







			   Makroassembler AS V1.41
			      Benutzeranleitung

                              Stand Februar 1997



			     Inhaltsverzeichnis




     1. Einleitung

      1.1. Lizenzbedingungen

      1.2. Lieferumfang

      1.3. allgemeine FÑhigkeiten des Assemblers

     2. Benutzung des Assemblers

      2.1. Hardware-Anforderungen

      2.2. Installation

      2.3. Aufruf, Parameter

      2.4. Format der Eingabedateien

      2.5. Format des Listings

      2.6. Symbolkonventionen

      2.7. FormelausdrÅcke

      2.8. Sharefile

      2.9. Prozessor-Aliasse

     3. Pseudobefehle

      3.1. Definitionen

       3.1.1. EQU und SET
       3.1.2. SFR und SFRB
       3.1.3. XSFR und YSFR
       3.1.4. LABEL
       3.1.5. BIT
       3.1.6. DBIT
       3.1.7. PORT
       3.1.8. CHARSET
       3.1.9. ENUM
       3.1.10. PUSHV und POPV

      3.2. Codebeeinflussung

       3.2.1. ORG
       3.2.2. CPU
       3.2.3. SUPMODE, PMMU und FPU
       3.2.4. FULLPMMU
       3.2.5. PADDING
       3.2.6. MAXMODE
       3.2.7. EXTMODE und LWORDMODE
       3.2.8. SRCMODE
       3.2.9. BIGENDIAN
       3.2.10. SEGMENT
       3.2.11. PHASE und DEPHASE
       3.2.12. SAVE und RESTORE
       3.2.13. ASSUME
       3.2.14. EMULATED

      3.3. Datendefinition

       3.3. 1. DC
       3.3. 2. DS
       3.3. 3. DB, DW, DD, DQ und DT
       3.3. 4. DS
       3.3. 5. BYT oder FCB
       3.3. 6. BYTE
       3.3. 7. ADR oder FDB
       3.3. 8. WORD
       3.3. 9. LONG
       3.3.10. SINGLE und EXTENDED
       3.3.11. FLOAT und DOUBLE
       3.3.12. EFLOAT, BFLOAT, TFLOAT
       3.3.13. Qxx und LQxx
       3.3.14. DATA
       3.3.15. ZERO
       3.3.16. FB und FW
       3.3.17. ASCII und ASCIZ
       3.3.18. STRING und RSTRING
       3.3.19. FCC
       3.3.20. DFS oder RMB
       3.3.21. BLOCK
       3.3.22. RES
       3.3.23. BSS
       3.3.24. DSB und DSW
       3.3.25. ALIGN
       3.3.26. LTORG

      3.4. Makrobefehle

       3.4.1. MACRO
       3.4.2. IRP
       3.4.3. REPT
       3.4.4. WHILE
       3.4.5. EXITM
       3.4.6. FUNCTION
      3.5. bedingte Assemblierung

       3.5.1. IF / ELSEIF / ENDIF
       3.5.2. SWITCH / CASE / ELSECASE / ENDCASE

      3.6. Listingsteuerung

       3.6.1. PAGE
       3.6.2. NEWPAGE
       3.6.3. MACEXP
       3.6.4. LISTING
       3.6.5. PRTINIT und PRTEXIT
       3.6.6. TITLE

      3.7. lokale Symbole

       3.7.1. Grunddefinition (SECTION/ENDSECTION)
       3.7.2. Verschachtelung und Sichtbarkeitsregeln
       3.7.3. PUBLIC
       3.7.4. FORWARD
       3.7.5. Geschwindigkeitsaspekte

      3.8. Diverses

       3.8.1. SHARED
       3.8.2. INCLUDE
       3.8.3. BINCLUDE
       3.8.4. MESSAGE, WARNING, ERROR und FATAL
       3.8.5. READ
       3.8.6. RELAXED
       3.8.7. END

     4. Prozessorspezifische Hinweise

      4.1. 6811

      4.2. DSP56000

      4.3. PowerPC

      4.4. H8

      4.5. SH7000/7600

      4.6. MELPS-4500

      4.7. MELPS-740

      4.8. MELPS-7700/65816

      4.9. M16

      4.10. MCS/48

      4.11. MCS/51

      4.12. MCS/251

      4.13. 8086..V35

      4.14. XA

      4.15. Z80UNDOC

      4.16. Z380

      4.17. TLCS-900

      4.18. TLCS-90

      4.19. TLCS-870

      4.20. TLCS-47

      4.21. TLCS-9000

      4.22. 29XXX

      4.23. 80C166/167

      4.24. PIC16C5x/16C8x

      4.25. PIC17C4x

      4.26. ST62xx

      4.27. 6804

      4.28. TMS3201x

      4.29. TMS3202x

      4.30. TMS32C03x

      4.31. TMS370xxx

      4.32  MSP430

      4.33. COP8

      4.34. 75K0

      4.35. 78K0

     5. Erzeugtes Datenformat

     6. Hilfsprogramme

       6.1. PLIST

       6.2. BIND

       6.3. P2HEX

       6.4. P2BIN

       6.5. AS2MSG


     A. Fehlermeldungen von AS

     B. E/A-Fehlermeldungen

     C. HÑufig gestellte Fragen

     D. Pseudobefehle gesammelt

     E. Vordefinierte Symbole

     F. Danksagungen

     G. énderungen seit Version 1.3

     H. Hinweise zum Quellcode von AS

       H.1 Sprachvoraussetzungen

       H.2 Modulaufteilung

       H.3 Neuer Prozessor...was nun ?

       H.4 RSC...was ist das denn?

     I. Literaturhinweise


----------------------------------------------------------------------------

	1. Allgemeines
	==============

Diese Anleitung wendet sich an Leute, die bereits in Assembler pro-
grammiert haben und sich darÅber informieren mîchten, wie man mit
AS umgeht.  Sie hat eher die Form eines Referenz- und nicht Benut-
zerhandbuches.  Als solches macht sie weder den Versuch, die Sprache
Assembler an sich zu erklÑren, noch erlÑutert sie die Architektur
bestimmter Prozessoren.  Im Literaturverzeichnis habe ich weiter-
fÅhrende Literatur aufgelistet, die bei der Implementation der ein-
zelnen Codegeneratoren ma·gebend war.  Um Assembler von Grund auf zu
lernen, kenne ich kein Buch; ich habe es im wesentlichen im "Trial and
error"-Verfahren gelernt.

	1.1 Lizenzbedingungen
	---------------------

Bevor es in medias res geht, erst einmal der unvermeidliche Prolog:

AS in der vorliegenden Version gebe ich als "Public Domain" weiter,
d.h. die Programm-und Overlaydatei sowie die dazugehîrenden Hilfs-
programme dÅrfen frei kopiert und benutzt werden.  Es existieren
keine Planungen, AS in ein kommerzielles oder Shareware-Programm
umzuwandeln. Diese Erlaubnis gilt jedoch nur unter der Voraussetzung,
da· die Startmeldung der Programme - insbesondere die Copyrightmel-
dung - nicht entfernt oder Åberschrieben wird und fÅr das Kopieren/
Verschicken nicht mehr als eine AufwandsentschÑdigung ( <=DM 20,-)
verlangt wird.

Auf Anfrage wird auch der Quellcode dieses Programmes ausgegeben.
Daraus abgeleitete oder darauf aufbauende Programme mÅssen unter
den gleichen Bedingungen weitergegeben werden wie dieses Programm.

Ich fordere ausdrÅcklich dazu auf, dieses Programm per Diskette oder
Mailbox/Netzwerk zu verbreiten!

Es mag sein, da· Sie dieses Programm als Beilage zu einem kommer-
ziellen Programm erhalten haben.  Die fÅr das kommerzielle Programm
geltenden Lizenzbedingungen beziehen sich jedoch auf keinen Fall
auf AS.

Sollte Ihnen der Assembler so gut gefallen, da· sie mir unbedingt
Geld dafÅr schicken wollen, so fordere ich Sie dazu auf, den Be-
trag fÅr Greenpeace zu spenden.

Ich habe mich bemÅht, das Programm so fehlerfrei wie nur irgendmîg-
lich zu machen.  Da es aber grundsÑtzlich keine fehlerfreie Software
gibt (die einzigen Leute, die keine Fehler machen, liegen auf dem
Friedhof!), Åbernehme ich keine Garantie fÅr die Funktion von AS
in einer bestimmten Umgebung (Hard-oder Software) oder Haftung fÅr
entstehende SchÑden.  FÅr Hinweise auf Fehler bin ich selbstverstÑnd-
lich immer dankbar und werde mich bemÅhen, sie zu korrigieren.

Um eine mîglichst schnelle Fehlerdiagnose und -korrektur zu ermîg-
lichen, bitte ich, dem Fehlerbericht folgende Angaben beizufÅgen:

 - Hardware:  - Prozessortyp  ( mit/ohne Koprozessor )
	      - Speicherausbau
	      - Grafikkarte
	      - Festplatte und Typ deren Interfaces

 - Software:  - Betriebssystem ( MS/DR/Novell-DOS, OS/2, Windows )
                und Version
	      - installierte speicherresidente Programme
	      - benutzte Version von AS + Datum des EXE-Files

 - mîglicht die Quelldatei, bei der der Fehler auftritt

Zu erreichen bin ich folgenderma·en:

  per Post :  Alfred Arnold
              Brîltalstr. 5a
              53773 Hennef(Sieg)

  per E-Mail : direkt :
		a.arnold@kfa-juelich.de
	       Åber den Computerclub:
		ccac@rog.rwth-aachen.de

Sofern Sie die letztere E-Mail-Adresse benutzen, fÅgen Sie der
Nachricht bitte einen Hinweis bei, da· diese an mich (Alfred
Arnold/Turbo-Pascal-Gruppe) gerichtet ist.

Wer mir persînlich Fragen stellen will (und in der NÑhe von Aachen
wohnt), kann dies mit hoher Wahrscheinlichkeit donnerstags von 19.00
bis 21.00 Uhr im Computerclub an der RWTH Aachen (Eilfschornstein-
stra·e 16, Keller PhilosophengebÑude RÅckseite).

Von Telefonanrufen bitte ich abzusehen.  Erstens, weil sich die
komplizierten ZusammenhÑnge am Telefon nur Ñu·erst schwer erîrten
lassen, und zweitens ist die Telekom schon reich genug...

Die neueste Version von AS findet sich auf folgendem FTP-Server:

 ftp.rus.uni-stuttgart.de
   Verzeichnis  pub/systems/pc/programming/as

Wer Åber keinen FTP-Zugang verfÅgt, kann den Assembler auch von mir
anfordern.  Ich werde aber nur Anfragen beantworten, die zwei
Disketten (fÅr 720K/1,2M-Format 4/3 StÅck) und einen passenden, fran-
kierten RÅckumschlag enthalten.  KEIN Geld schicken!!!

So. Nach diesem unvermeidlichen Vorwort kînnen wir wohl beruhigt
zur eigentlichen Anleitung schreiten:



	1.2. Lieferumfang
	-----------------

Das von mir ausgegebene Paket beinhaltet folgende Dateien:

    Datei               Funktion
    -----               --------

   AS.EXE               Assembler
   AS.OVR               Overlay zum Assembler

   AS.DOC               diese Datei mit der Anleitung

   PLIST.EXE            Listet Inhalt von Codedateien auf
   BIND.EXE             kopiert Codedateien zusammen
   P2HEX.EXE            wandelt Codedateien in Hexdateien um
   P2BIN.EXE            wandelt Codedateien in BinÑrdateien um

   80C552.INC		Registeradressen 80C552
   STDDEF04.INC		Registeradressen 6804
   STDDEF16.INC         Befehlsmakros und Registeradressen PIC16C5x
   STDDEF17.INC         Registeradressen PIC17C4x
   STDDEF18.INC         Registeradressen PIC16C8x
   STDDEF2X.INC         Registeradressen TMS 3202x
   STDDEF37.INC         Register- & Bitadressen TMS370xxx
   STDDEF3X.INC         Peripherieadressen TMS 320C3x
   STDDEF3X.INC         Peripherieadressen TMS 320C5x
   STDDEF47.INC         Befehlsmakros TLCS-47
   STDDEF51.INC         Definition von SFRs und Bits fÅr 8051/8052/
			80515
   STDDEF56.INC         Registeradressen DSP56000
   STDDEF60.INC         Befehlsmakros & Registeradressen PowerPC
   STDDEF62.INC         Registeradressen & Makros ST62xx
   STDDEF75.INC         Registeradressen 75K0
   STDDEF87.INC         Register- & Speicheradressen TLCS-870
   STDDEF90.INC		Register- & Speicheradressen TLCS-90
   STDDEF96.INC 	Register- & Speicheradressen TLCS-900
   STDDEFXA.INC         SFR- & Bitadressen Philips XA
   STDDEFZ8.INC         Registeradressen Z8-Familie
   REG166.INC           Adressen & Befehlsmakros 80C166/167
   REG251.INC           Adressen & Bits 80C251
   REG29K.INC           Peripherieadressen AMD 2924x
   REG53X.INC           Registeradressen H8/53X
   REG683XX.INC         Registeradressen 68332/68340/68360
   REG78K0.INC          Register- und Speicheradressen 78K0
   REG96.INC            Registeradressen 8096
   REGAVR.INC           Registeradressen Atmel AVR
   REGCOP8.INC          Registeradressen COP8
   REGHC12.INC          Registeradressen Motorola 68HC12...
   REGM16C.INC          Registeradressen Mitsubishi M16C
   REGMSP.INC           Befehlsmakros & Registeradressen MSP430
   REGZ380.INC          On-Chip-Register Z380
   CTYPE.INC            Standardfunktionen zur Analyse von Zeichen
   BITFUNCS.INC		Standardfunktionen zur Bitmanipulation

   DEMOCODE.ASM		Beispielprogramme fÅr die Nutzung des Assemblers
   DEMOMAC.ASM
   DEMOPHAS.ASM
   DEMOLIST.ASM

Falls eine der Dateien fehlt, hat jemand (im Zweifelsfalle ich) beim
Kopieren geschlafen...


	1.3. allgemeine FÑhigkeiten des Assemblers
	------------------------------------------

AS bietet im Gegensatz zu normalen Assemblern die Mîglichkeit, Code
fÅr vîllig verschiedene Prozessoren zu erzeugen.  Momentan sind fol-
gende Prozessorfamilien implementiert:

 - Motorola 68000..68030,683xx inkl. Koprozessor und MMU
 - Motorola DSP56000
 - Motorola/IBM MPC601/MPC505/PPC403
 - Motorola 6800, 6805, 68HC08, 6809, 68(HC)11, 68HC12, 68HC16 sowie Hitachi 6301
 - Hitachi 6309
 - Hitachi H8/300(H)
 - Hitachi H8/500
 - Hitachi SH7000/7600
 - Rockwell 6502 und 65(S)C02
 - CMD 65816
 - Mitsubishi MELPS-740
 - Mitsubishi MELPS-7700
 - Mitsubishi MELPS-4500
 - Mitsubishi M16
 - Mitsubishi M16C
 - Intel MCS-48/41
 - Intel MCS-51/251
 - Intel MCS-96
 - Intel 8080/8085
 - Philips XA
 - Atmel AVR
 - AMD 29K
 - Siemens 80C166/167
 - Zilog Z80, Z180, Z380
 - Zilog Z8
 - Toshiba TLCS-900(L)
 - Toshiba TLCS-90
 - Toshiba TLCS-870
 - Toshiba TLCS-47
 - Toshiba TLCS-9000
 - Microchip PIC16C54..16C57
 - Microchip PIC16C84/PIC16C64
 - Microchip PIC17C42
 - SGS-Thomson ST62xx
 - SGS-Thomson 6804
 - Texas Instruments TMS32010/32015
 - Texas Instruments TMS3202x
 - Texas Instruments TMS320C3x
 - Texas Instruments TMS320C5x
 - Texas Instruments TMS370xxx
 - Texas Instruments MSP430
 - National Semiconductor COP8
 - NEC ÊPD 78(C)1x
 - NEC ÊPD 75xxx (alias 75K0)
 - NEC ÊPD 78xxx (alias 78K0)

in Arbeit / Planung / öberlegung :

 - SGS-Thomson ST9
 - National Semiconductor SC/MP
 - Texas Instruments TMS7000
 - Texas Instruments TMS9900
 - SGS-Thomson ST7
 - Signetics 8x300
 - SGS-Thomson ST20
 - Toshiba TC9331
 - Intel i960
 - Analog Devices ADSP21xx

Noch gesucht werden Unterlagen fÅr:

 - Texas Instruments TMS320C4x
 - Texas Instruments TMS320C8x (die kostenlose CD ist vergriffen
   und die Preise fÅr den angekÅndigten Nachfolger sind mir zu
   hoch, um "just for fun" etwas zu implementieren)

ungeliebt, aber DOCH vorhanden :

 - Intel 80x86, 80186, Nec V30&V35 inkl. Koprozessor 8087

Die Umschaltung des Codegenerators darf dabei auch mitten in der Da-
tei erfolgen, und das beliebig oft!

Der Grund fÅr diese FlexibilitÑt ist, da· AS eine Vorgeschichte hat,
die auch in der Versionsnummer deutlich wird: AS ist als Erweiterung
eines Makroassemblers fÅr die 68000er-Familie entstanden.  Auf beson-
deren Wunsch habe ich den ursprÅnglichen Assembler um die FÑhigkeit
zur öbersetzung von 8051-Mnemonics erweitert, und auf dem Weg (Ab-
stieg?!) vom 68000 zum 8051 sind die anderen fast nebenbei abgefal-
len... Die Versionsnummer ist also nicht nur Marketing, sondern sie
drÅckt wirklich aus, da· dies hier keine 1.0er Version mit Kinder-
krankheiten ist (was nichts am Gewicht des in Teil 1.1 gesagten Ñn-
dert).

Diese FlexibilitÑt bedingt ein etwas exotisches Codeformat, fÅr des-
sen Bearbeitung ich einige Tools beigelegt habe.  Deren Beschreibung
findet sich in Kapitel 6.

AS ist ein Makroassembler, d.h. dem Programmierer ist die Mîglichkeit
gegeben, sich mittels Makros neue "Befehle" zu definieren.  ZusÑtz-
lich beherrscht er die bedingte Assemblierung.  Labels in MakrorÅmpfen
werden automatisch als lokal betrachtet.

Symbole kînnen fÅr den Assembler sowohl Integer-, String- als auch
Gleitkommawerte haben.  Diese werden - wie Zwischergebnisse bei
Formeln - mit einer Breite von 32 Bit fÅr Integerwerte, 80 Bit fÅr
Gleitkommawerte und 255 Zeichen fÅr Strings gespeichert.  FÅr die
Intel-Mikrokontroller besteht die Mîglichkeit, durch Segmentbildung
die Symbole bestimmten Klassen zuzuordnen.  Dem Assembler kann man
auf diese Weise die - begrenzte - Mîglichkeit geben, Zugriffe in fal-
sche Adre·rÑume zu erkennen.

Der Assembler kennt keine expliziten BeschrÑnkungen bzgl. Verschach-
telungstiefe von Includefiles oder Makros, eine Grenze bildet ledig-
lich die durch den Hauptspeicher beschrÑnkte Rekursionstiefe.  Eben-
so gibt es keine Grenze fÅr die SymbollÑnge, diese wird nur durch
die maximale ZeilenlÑnge begrenzt.

Ab Version 1.38 ist AS ein Mehrpass-Assembler.  Dieser hochtrabende
Begriff bedeutet nicht mehr, als das die Anzahl der DurchgÑnge durch
die Quelltexte nicht mehr zwei sein mu·.  Sind keine VorwÑrtsrefe-
renzen im Quellcode enthalten, so kommt AS mit einem Durchgang aus.
Stellt sich dagegen im zweiten Durchgang heraus, da· ein Befehl mit
einer kÅrzeren oder lÑngeren Kodierung benutzt werden mu·, so wird
ein dritter (vierter, fÅnfter...) Durchgang eingelegt, um alle Sym-
bolreferenzen richtig zu stellen.  Mehr steckt hinter dem Begriff
"Multipass" nicht...er wird im weiteren Verlauf dieser Anleitung
deswegen auch nicht mehr auftauchen.

Nach soviel Lobhudelei ein dicker Wermutstropfen: AS erzeugt keinen
linkfÑhigen Code.  Eine Erweiterung um einen Linker wÑre mit erheb-
lichem Aufwand verbunden und ist momentan nicht in Planung.

Zum Thema "Herausgabe von Sourcen": Die Sourcen von AS sind nicht
in einer Form, die ein einfaches VerstÑndnis ermîglicht (== null
Kommentare).  Sourcen werde ich daher nur fÅr den Fall herausgeben,
da· jemand wirklich damit etwas anfangen will (z.B. AS auf einen
anderen Rechner portieren) und das daraus entstehende wiederum
Public Domain wird.  Insbesondere will ich verhindern, da· jemand
5 Zeilen Ñndert (bevorzugt den Copyrighteintrag) und das Ergebnis
dann kommerziell als "sein" Programm vertreibt.

Zur offensichtlich unvermeidlichen Frage, ob es denn einmal eine Win-
dows-Version geben wird: Ich bin der Ansicht, da· man ein System,
wenn es offensichtlicher Bockmist ist, nicht auch noch durch Pro-
gramme unterstÅtzen sollte!  FÅr Leute, die nicht unter DOS arbei-
ten wollen oder akute Speicherprobleme haben, gibt es sowohl eine
DOS-DPMI- als auch eine OS/2-Version.  Eine C-Version, die auf einer
Reihe von UNIX-Systemen (inkl. Linux) Åbersetzbar ist, ist in Arbeit,
ist aber noch nicht 100%ig ausgereift.  Da aber nicht jeder diese
anderen Versionen braucht, gebe ich sie in getrennten Paketen aus.


	2.Benutzung des Assemblers
	==========================


        2.1. Hardware-Anforderungen
        ---------------------------

Da AS ein reines DOS-Program ist, lÑuft er prinzipiell auf allen 
IBM-kompatiblen PCs, angefangen vom PC/XT mit vierkommawenig Mega-
herz bis hin zum Pentium.  Wie bei vielen anderen Programmen aber 
auch, steigt der Lustgewinn mit der Hardware-Ausstattung.  So dÅrf-
te ein XT-Benutzer ohne Festplatte erhebliche Probleme haben, die 
Åber 500 kByte gro·e Overlay-Datei von AS auf einer Diskette unter-
zubringen...eine Festplatte sollte der PC also schon haben, allein 
um vernÅnftige Ladezeiten zu erreichen.  Im Hauptspeicherbedarf ist
AS recht genÅgsam: Das Programm selber belegt knapp 300 kByte 
Hauptspeicher, AS sollte also ab einer Hauptspeichergrî·e von 512
kByte ausfÅhrbar sein.


        2.2. Installation
        -----------------

Eine besondere Installation ist fÅr die Nutzung von AS nicht erfor-
derlich, es genÅgt, alle EXE- sowie OVR-Dateien in ein Verzeichnis
kopieren, das in der PATH-Variable auftaucht.  Ob man ein bestehen-
des Verzeichnis nutzt oder ein neues anlegt, ist dabei egal.  Die
Dokumentation, Beispielprogramme sowie Includefiles kînnen vîllig
nach belieben verteilt werden...als Beispiel hier eine Installation,
die ein UNIX-AnhÑnger vornehmen wÅrde:

Legen Sie folgende Verzeichnise an (im folgenden nehme ich an, da·
Sie AS auf Laufwerk C installieren wollen):

c:\as
c:\as\bin
c:\as\include
c:\as\lib
c:\as\doc
c:\as\demos

Als erstes kopieren Sie alle EXE- sowie OVR-Dateien aus dem Archiv in
das bin-Verzeichnis; um dieses Verzeichnis ergÑnzen Sie dann auch die
PATH-Anweisung in Ihrer AUTOEXEC.BAT.  In das include-Verzeichnis 
kommen alle INC-Dateien.  In dem lib-Verzeichnis erzeugen Sie eine
Datei AS.RC mit folgendem Inhalt:

-i c:\as\include

Diese sogenannte Key-Datei zeigt AS, in welchem Verzeichnis er seine 
Include-Dateien suchen soll.  Damit AS diese Key-Datei bei Start 
auch beachtet, mu· noch folgende Anweisung in die AUTOEXEC.BAT:

set ASCMD=@c:\as\lib\as.rc

Was Sie alles noch in der Key-Datei voreinstellen kînnen, steht im
folgenden Abschnitt.  Zuguterletzt wandern noch alle DOC-Dateien
ins gleichnamige Verzeichnis sowie die Demo-Assemblerquellen ins
demos-Verzeichnis.  Das war's auch schon!


	2.3. Aufruf, Parameter
	----------------------

AS ist ein kommandozeilengesteuertes Programm, d.h. alle Parameter
und Dateiangaben sind in der Kommandozeile anzugeben.  Um den Spei-
cherbedarf nicht ins Unerme·liche zu steigern, wurden die verschie-
denen Codegeneratormodule in eine Overlaydatei verlegt, deren Exis-
tenz der Assembler sofort nach Programmstart prÅft.  Findet er die-
se nicht, so ist der Programmlauf auch schon an dieser Stelle zu En-
de...die Datei AS.OVR sollte sich immer im gleichen Verzeichnis wie
das EXE-File befinden.

Die Verwendung von Overlays ergibt naturgemÑ· etwas Overhead.  AS
versucht diesen aber zu reduzieren, indem er eventuell vorhandenen
EMS- oder XMS-Speicher zur Ablage von Overlays nutzt.  Sollte dies
zu Problemen fÅhren, so kînnen Sie die Verwendung von EMS bzw. XMS
unterbinden, indem Sie einer Environment-Variablen USEXMS bzw.
USEEMS den Wert n zuweisen.  So kann man z.B. mit dem Befehl

   SET USEXMS=n

die Verwendung von extended memory verhindern.

Da AS alle Ein-und Ausgaben Åber DOS abwickelt (und daher auch auf
nicht ganz so kompatiblen PC's laufen sollte) und eine rudimentÑre
Bildschirmsteuerung benîtigt, gibt er wÑhrend der Assemblierung ANSI-
Steuersequenzen aus.  Falls Sie in den Ausgaben von AS also seltsame
Zeichen sehen sollten, fehlt offensichtlich in Ihrer CONFIG.SYS eine
Zeile der Art

   device=ansi.sys  ,

die weitere Funktion von AS wird dadurch aber nicht beeinflu·t.  Al-
ternativ kînnen Sie aber auch die Ausgabe von ANSI-Sequenzen durch
das Setzen der Environment-Variablen USEANSI auf n ganz unterdrÅcken.

Die Parameter kînnen grob in zwei Klassen eingeteilt werden: Schalter
und Dateispezifikationen.  Parameter dieser beiden Klassen kînnen be-
liebig gemischt in der Kommandozeile auftreten, AS wertet zuerst alle
Parameter aus und assembliert dann die angegebenen Dateien.  Daraus
folgen zwei Dinge:

 - Die angegebenen Schalter wirken auf alle angegebenen Quelldateien.
   Sollen mehrere Quelldateien mit unterschiedlich gesetzten Schaltern
   assembliert werden, so mu· dies in getrennten LÑufen erfolgen.

 - Es kînnen in einem Durchgang mehrere Dateien assembliert werden.
   Um der Sache die Krone aufzusetzen, dÅrfen die Dateiangaben Joker-
   zeichen enthalten.

Schalterparameter erkennt AS daran, da· sie durch einen SchrÑgstrich
(/) oder Bindestrich (-) eingeleitet werden.  Es gibt dabei sowohl
Schalter, die nur aus einem Buchstaben bestehen, als auch Schalter,
die aus einem ganzen Wort bestehen.  Immer wenn AS einen Schalter
nicht als "Wort-Schalter" verstehen kann, so versucht er, die Buch-
staben des Wortes als einzelne Schalter zu interpretieren.  Wenn man
also z.B.

 -queit

anstelle von

 -quiet

geschrieben hÑtte, wÅrde AS die Buchstaben q, u, e, i und t als ein-
zelne Schalter auffassen.  Mehrbuchstabige Schalter unterscheiden
sich weiterhin von einbuchstabigen dadurch, da· AS bei Ihnen belie-
bige Gro·-und Kleinschreibungen akzeptiert, wÑhrend einbuchstabige
Schalter je nach Gro·- oder Kleinschreibung unterschiedliche Bedeutung
haben.

Momentan sind folgende Schalter definiert:

 -  l : Assemblerlisting auf Konsole ausgeben.  Falls mehrere Passes
        ausgefÅhrt werden mÅssen, landen im Gegensatz zur nÑchsten
	Option die Listings aller DurchgÑnge auf der Ausgabe!
 -  L : Assemblerlisting auf Datei schreiben.  Die Listdatei erhÑlt
	dabei den gleichen Namen wie die Quelldatei, lediglich die
	Endung wird durch LST ersetzt.

 -  o : Bestimmt einen neuen Namen fÅr die von AS zu erzeugende
        Code-Datei.  Wird diese Option mehrfach verwendet, so werden
        die angegebenen Namen nacheinander den zu assemblierenden
        Quelldateien zugeordnet; Negation (s.u.) dieser Option in
        Verbindung mit einem Namen lîscht den Namen aus der Liste;
	Negation ohne Namensangabe lîscht die komplette Liste.

 -  c : SHARED-Variablen werden in einem Format abgelegt, das die
	Einbindung in eine C-Quelldatei erlaubt.  Die Endung der
	Datei ist H .
 -  p : SHARED-Variablen werden in einem Format abgelegt, das die
	Einbindung in den CONST-Block eines Pascal-Programmes er-
	laubt.  Die Endung der Datei ist INC .
 -  a : SHARED-Variablen werden in einem Format abgelegt, das die
	Einbindung in eine Assembler-Quelldatei erlaubt.  Die Endung
	der Datei ist INC .

Zu Sinn und Funktion der SHARED-Symbole siehe Kapitel 2.6. bzw. 3.8.1.

 -  w : Ausgabe von Warnungen unterdrÅcken

 -  E [Datei] : Die von AS erzeugten Fehlermeldungen und Warnungen in
		eine Datei umleiten.  Anstatt einer Datei kînnen auch
		die 5 Standardhandles (STDIN..STDPRN) als !0 bis !4
		angegeben werden.  Default ist !2, also STDERR.
		Wird die Dateiangabe weggelassen, so ist der Name der
		Fehlerdatei gleich dem der Quelldatei, nur mit der
		Endung LOG.

 -  q : Dieser Schalter unterdrÅckt alle Meldungen von AS mit Aus-
        nahme von Fehlermeldungen und vom Programm selber erzeugten
        Ausgaben.  Die Assemblierzeit kann dadurch geringfÅgig
        reduziert werden, und beim Aufruf aus einer Shell heraus kann
        man sich eine Umleitung ersparen.  Der Nachteil ist, da· man
        u.U. einige Minuten "im Dunklen" steht...  Anstelle von 'q'
        darf auch 'quiet' geschrieben werden.

 -  h : Hexadezimalzahlen mit Klein- anstelle von Gro·buchstaben aus-
	geben. Diese Option ist in erster Linie eine Frage des per-
	sînlichen Geschmacks.

 -  i <Pfadliste> : gibt eine Liste von Verzeichnissen an, in denen
		    der Assembler automatisch nach Includedateien
		    suchen soll, falls er diese nicht im aktuellen
		    Verzeichnis findet. Die einzelnen Verzeichnisse
                    mÅssen durch Semikolons getrennt werden.

 -  u : eine Liste der in den Segmenten belegten Bereiche berechnen.
	Diese Option ist nur wirksam, falls ein Listing erzeugt
	wird.  Diese Option benîtigt erhebliche zusÑtzliche Spei-
	cher-und Rechenleistung, im Normalbetrieb sollte sie daher
	abgeschaltet sein.

 -  C : erzeugt eine Liste mit Querverweisen.  Aufgelistet wird,
	welche (globalen) Symbole in welchen Dateien in welchen
	Zeilen benutzt werden.  Auch diese Liste wird nur gene-
	riert, falls ein Listing erzeugt wird und belegt wÑhrend
        der Assemblierung zusÑtzlichen Speicherplatz.

 -  s : eine Liste aller Sektionen (s. Abschnitt 3.7) ausgeben.
	Die Verschachtelung wird dabei durch EinrÅckungen
	angedeutet.

 -  I : Analog zur Sektionsliste eine Liste aller bearbeiteten
        Include-Dateien ausgeben.

 -  t : Mit diesem Schalter lassen sich einzelne Komponenten des
	standardmÑ·ig ausgegebenen Assemblerlistings ein-und aus-
	blenden.  Welcher Teil dabei welchem Bit zugeordnet ist, ist
	im ÅbernÑchsten Abschnitt, der genauer auf das Format des
	Assemblerlistings eingeht, nachgelesen werden.

 -  D : Symbole definieren.  Die hinter dieser Option angegebenen,
	durch Kommas getrennten Symbole werden in der globalen
	Symboltabelle vor Beginn der Assemblierung abgelegt.
	DefaultmÑ·ig werden diese Symbole als ganze Zahlen mit dem
	Wert TRUE abgelegt, mit einem nachgestellten Gleichheits-
	zeichen kann aber auch eine andere Belegung gewÑhlt werden.
	Der dem Gleichheitszeichen folgende Ausdruck darf dabei auch
	Operatoren oder interne Funktionen beinhalten, jedoch KEINE
	anderen Symbole, selbst wenn diese schon davor in der Liste
	definiert sein sollten!  Zusammen mit den Befehlen zur be-
	dingten  Assemblierung (siehe dort) kînnen so per Kommando-
	zeile aus einer Quelldatei unterschiedliche Programmver-
	sionen erzeugt werden.


 -  A : Die Liste globaler Symbole in einer anderen, kompakteren Form
	ablegen.  Verwenden Sie diese Option, wenn der Assembler bei
	langen Symboltabellen mit einem StapelÅberlauf abstÅrzt.
	Eventuell kann diese Option die Arbeitsgeschwindigkeit des
	Assemblers erhîhen, dies hÑngt jedoch von den Quellen ab.

 -  x : So vorhanden, wird bei Fehlern noch eine erweiterte Meldung
	ausgegeben, anhand der die Identifizierung des Fehlers erleich-
	tert werden soll.  Welche Fehlermeldungen welche Zusatzin-
	formationen tragen kînnen, steht im Anhang mit der Liste aller
	Fehlermeldungen.

 -  n : Wird diese Option angegeben, so werden Fehlermeldungen nicht
	nur mit ihrem Klartext, sondern auch mit ihren im Anhang
	genannten internen Nummern ausgegeben.  Diese Option ist
	primÑr fÅr Shells und Entwicklungsumgebungen gedacht, denen
	mit diesen Nummern die Identifizierung von Fehlern erleichtert
	werden soll.

 -  U : Mit dieser Option schaltet man AS in den case-sensitiven
        Modus um, d.h. in Namen von Symbolen, Sektionen, Makros
        und selbstdefinierte Funktionen werden Klein- und Gro·buchstaben
        unterschieden, was normalerweise nicht der Fall ist.

 -  P : weist AS an, den von Makroprozessor und bedingter Assemblie-
	rung bearbeiteten Quelltext in einer Datei abzulegen.  Dieser
	Datei fehlen zusÑtzlich Leer- und reine Kommentarzeilen.  Die
	Endung der Datei ist I.

 -  M : mit diesem Schalter erzeugt AS eine Datei, in der die Defini-
	tionen der Makros aus der Quelldatei abgespeichert werden, die
	nicht die NOEXPORT-Option verwenden.  Diese neue Datei
	hat den gleichen Namen wie die Quelldatei, lediglich die
	Endung wird in MAC geÑndert.

 -  G : Dieser Schalter bestimmt, ob AS Code erzeugen soll oder nicht.
	Ist er ausgeschaltet, wird die Datei zwar assembliert, aber
        keine Code-Datei geschrieben.  Dieser Schalter ist defaultmÑ·ig
	aktiviert (logisch, sonst bekÑme man ja auch gar kein Code-
	file).  

 -  r [n] : Warnungen ausgeben, falls Situationen eintreten, die
            einen weiteren Pass erfordern.  Diese Information kann
	    genutzt werden, um die Anzahl der DurchlÑufe zu
	    verringern.  Optional kann man die Nummer des Passes
	    angeben, ab dem diese Warnungen erzeugt werden; ohne
	    Angabe kommen die Warnungen ab dem ersten Pass.  Machen
	    Sie sich aber so oder so auf einen ziemlichen Haufen an
	    Meldungen gefa·t!!

 - alias <neu>=<alt> :
        definiert den Prozessortyp <neu> als einen Alias fÅr den
	Typen <alt>.  Zu den Sinn und Zweck von Aliassen siehe
	Abschnitt 2.7.

Sofern Schalter keine Argumente benîtigen und ihre Zusammenziehung
keinen mehrbuchstabigen Schalter ergibt, kînnen mehrere Schalter
auch auf einen Rutsch angegeben werden, wie z.B im folgenden Bei-
spiel:

 as test*.asm firstprog -cl /i c:\as\8051\include

Es werden alle Dateien TEST*.ASM sowie die Datei FIRSTPROG.ASM assem-
bliert, wobei fÅr alle Dateien Listings auf der Konsole ausgegeben
und Sharefiles im C-Format erzeugt werden.  Nach Includes soll der
Assembler zusÑtzlich im Verzeichnis C:\AS\8051\INCLUDE suchen.

Dieses Beispiel zeigt, da· AS als Defaultendung fÅr Quelldateien ASM
annimmt.

Neben der Angabe in der Kommandozeile kînnen dauernd benîtigte
Optionen in der Environment-Variablen ASCMD abgelegt werden. Wer z.B.
immer Listdateien haben mîchte und ein festes Includeverzeichnis hat,
kann sich mit dem Befehl

 set ascmd=-L -i c:\as\8051\include

eine Menge Tipparbeit ersparen.  Da die Environment-Optionen vor der
Kommandozeile abgearbeitet werden, kînnen Optionen in der Kommando-
zeile widersprechende im Environment Åbersteuern.

Bei sehr langen Pfaden kann es jedoch auch in der ASCMD-Variablen eng
werden.  FÅr solche FÑlle kann auf eine sog. Key-Datei ausgewichen
werden, in der die Optionen genauso wie in der Kommandozeile oder
ASCMD-Variablen abgelegt werden kînnen, nur da· diese Datei mehrere
Zeilen mit jeweils maximal 255 Zeichen enthalten darf.  Wichtig ist
dabei, da· bei Optionen, die ein Argument benîtigen, sowohl Schalter
als auch Argument in EINER Zeile stehen mÅssen.  Der Name der Datei
wird AS dadurch mitgeteilt, da· er mit einem vorangestellten Klammer-
affen in der ASCMD-Variablen abgelegt wird, z.B.

 set ASCMD=@c:\as\as.key

Um Optionen in der ASCMD-Variablen (oder der Key-Datei) wieder aufzu-
heben, kann die Option mit einem vorangestellten Pluszeichen wieder
aufgehoben werden.  Soll in einem Einzelfall z.B. doch kein Listing
erzeugt werden, so kann es mit

 as +L <Datei>

wieder aufgehoben werden.  NatÅrlich ist es nicht ganz logisch, eine
Option mit einem Pluszeichen zu negieren...UNIX soit qui mal y pense.

FÅr den Fall, da· Sie AS von einem anderen Programm oder einer Shell
aufrufen wollen und diese Shell nur Klein- oder Gro·buchstaben in der
Kommandozeile Åbergeben will, existiert folgendes Workaround: Wird
vor den Buchstaben der Option eine Tilde gesetzt, so werden die
folgenden Buchstaben immer als Kleinbuchstaben interpretiert.  Analog
erzwingt ein Lattenzaun die Interpretation als Gro·buchstaben.  Es
ergeben sich z.B. folgende Transformationen:

 /~I ---> /i
 -#u ---> -U

AbhÑngig vom Ablauf der Assemblierung endet der Assembler mit fol-
genden Returncodes:

 0 : fehlerfreier Ablauf, hîchstens Warnungen aufgetreten
 1 : Der Assembler hat nur die Aufrufparameter ausgegeben und endete
     danach sofort.
 2 : Es sind Fehler bei der Assemblierung aufgetreten, es wurde kein
     Codefile erzeugt.
 3 : Es trat ein fataler Fehler wÑhrend des Ablaufes auf, der zum
     sofortigen Abbruch gefÅhrt hat.
 4 : Bereits wÑhrend des Starts des Assemblers ist ein Fehler auf-
     getreten.  Dies kann ein Parameterfehler oder eine fehlerhafte
     Overlay-Datei sein.
255: Bei der Initialisierung ist irgendein interner Fehler aufgetre-
     ten, der auf keinen Fall auftreten sollte...neu booten, noch
     einmal probieren, und bei Reproduzierbarkeit mit mir Verbindung
     aufnehmen!


	2.4. Format der Eingabedateien
	------------------------------

Wie die meisten Assembler auch erwartet AS genau einen Befehl pro Zeile
(Leerzeilen sind natÅrlich auch zugelassen).  Die Zeilen dÅrfen nicht
lÑnger als 255 Zeichen werden, darÅber hinaus gehende Zeichen werden
abgeschnitten.

Eine einzelne Zeile hat folgendes Format:

[Label[:]] <Befehl>[.Attribut] [Parameter[,Parameter..]] [; Kommentar]

Der Doppelpunkt nach dem Label ist optional, falls das Label in der
ersten Spalte beginnt (woraus folgt, da· der Befehl niemals in Spalte
1 beginnen darf).  Man mu· ihn aber setzen, falls das Label nicht
in der ersten Spalte beginnt, damit AS es von einem Befehl unter-
scheiden kann.  In letzterem Fall mu· Åbrigens zwischen Doppelpunkt
und dem Befehl mindestens ein Leerzeichen stehen, falls der eingestell-
te Zielprozessor zu denjenigen gehîrt, bei denen das Attribut auch
eine mit einem Doppelpunkt abgetrennte Formatangabe sein darf.  Dieser
Knopf ist aus EindeutigkeitsgrÅnden nîtig, da sonst keine Unter-
scheidung zwischen Befehl mit Format und Label mit Befehl mîglich
wÑre.

Bei 680x0, SH7000, TLCS-9000, M16(C), XA, MSP430 sowie H8 dient ein 
dem Befehl mit einem Punkt angehÑngtes Attribut zur Beschreibung der 
Operandengrî·e.  Folgende Attributbuchstaben sind definiert:

   Attribut     arithmetisch-logischer Befehl      Sprungbefehl

      B		 Byte (8 Bit)		             -------

      W/H	 Wort (16 Bit)                       -------

      L/D/W      Langwort (32 Bit)              16-Bit-Displacement

      Q          Vierfachwort (64 Bit)               -------

      S          Single Precision (32 Bit)       8-Bit-Displacement

      D          Double Precision (64 Bit)           -------

      X		 Extended Precision (80/96 Bit) 32-Bit-Displacement

      P          Dezimalgleitkomma (80/96 Bit)       -------

Achtung: Nicht alle Befehle erlauben alle Operandengrî·en, und manche
Befehle haben gar kein Attribut.  Zum genaueren Studium greife man auf
ein vernÅnftiges Programmierhandbuch zurÅck, z.B. in [Williams] fÅr
die 68000er-Familie.

Bei TLCS-9000, H8/500 und M16(C) dient das Attribut sowohl der Angabe 
der Operandengrî·e, falls diese nicht durch die Operanden klar sein 
sollte, als auch der des zu verwendenden Befehlsformates.  Dieses mu·
durch einen Doppelpunkt von der Operandengrî·e getrennt werden, z.B.
so:

    add.w:g   rw10,rw8

Was dieses Beispiel nicht zeigt, ist, da· die Formatangabe auch ohne
Operandengrî·e geschrieben werden darf.  Steht demgegenÅber eine
Operandengrî·e ohne Formatangabe, verwendet AS automatisch das kÅr-
zeste Format.  Die erlaubten Befehlsformate und Operandengrî·en sind
vom Maschinenbefehl abhÑngig und kînnen z.B. [Tosh900], [HitH8_5],
[MitM16] bzw. [MitM16C] entnommen werden.

Die Zahl der Befehlsparameter ist abhÑngig vom Befehl und kann prin-
zipiell zwischen 0 und 20 liegen.  Die Trennung der Parameter von-
einander erfolgt ausschlie·lich durch Kommas (Ausnahme: DSP56000,
dessen parallele Datentransfers durch Leerzeichen getrennt werden),
wobei in Klammern oder Hochkommas eingeschlossene Kommas natÅrlich
nicht beachtet werden.

Anstelle eines Kommentars am Ende kann die Zeile auch nur aus einem
Kommentar bestehen, wenn er in der ersten Spalte beginnt.

Bei den Leerzeichen zur Trennung einzelnen Komponenten darf es sich
genausogut um Tabulatoren handeln.

	2.5. Format des Listings
	------------------------

Das von AS bei Angabe der Kommandozeilenoptionen i oder I erzeugte Listing
lÑ·t sich grob in folgende Teile gliedern:

  1. Wiedergabe des assemblierten Quellcodes;
  2. Symbolliste;
  3. Belegungsliste;
  4. Querverweisliste.

Letztere beide werden nur erzeugt, wenn sie durch zusÑtzliche Kom-
mandozeilenoptionen angefordert wurden.

Im ersten Teil listet AS den kompletten Inhalt aller Quelldateien
inklusive des erzeugten Codes auf.  Eine Zeile in diesem Listing
hat dabei folgende Form:

   [<n>] <Zeile>/<Adresse> <Code> <Quelle>

Im Feld "n" zeigt AS die Include-Verschachtelungstiefe an.  Die
Hauptdatei (die Datei, mit der die Assemblierung begann), hat dabei
die Tiefe 0, von dort aus eingebundene Dateien haben Tiefe 1 usw.
Die Tiefe 0 wird dabei nicht angezeigt.

Im Feld "Zeile" wird die Zeilennummer bezogen auf die jeweilige
Datei ausgegeben.  Die erste Zeile einer Datei hat dabei Nummer 1.
Die Adresse, an der der fÅr diese Zeile erzeugte Code abgelegt wur-
de, folgt hinter dem SchrÑgstrich im Feld "Adresse".

Der erzeugte Code selber steht dahinter im Feld "Code" in hexadezima-
ler Schreibweise.  Je nach Prozessortyp und aktuellem Segment kînnen
die Werte entweder als Bytes oder 16-Bit-Worte formatiert sein.
Sollte mehr Code erzeugt worden sein, als in das Feld hineinpa·t, so
werden im Anschlu· an die Zeile weitere Zeilen erzeugt, in denen nur
dieses Feld belegt ist.

Im Feld "Quelle" schlu·endlich wird die Zeile aus der Quelldatei in
ihrer Originalform ausgegeben.

Die Symboltabelle ist so ausgelegt, da· sie nach Mîglichkeit immer
in 80 Spalten dargestellt werden kann.  FÅr Symbole "normaler LÑnge"
wird eine zweispaltige Ausgabe gewÑhlt.  Sollten einzelne Symbole
mit ihrem Wert die Grenze von 40 Spalten Åberschreiten, werden sie
in einer einzelnen Zeile ausgegeben.  Die Ausgabe erfolgt in alpha-
betischer Reihenfolge.  Symbole, die zwar definiert, aber nie benutzt
wurden, werden mit einem vorangestellten Stern (*) gekennzeichnet.

Die bisher genannten Teile sowie die Auflistung aller definierten
Makros/Funktionen lassen sich selektiv aus dem Gesamtlisting ein-
undausblenden, und zwar mit dem bereits erwÑhnten t-Kommandozei-
lenschalter.  Intern existiert in AS ein Byte, dessen Bits reprÑ-
sentieren, welche Teile ausgegeben werden sollen.  Den einzelnen
Bits sind dabei folgende Teile zugeordnet:

 Bit   Teil

  0   Quelldatei(en)+erzeugter Code
  1   Symboltabelle
  2   Makroliste
  3   Funktionsliste
  4   Zeilennumerierung

DefaultmÑ·ig sind alle Bits auf 1 gesetzt, bei Verwendung des
Schalters

-t <Maske>

werden die in <Maske> gesetzten Bits gelîscht, so da· die entspre-
chenden Listing-Teile unterdrÅckt werden.  Analog lassen sich mit
einem Pluszeichen einzelne Teile wieder einschalten, falls man es
in der ASCMD-Variablen Åbertrieben hat...will man z.B. nur die
Symboltabelle haben, so reicht

-t 2  .

In der Belegungsliste werden fÅr jedes Segment einzeln die belegten
Bereiche hexadezimal ausgegeben.  Handelt es sich bei einem Bereich
um eine einzige Adresse, wird nur diese ausgegeben, ansonsten erste
und letzte Adresse.

In der Querverweisliste wird fÅr jedes definierte Symbol in alpha-
betischer Reihenfolge eine Ausgabe folgender Form erzeugt:

 Symbol <Symbolname> (=<Wert>,<Datei>/<Zeile>):
  Datei <Datei 1>:
  <n1>[(m1)]  ..... <nk>[(mk)]
  .
  .
  Datei <Datei l>:
  <n1>[(m1)]  ..... <nk>[(mk)]

FÅr jedes Symbol wird aufgelistet, in welchen Dateien es in wel-
chen Zeilen angesprochen wurde.  Sollte ein Symbol mehrmals in
der gleichen Zeile benutzt worden sein, so wird dies durch eine
in Klammern gesetzte Anzahl hinter der Zeilennummer angedeutet.
Sollte ein Symbol niemals benutzt worden sein, erscheint es auch
nicht in der Liste; entsprechend erscheint eine Datei auch Åber-
haupt nicht in der Liste eines Symbols, falls es in der ent-
sprechenden Datei nicht referenziert wurde.

ACHTUNG! AS kann dieses Listing nur dann korrekt aufs Papier bringen,
wenn man ihm vorher die LÑnge und Breite des Ausgabemediums mit
Hilfe des PAGE-Befehls (siehe dort) mitgeteilt hat!  Der voreinge-
stellte Default sind 60 Zeilen und eine unbegrenzte Zeilenbreite.


        2.6. Symbolkonventionen
        -----------------------

Symbole dÅrfen zwar (wie in der Einleitung bereits angedeutet) bis zu
255 Zeichen lang werden und werden auch auf der ganzen LÑnge unter-
schieden, die Symbolnamen mÅssen aber einigen Konventionen genÅgen:

Symbolnamen dÅrfen aus einer beliebigen Kombination von Buchstaben,
Ziffern, Unterstrichen und Punkten bestehen, wobei das erste Zeichen
keine Ziffer sein darf.  Der Punkt wurde nur zugelassen, um der MCS-51-
Notation von Registerbits zu genÅgen, und sollte mîglichst nicht in
eigenen Symbolnamen verwendet werden.  Zur Segmentierung von Symbol-
namen sollte auf jeden Fall der Unterstrich und nicht der Punkt ver-
wendet werden.

DefaultmÑ·ig ist AS nicht case-sensitiv, es ist also egal, ob man
Gro·-oder Kleinbuchstaben verwendet.  Mittels des Kommandozeilenschal-
ters U lÑ·t sich AS jedoch in einen Modus umschalten, in dem Gro·-
und Kleinschreibung unterschieden wird.  Ob AS umgeschaltet wurde, 
kann mit dem vordefinierten Symbol CASESENSITIVE ermittelt werden: TRUE
bedeutet Unterscheidung, FALSE keine.

Dies sind die wichtigsten, von AS vordefinierten Symbole:

Name            Bedeutung

TRUE            logisch "wahr"
FALSE           logisch "falsch"

CONSTPI         Kreiszahl Pi (3.1415.....)

VERSION         Version von AS in BCD-Kodierung,
		z.B. 1331 hex fÅr Version 1.33p1

DATE            Datum und
TIME            Zeitpunkt der Assemblierung
		(Beginn)

MOMCPU          momentan gesetzte Ziel-CPU
		(siehe Befehl CPU)
MOMCPUNAME      dito, nur als voll ausgeschrie-
                bener String

MOMFILE         augenblickliche Quelldatei
MOMLINE         Zeilennummer in Quelldatei
MOMPASS         Nummer des laufenden Durchgangs
MOMSECTION      Name der aktuellen Sektion oder
		Leerstring
MOMSEGMENT      Name des mit SEGMENT
                eingestellten Adre·raumes
*,$ bzw. PC     mom. ProgrammzÑhler

Der Status "vordef." bedeutet, da· das Symbol als normales Symbol
in der globalen Symboltabelle gespeichert wird; der Versuch, ein
Symbol gleichen Namens zu definieren, fÅhrt damit zu einer Fehler-
meldung wegen eines doppelt definierten Symbols. Spezialsymbole
werden dagegen Åber Sonderabfragen im Parser realisiert und sind
damit nicht Åbersteuerbar.

VORSICHT!  WÑhrend es im case-insensitiven Modus egal ist, mit welcher
Kombination von Gro·- und Kleinbuchstaben man vordefinierte Symbole
anspricht, mu· man sich im case-sensitiven Modus exakt an die oben
angegebene Schreibweise (nur Gro·buchstaben) halten!

ZusÑtzlich definieren einige Pseudobefehle noch Symbole, die eine
Abfrage des damit momentan eingestellten Wertes ermîglichen.  De-
ren Beschreibung findet sich bei den zugehîrigen Befehlen.

Ein etwas verstecktes (und mit Vorsicht zu nutzendes) Feature ist,
Symbolnamen aus String-Variablen zusammenzubauen, indem man den
Namen des Strings mit geschweiften Klammern in den Symbolnamen
einbaut.  So kann man z.B. den Namen eines Symbols anhand des
Wertes eines anderen Symbols festlegen:

cnt		set	cnt+1
temp		equ	"\{CNT}"
		jnz	skip{temp}
		.
		.
skip{temp}:	nop

ACHTUNG!  Der Programmierer ist selber dafÅr verantwortlich, da·
sich dabei gÅltige Symbolnamen ergeben!

Eine vollstÑndige Auflistung aller von AS verwendeten Symbolnamen
findet sich in Anhang E.


	2.7. FormelausdrÅcke
	--------------------

An den meisten Stellen, an denen der Assembler Zahlenangaben erwartet,
kînnen nicht nur einfache Symbole oder Konstanten angegeben werden,
sondern ganze FormelausdrÅcke.  Bei den Komponenten der Formelaus-
drÅcke kann es sich sowohl um ein einzelnes Symbol als auch um eine
Konstante handeln.  Die Schreibweise von Integerkonstanten kann in
verschiedenen Zahlensystemen erfolgen:

		Intel-Modus	  Motorola-Modus        C-Modus
	       (Intel, Zilog,   (Rockwell, Motorola,    (PowerPC,
		Thomson, Texas,  Microchip, Thomson,     AMD 29K,
		Toshiba, NEC,    Hitachi, Atmel)         COP8)
		Siemens, Philips)

dezimal		  direkt	       direkt            direkt

hexadezimal  nachgestelltes H     vorangestelltes $  vorangestelltes 0x

binÑr	     nachgestelltes B     vorangestelltes %  vorangestelltes 0b

oktal	     nachgestelltes O	  vorangestelltes @  vorangestellte 0

Damit hexadezimale Kostanten im Intel-Modus nicht als Symbolnamen
fehlinterpretiert werden kînnen, mÅssen sie immer mit einer Ziffer
beginnen; anstelle z.B. F0H mu· also 0F0H geschrieben werden.  Der
Motorola-bzw. C-Modus kennt derartige Probleme nicht (hihihi!).

Mit Hilfe des RELAXED-Befehls (siehe dort) kann die starre Zuordnung
einer Schreibweise zu einem Zielprozessor aufgehoben werden, so da·
man eine beliebige Schreibweise verwenden kann (auf Kosten der Kompa-
tibilitÑt zu Standard-Assemblern).  DefaultmÑ·ig ist diese Option
aber ausgeschaltet.

Integerkonstanten kînnen auch als ASCII-Werte geschrieben werden,
so entsprechen

 'A'    == $41
 'AB'   == $4142
 'ABCD' == $41424344

Wichtig ist, da· hier die Zeichen in Hochkommas geschrieben werden,
um sie von den weiter unten beschriebenen Stringkonstanten zu unter-
scheiden.

Gleitkommakonstanten werden in der Åblichen halblogarithmischen
Schreibweise geschrieben, die in der allgemeinsten Form

 [-]<Vorkommastellen>[.Nachkommastellen][E[-]Exponent]

lautet. ACHTUNG! Der Assembler versucht eine Konstante zuerst als
Integerkonstante zu verstehen und macht erst dann einen Versuch mit
Gleitkomma, falls dies gescheitert ist.  Will man aus irgendwelchen
GrÅnden die Auswertung als Gleitkommazahl erzwingen, so kann man dies
durch Dummy-Nachkommastellen erreichen, z.B.

   2 ---> 2.0

Stringkonstanten mÅssen in GÑnsefÅ·chen eingeschlossen werden. Um nun
aber auch GÑnsefÅ·chen und Sonderzeichen ohne Verrenkuungen in
Stringkonstanten schreiben zu kînnen, wurde ein "Escape-Mechanismus"
eingebaut, der C-Programmierer(inne)n bekannt vorkommen dÅrfte:

Schreibt man einen Backslash (\) mit einer maximal dreiziffrigen
Zahl im String, so versteht der Assembler dies als Zeichen mit dem
entsprechenden dezimalen ASCII-Wert.  So kann man mit

\0

ein NUL-Zeichen definieren.

Einige besonders hÑufig gebrauchte Steuerzeichen kann man auch mit
folgenden AbkÅrzungen erreichen:

\b : Backspace           \a : Klingel         \e : Escape
\t : Tabulator           \n : Zeilenvorschub  \r : WagenrÅcklauf
\\ : Backslash           \' oder \h : Hochkomma
\" oder \i : GÑnsefÅ·chen

Die Kennbuchstaben dÅrfen sowohl gro· als auch klein geschrieben
werden.

öber dieses Escape-Zeichen kînnen sogar FormelausdrÅcke in den
String eingebaut werden, wenn sie in geschweifte Klammern einge-
fa·t werden: z.B. ergibt

    message "Wurzel aus 81 : \{sqrt(81)}"

die Ausgabe

    Wurzel aus 81 : 9

AS wÑhlt anhand des Formelergebnistyps die richtige Ausgabeform, zu
vermeiden sind lediglich weitere Stringkonstanten im Ausdruck, da
der Parser bei der Gro·-zu-Kleinbuchstabenumwandlung sonst durchein-
anderkommt.  ACHTUNG!  Integer-Konstanten werden hexadezimal und
"nackt" eingesetzt, d.h. ohne z.B. vorangestelltes Dollarzeichen
oder die bei Intel bisweilen erforderliche Null...

Bis auf den Einbau von FormelausdrÅcken ist dieser Escape-Mechanismus
auch in als ASCII definierten Integerkonstanten zulÑssig, z.B. so:

   move.b   #'\n',d0

Jedoch hat alles seine Grenzen, weil der darÅberliegende Parser, der
die Zeile in Opcode und Parameter zerlegt, nicht wei·, womit er da
eigentlich arbeitet, z.B. hier:

   move.l   #'\'abc',d0

Nach dem dritten Hochkomma findet er das Komma nicht mehr, weil er
vermutet, da· eine weitere Zeichenkonstante beginnt, und eine
Fehlermeldung Åber eine falsche Parameterzahl ist die Folge.  Abhilfe
wÑre z.B., \i anstelle \' zu schreiben.

Die Berechnung von im Formelausdruck entstehenden Zwischenergebnissen
erfolgt immer mit der hîchsten verfÅgbaren Wortbreite, d.h. 32 Bit fÅr
Ganzzahlen, 80 Bit fÅr Gleitkommazahlen und 255 Zeichen fÅr Strings.
Eine eventuelle PrÅfung auf WertebereichsÅberschreitung findet erst am
Endergebnis statt.

Der Assembler stellt zur VerknÅpfung folgende Operanden zur VerfÅgung:

Operand   Funktion           #Operanden Integer Gleitkomma String Rang

  <>      Ungleichheit            2       ja        ja      ja     14
  >=      grî·er oder gleich      2       ja        ja      ja     14
  <=      kleiner oder gleich     2       ja        ja      ja     14
  <       echt kleiner            2       ja        ja      ja     14
  >       echt grî·er             2       ja        ja      ja     14
  =       Gleichheit              2       ja        ja      ja     14

  !!      log. XOR                2       ja        nein    nein   13
  ||      log. OR                 2       ja        nein    nein   12
  &&      log. AND                2       ja        nein    nein   11
  ~~      log. NOT                1       ja        nein    nein    2

  -       Differenz               2       ja        ja      nein   10
  +       Summe                   2       ja        ja      ja     10
  #       Modulodivision          2       ja        nein    nein    9
  /       Quotient                2       ja *)     ja      nein    9
  *       Produkt                 2       ja        ja      nein    9
  ^       Potenz                  2       ja        ja      nein    8

  !       binÑres XOR             2       ja        nein    nein    7
  |       binÑres OR              2       ja        nein    nein    6
  &       binÑres AND             2       ja        nein    nein    5
  ><      Bitspiegelung           2       ja        nein    nein    4
  >>      log. Rechtsschieben     2       ja        nein    nein    3
  <<      log. Linksschieben      2       ja        nein    nein    3
  ~       binÑres NOT             2       ja        nein    nein    1

*) Rest wird verworfen

Unter "Rang" ist dabei die PrioritÑt zu verstehen, die dieser Opera-
tor bei der Teilung eines Ausdruckes in UnterausdrÅcke hat, der
ranghîchste Operator wird also ZULETZT ausgewertet.  Die Reihenfolge
der Evaluierung lÑ·t sich durch Klammerung neu festlegen.

Die Vergleichsoperatoren liefern TRUE, falls die Bedingung zutrifft,
und FALSE falls nicht.  FÅr die logischen Operatoren ist ein Ausdruck
TRUE, falls er ungleich 0 ist, ansonsten FALSE.

Die Bitspiegelung ist wohl etwas erklÑrungsbedÅrftig: Der Operator
spiegelt die untersten Bits im ersten Operanden, lÑ·t die darÅberlie-
genden Bits aber unverÑndert.  Die Zahl der zu spiegelnden Bits ist
der rechte Operand und darf zwischen 1 und 32 liegen.

ZusÑtzlich zu den Operatoren definiert der Assembler noch eine Reihe
in erster Linie transzendenter Funktionen mit Gleitkommaargument:

Name      Bedeutung           Argument            Ergebnis

SQRT      Quadratwurzel       arg >= 0            Gleitkomma

SIN       Sinus               arg reell           Gleitkomma
COS       Kosinus             arg reell           Gleitkomma
TAN       Tangens             arg <> (2*n+1)*Pi/2 Gleitkomma
COT       Kotangens           arg <> n*Pi         Gleitkomma

ASIN      inverser Sinus      |arg| <= 1          Gleitkomma
ACOS      inverser Kosinus    |arg| <= 1          Gleitkomma
ATAN      inverser Tangens    arg reell           Gleitkomma
ACOT      inverser Kotangens  arg reell           Gleitkomma

EXP       Exponentialfunktion arg reell           Gleitkomma
ALOG      10 hoch Argument    arg reell           Gleitkomma
ALD       2 hoch Argument     arg reell           Gleitkomma
SINH      hyp. Sinus          arg reell           Gleitkomma
COSH      hyp. Kosinus        arg reell           Gleitkomma
TANH      hyp. Tangens        arg reell           Gleitkomma
COTH      hyp. Kotangens      arg <> 0            Gleitkomma

LN        nat. Logarithmus    arg > 0             Gleitkomma
LOG       dek. Logarithmus    arg > 0             Gleitkomma
LD        2er Logarithmus     arg > 0             Gleitkomma
ASINH     inv. hyp. Sinus     arg reell           Gleitkomma
ACOSH     inv. hyp. Kosinus   arg >= 1            Gleitkomma
ATANH     inv. hyp. Tangens   arg < 1             Gleitkomma
ACOTH     inv. hyp. Kotangens arg > 1             Gleitkomma

INT       ganzzahliger Anteil arg reell           Gleitkomma

BITCNT    binÑre Quersumme    Integer             Integer
FIRSTBIT  niedrigstes 1-Bit   Integer             Integer
LASTBIT   hîchstes 1-Bit      Integer             Integer
BITPOS    einziges 1-Bit      Integer             Integer

SGN       Vorzeichen (0/1/-1)  Gleitkomma oder    Integer
                               Integer
ABS       Betrag               Integer oder       Integer oder
			       Gleitkomma         Gleitkomma
TOUPPER   pass. Gro·buchstabe  Integer            Integer
TOLOWER   pass. Kleinbuchstabe Integer            Integer

UPSTRING  wandelt alle Zei-   String              String
          chen in Gro·buch-
	  staben

LOWSTRING wandelt alle Zei-   String              String
          chen in Kleinbuch-
	  staben

VAL       evaluiert Stringin- String              abh. von
	  halt als Ausdruck                       Argument

Die Funktionen FIRSTBIT, LASTBIT und BITPOS liefern als Ergebnis
-1, falls Åberhaupt kein bzw. nicht genau ein Bit gesetzt ist. Zu-
sÑtzlich gibt BITPOS in einem solchen Fall eine Fehlermeldung aus.

Wenn eine Funktionen auch Gleitkommaargumente erwartet, so soll
dies nicht bedeuten, da· man nicht z.B.

wur2 equ sqrt(2)

schreiben dÅrfte - in solchen FÑllen findet automatisch eine Typ-
konvertierung statt.  Umgekehrt mu· allerdings die INT-Funktion an-
gewandt werden, um eine Gleitkommazahl ganz zu bekommen.  Bei der
Benutzung dieser Funktion ist zu beachten, da· sie als Ergebnis
immer einen vorzeichenbehafteten Integer liefert, sie hat also
einen Wertebereich von ca. +/-2.0E9.

Schaltet man AS in den case-sensitiven Modus, so kînnen im Gegen-
satz zu vordefinierten Symbolen die vordefinierten Funktionen
weiterhin in beliebiger Schreibweise angesprochen werden.  Bei
selbstdefinierten Funktionen (siehe Abschnitt 3.4.6) wird allerdings
unterschieden.  Dies hat zur Folge, da· z.B. bei der Definition
einer Funktion 'Sin' man mit 'Sin' diese Funktion auch erreicht,
mit allen anderen Schreibweisen jedoch die eingebaute Funktion.

FÅr eine korrekte Umwandlung von Klein-zu Gro·buchstaben ist eine
DOS-Version >=3.30 erforderlich.


	2.8. Sharefile
	--------------

Diese Funktion ist ein Abfallprodukt aus den reinen 68000er-VorgÑn-
gern von AS, da sie vielleicht doch der (die?!) eine oder andere ge-
brauchen kînnte, habe ich sie dringelassen.  Grundproblem ist es,
an bestimmte beim Assemblieren entstehende Symbole heranzukommen,
weil man evtl. mit diesen Adre·informationen auf den Speicher des
Zielsystems zugreifen mîchte.  Der Assembler erlaubt es, mit Hilfe
des SHARED-Pseudobefehles (siehe dort) Symbolwerte extern zur Ver-
fÅgung zu stellen.  Zu diesem Zweck erstellt der Assembler im zwei-
ten Pass eine Textdatei mit den gewÅnschten Symbolen und ihren Wer-
ten, die mittels Include in ein Hochsprachen-oder weiteres Assembler-
programm eingebunden werden kînnen.  Das Format der Textdatei (C, Pas-
cal oder Assembler) wird durch die Kommandozeilenschalter p, c oder a
festgelegt.

ACHTUNG! Ist keiner dieser Schalter angegeben, so wird auch keine Da-
tei erzeugt, egal ob sich SHARED-Befehle im Quelltext finden oder
nicht!

AS prÅft beim Anlegen der Share-Datei nicht, ob bereits eine Datei
gleichen Namens existiert, eine solche wird ggfs. einfach Åber-
schrieben.  Eine Abfrage halte ich nicht fÅr sinnvoll, da AS dann
bei jedem Lauf fragen wÅrde, ob er die alte Version der Share-Datei
Åberschreiben darf, und das wÑre doch sehr lÑstig...


	2.9. Prozessor-Aliasse
        ----------------------

Mit Varianten gÑngiger Mikrocontroller-Familien ist es wie mit Kanin-
chen: Sie vermehren sich schneller, als man mit der Versorgung hinter-
herkommen kann.  Im Zuge der Entwicklung von Prozessorkernen als Bau-
steine fÅr ASICs und von Controller-Familien mit vom Kunden wÑhlbarer
Peripherie wird die Zahl von Controller-Varianten, die sich von einem
bekannten Typ nur in einigen Peripherie-Details unterscheiden, immer
grî·er.  Die Unterscheidung der einzelnen Typen ist aber trotz meist
identischer Prozessorkernes wichtig, um z.B. in den Includefiles den
korrekten Satz von Peripherieregistern einzublenden.  Bisher habe ich
mich zwar immer bemÅht, die wichtigsten Vertreter einer Familie in AS
einzubauen (und werde das auch weiter tun), aber manchmal lÑuft mir
die Entwicklung einfach auf und davon...es mu·te also ein Mechanismus
her, mit dem man die Liste der unterscheidbaren Prozessortypen selbst
erweitern kann.

Das Ergebnis davon sind Prozessor-Aliasse: Mit der alias-Kommandozei-
lenoption kann man einen neuen Prozessortyp definieren, der im Be-
fehlssatz einem anderen, in AS fest eingebauten Typ entspricht.  Bei
Benutzung dieses Typs im CPU-Befehl wird sich AS also wie beim "Origi-
nal" verhalten, mit einem Unterschied: Die Variablen MOMCPU bzw.
MOMCPUNAME werden auf den Namen des Alias gesetzt, wodurch der neue
Name zur Unterscheidung z.B. in Includefiles dienen kann.

Die Definition dieser Aliasse wurde aus zwei GrÅnden mit Kommandozei-
lenoptionen anstatt Pseudobefehlen vorgenommen: zum einen wÑre es ohne-
hin nicht mîglich gewesen, die Definition der Aliasse zusammen mit den
Registerdefinitionen in eine Include-Datei zu legen, denn in einem
Programm, das so eine Datei benutzen wollte, mÅ·te sie ja sowohl vor
als auch nach dem CPU-Befehl in der Hauptdatei eingebunden werden -
eine Vorstellung, die irgendwo zwischen unelegant und unmîglich liegt.
Zum zweiten ermîglicht diese Implementierung, die Definition der neuen
Typen in eine Datei zu legen, die Åber die ASCMD-Variable beim Start
automatisch ausgefÅhrt wird, ohne das sich das Programm darum kÅmmern
mÅ·te.


	3. Pseudobefehle
        ================

Nicht fÅr alle Prozessoren sind alle Pseudobefehle definiert.  In Klam-
mern ist jeweils vermerkt, fÅr welche Prozessortypen dieser Befehl
erlaubt ist.


	3.1. Definitionen
        -----------------

	3.1.1.  SET und EQU	( alle Prozessoren )
	- - - - - - - - - -

SET und EQU erlauben die Definition typenloser Konstanten, d.h. sie
werden keinem Segment zugeordnet und ihre Verwendung erzeugt in kei-
nem Fall eine Warnung wegen Segmentverquickung.  WÑhrend EQU Konstan-
ten definiert, die nicht wieder (mit EQU) geÑndert werden kînnen,
erlaubt SET die Definition von Variablen, die sich wÑhrend des As-
semblerlaufes verÑndern lassen.  Dies ist nÅtzlich z.B. bei der
Allokation von Resourcen Ö la Interruptvektoren, wie im folgenden
Beispiel:

VecCnt		set	0		; irgendwo am Anfang

		.
                .
                .

DefVec		macro	Name		; einen neuen Vektor belegen
Name		equ	VecCnt
VecCnt		set	VecCnt+4
		endm

		.
		.
		.


		DefVec	Vec1		; ergibt Vec1=0
		DefVec	Vec2		; ergibt Vec2=4

Intern werden Konstanten und Variablen identisch gespeichert, der
einzige Unterschied ist, da· sie mit SET umdefiniert werden kînnen
und mit EQU nicht.  Es ist daher mîglich, ein Symbol mit EQU zu de-
finieren und es mit SET zu Ñndern (auch wenn das nicht der Sinn
der Sache ist).  Aus einem weiteren Grund sollte man davon sogar
explizit die Finger lassen: Im Gegensatz zu SET prÅft EQU, ob der
neu zugewiesene Wert sich von einem evtl. bisher existierenden
unterscheidet.  Da sich dieser fÅr mit EQU definierte Konstanten
nicht Ñndern sollte, vermutet AS einen Phasenfehler und legt einen
weiteren Pass ein...wÅrde man in obigem Beispiel z.B. die Initia-
lisierung des ZÑhlers mit EQU durchfÅhren, so wÅrde AS sich zwar
nicht beschweren, da eine einmalige Neuzuweisung pro Pass erlaubt
ist (bei n DurchgÑngen kommt man nun einmal n-mal an dieser Stelle
vorbei), aber endlos neue Passes ansto·en, da der Initialwert des
ZÑhlers immer vom Endwert verschieden ist.

Mit SET/EQU lassen sich sowohl Gleitkomma-als auch Integerkonstanten
definieren, z.B.

IntZwei		equ	2
FloatZwei	equ	2.0

Einige Prozessoren besitzen leider bereits selber einen SET-Befehl.
Bei diesen mu· EVAL anstelle von SET verwendet werden.

Anstelle von EQU darf auch einfach ein Gleichheitszeichen ge-
schrieben werden, analog kann man anstelle von SET bzw. EVAL
einfach := schreiben.

DefaultmÑ·ig sind mit SET oder EQU definierte Symbole typenlos,
optional kann jedoch als zweites Argument ein Segmentname (CODE,
DATA, IDATA, XDATA, YDATA, BITDATA, IO) oder MOMSEGMENT fÅr das
aktuell gesetzte Segment angegeben werden, um das Symbol einem
bestimmten Adre·raum zuordnen.


	3.1.2. SFR und SFRB  (diverse, SFRB nur MCS-51)
        - - - - - - - - - -

Diese Befehle funktionieren wie EQU, nur sind die damit definierten
Symbole dem direkt adressierbaren Datensegment zugeordnet, d.h. sie
dienen bevorzugt zur Definition von RAM-Zellen und (wie der Name
ahnen lÑ·t) im Datenbereich eingeblendeten Hardwareregistern.  Der
dabei zugelassene Wertebereich ist identisch mit dem bei ORG fÅr das
DATA-Segment zugelassenen (s. Abschnitt 3.2.1).  SFR und SFRB
unterscheiden sich darin, da· SFRB das Register als bitadressierbar
kennzeichnet, weshalb AS zusÑtzlich 8 Symbole erzeugt, die dem Bit-
segment zugeordnet werden und die Namen xx.0 bis xx.7 tragen, z.B.

PSW		sfr	0d0h	; ergibt PSW = D0H (Datensegment)

PSW		sfrb	0d0h	; ergibt zusÑtzlich PSW.0 = D0H (Bit)
				;               bis PSW.7 = D7H (Bit)

Da beim 80C251 grundsÑtzlich alle SFRs ohne zusÑtzliche Bit-Symbole
bitadressierbar sind, ist der SFRB-Befehl fÅr ihn auch nicht mehr
definiert; die Bits PSW.0 bis PSW.7 sind automatisch vorhanden.

AS ÅberprÅft bei der Definition eines bitadressierbaren Registers mit
SFRB, ob die Speicherstelle Åberhaupt bitadressierbar ist (Bereich
20h..3fh bzw. 80h, 88h, 90h, 98h...0f8h).  Ist sie es nicht, so wird eine
Warnung ausgegeben; die dann erzeugten Bit-Symbole sind undefiniert.


	3.1.3. XSFR und YSFR (DSP56000)
	- - - - - - - - - - - - - - - -

Auch der DSP56000 hat einige Peripherieregister memory-mapped im
Speicher liegen, die Sache wird jedoch dadurch komplizierter, da·
es zwei Datenbereiche gibt, den X-und Y-Bereich.  Diese Architektur
erlaubt einerseits zwar einen hîheren ParallelitÑtsgrad, zwingt je-
doch andererseits dazu, den normalen SFR-Befehl in die beiden oben
genannten Varianten aufzuspalten.  Sie verhalten sich identisch zu
SFR, nur da· XSFR ein Symbol im X-Adre·raum definiert und YSFR ent-
sprechend eines im Y-Adre·raum.  Der erlaubte Wertebereich ist
0..$ffff.


	3.1.4. LABEL (alle Prozessoren)
	- - - - - - - - - - - - - - - -

Die Funktion des LABEL-Befehls ist identisch zu EQU, nur wird das
Symbol nicht typenlos, sondern erhÑlt das Attribut "Code".  LABEL wird
genau fÅr einen Zweck benîtigt: Labels in Makros sind normalerweise
lokal, also nicht au·erhalb des Makros zugreifbar.  Mit einem EQU-
Befehl kann man sich zwar aus der AffÑre ziehen, die Formulierung

<Name>   label    $

erzeugt aber ein Symbol mit korrekten Attributen.


	3.1.5.  BIT		(MCS/(2)51, XA, 80C166, 75K0)
	- - - - - -

BIT dient dazu, ein einzelnes Bit einer Speicherstelle mit einem sym-
bolischen Namen gleichzusetzen.  Da die Art und Weise, wie verschie-
dene Prozessoren Bitverarbeitung und -adressierung betreiben, stark
variiert, verhÑlt sich auch dieser Befehl je nach Zielplattform
anders:

FÅr die MCS/51-Familie, die einen eigenen Adre·raum fÅr Bitoperanden
besitzt, ist die Funktion von BIT ganz analog zu SFR, d.h. es wird
einfach ein Integer-Symbol mit dem angegebenen Wert und dem Segment
BDATA erzeugt.  FÅr alle anderen Prozessoren wird die Bitadressierung
dagegen zweidimensional mit Adresse und Bitstelle vorgenommen.  In
diesem Fall verpackt AS beide Teile in einer vom jeweiligen Prozessor
abhÑngigen Weise in ein Integer-Symbol und drîselt dieses bei der
Benutzung wieder in die beiden Teile auseinander.  Letzterer Fall
trifft auch schon fÅr den 80C251 zu:  WÑhrend zum Beispiel der Befehl

Mein_Carry	bit	PSW.7

auf einem 8051 noch dem Symbol Mein_Carry den Wert 0d7h zuweisen
wÅrde, wÅrde auf einem 80C251 dagegen ein Wert von 070000d0h gene-
riert werden, d.h. die Adresse steht in Bit  0..7 sowie die Bitstelle
in Bit 24..26.  Dieses Verfahren entspricht dem, das auch beim DBIT-
Befehl des TMS370 angewendet wird und funktioniert sinngemÑ· so auch
beim 80C166, nur da· dort Bitstellen von 0 bis 15 reichen dÅrfen:

MSB     BIT     r5.15

Beim Philips XA findet sich in Bit 0..9 die Bitadresse, wie sie auch
in die Maschinenbefehle eingesetzt wird, fÅr Bits aus den RAM-Speicher
wird in Bit 16..23 die 64K-Bank eingesetzt.

Noch etwas weiter geht der BIT-Befehl bei der 75K0-Familie: Da dort
Bitadressierungen nicht nur absolute Basisadressen verwenden dÅrfen,
sind sogar AusdrÅcke wie

bit1    BIT     @h+5.2

erlaubt.


	3.1.6. DBIT        (TMS 370xxx)
	- - - - - -

Die TMS370-Reihe hat zwar kein explizites Bit-Segment, jedoch kînnen
einzelne Bits als Symbol durch diesen Befehl simuliert werden.  DBIT
benîtigt zwei Operanden, nÑmlich einmal die Adresse der Speicherstel-
le, in der das Bit liegt, sowie die genaue Position des Bits im Byte.
So definiert man z.B. mit

INT3            EQU     P019
INT3_ENABLE     DBIT    0,INT3

das Bit, welches Interrupts von Anschlu· INT3 freigibt.  So defi-
nierte Bits kînnen dann von den Befehlen SBIT0, SBIT1, CMPBIT, JBIT0
und JBIT genutzt werden.


	3.1.7. PORT        (8080/8085/8086, XA, Z80, 320xx, TLCS-47,
	- - - - - -         AVR)

PORT arbeitet analog zu PORT, nur wird das Symbol dem I/O-Adre·bereich
zugeordnet.  Erlaubte Werte sind 0..7 beim 3201x, 0..15 beim 320C2x,
0..65535 beim 8086, 0..63 beim AVR, und 0..255 beim Rest.

Beispiel: eine PIO 8255 liege auf Adresse 20H:

PIO_Port_A	port	20h
PIO_Port_B	port	PIO_Port_A+1
PIO_Port_C	port	PIO_Port_A+2
PIO_Ctrl	port	PIO_Port_A+3


	3.1.8.  CHARSET		(alle Prozessoren)
	- - - - - - - -

Einplatinensysteme, zumal wenn sie LCDs ansteuern, benutzen hÑufig
einen anderen Zeichensatz als ASCII, und da· die Umlautkodierung mit
der im Befehl Åbereinstimmt, dÅrfte wohl reiner Zufall sein.  Um nun
aber keine fehlertrÑchtigen Handumkodierungen vornehmen zu mÅssen,
enthÑlt der Assembler eine Umsetzungstabelle fÅr Zeichen, die jedem
Quellcode ein Zielzeichen zuordnet.  Zur Modifikation dieser Tabelle
( die initial 1:1 Åbersetzt ), dient der Befehl CHARSET.  Der Befehl
erwartet eine Bereichsangabe fÅr die zu Åbersetzenden Zeichen als
ersten bzw. ersten/zweiten Parameter und als letzten Parameter den
Bereich, in den die Zeichen umgemappt werden sollen.  Zur Klarstel-
lung zwei Beispiele:

	CHARSET	'Ñ',128

bedeutet, da· das Zielsystem das Ñ mit der Zahl 128 kodiert.
Falls das Zielsystem keine Kleinbuchstaben unterstÅtzt, kînnen mit


	CHARSET 'a','z','A'

alle Kleinbuchstaben auf die passenden Gro·buchstaben automatisch um-
gemappt werden.

ACHTUNG! CHARSET beeinflu·t nicht nur im Speicher abgelegte String-
konstanten, sondern auch als "ASCII" formulierte Integerkonstanten.
Dies bedeutet, da· eine evtl. bereits modifizierte Umsetzungstabelle
in den obigen Beispielen zu anderen Ergebnissen fÅhren kann!


	3.1.9 ENUM (alle Prozessoren)
	- - - - - - - - - - - - - - -

ENUM dient analog zu dem entsprechenden Befehl in C dazu, AufzÑh-
lungstypen zu definieren, d.h. eine Reihe von Integer-Konstanten,
denen fortlaufende Werte (von 0 an beginnend) zugewiesen werden.
Als Parameter werden dabei die Namen der zu definierenden Symbole
angegeben, wie in dem folgenden Beispiel:

	ENUM	SymA,SymB,SymC

Dieser Befehl weist den Symbolen SymA, SymB und SymC die Werte 0,
1 und 2 zu.

ENUM-Befehle sind von Hause aus einzeilig, d.h. bei einem neuen
ENUM-Befehl beginnt die Numerierung wieder bei Null.  Mehrzeilige
AufzÑhlungen kann man aber mit einem kleinen Trick erreichen, der
die Tatsache ausnutzt, da· man mit einer expliziten Zuweisung den
internen ZÑhler neu setzen kann, wie in dem folgenden Fall:

	ENUM    Januar=1,Februar,MÑrz,April,Mai,Juni

(Man merke den Umlaut an, das kann kein anderer mir bekannter
Assembler!)  Hier werden den Monatsnamen die Zahlenwerte 1..6
zugewiesen.  Mîchte man die AufzÑhlung nun fortsetzen, geht
das folgenderma·en:

	ENUM	Juli=Juni+1,August,September,Oktober
	ENUM	November=Oktober+1,Dezember

Die Definition von Symbolen mit ENUM gleicht einer Definition
mit EQU, d.h. es ist nicht mîglich, einem Symbol einen neuen
Wert zuzuweisen.


	3.1.10 PUSH und POPV (alle Prozessoren)
        - - - - - - - - - - - - - - - - - - - -

Mit PUSHV und POPV ist es mîglich, den Wert von (nicht makro-
lokalen) Symbolen temporÑr zu speichern und zu einem spÑteren 
Zeitpunkt wiederherzustellen.  Die Speicherung erfolgt auf
Stacks, d.h. Last-In-First-Out-Speichern.  Ein Stack hat einen
Namen, der den allgemeinen Symbolkonventionen genÅgen mu·, und
existiert so lange, wie er mindestens ein Element enthÑlt: Ein
bisher nicht existierender Stack wird bei PUSHV automatisch ange-
legt, ein durch POPV leer werdender Stack wird automatisch wieder
aufgelîst.  Der Name des Stacks, auf den Symbole abgelegt und
von dem sie wieder abgeholt werden sollen, ist der erste Parameter
von PUSHV bzw. POPV, danach folgt eine beliebige Menge von Sym-
bolen als weitere Parameter.  Alle in der Liste aufgefÅhrten
Symbole mÅssen bereits existieren, es ist also NICHT mîglich, mit
einem POPV-Befehl implizit neue Symbole zu definieren.  

Stacks stellen eine globale Ressource dar, d.h. ihre Namen sind
nicht lokal zu Sektionen.

Wichtig ist, da· die Variablenliste IMMER von links nach rechts
abgearbeitet wird.  Wer also mehrere Variablen mit POPV von einem
Stack herunterholen will, mu· diese in genau umgekehrter Reihen-
folge zum entsprechenden PUSHV angeben!

Der Name des Stacks kann auch weggelassen werden, etwa so:

        pushv   ,var1,var2,var3
        .
        .
        popv    ,var3,var2,var1

AS verwendet dann einen internen, vordefinierten Default-Stack.

Nach Ende eines Durchlaufes ÅberprÅft AS, ob noch Stacks existieren,
die nicht leer sind, und gibt deren Namen sowie "FÅllstand" aus.  Mit
diesen Warnungen kann man herausfinden, ob an irgendeiner Stelle die
PUSHV's und POPV's nicht paarig sind.  Es ist jedoch in keinem Fall
mîglich, Symbolwerte in einem Stack Åber mehrere DurchlÑufe hinwegzu-
retten: Zu Beginn eines Durchlaufes werden alle Stacks geleert!


	3.2. Codebeeinflussung
	----------------------


	3.2.1.  ORG		(alle Prozessoren)
	- - - - - -

ORG erlaubt es, den assemblerinternen Adre·zÑhler mit einem neuen
Wert zu besetzen.  Der Wertebereich ist vom momentan gewÑhlten Seg-
ment und vom Prozessortyp abhÑngig.  Die untere Grenze ist dabei
immer 0; die obere Grenze der angegebene Wert minus eins:

Prozessor  CODE     DATA     IDATA      XDATA    YDATA    BITDATA  IO

68xx0      4G       ------   ------     ------   ------   ------   ------
           Init 0

DSP56000   64K      ------   ------     64K      64K      ------   ------
           Init 0                       Init 0   Init 0

PowerPC    4G       ------   ------     ------   ------   ------   ------
           Init 0

6800,6301, 64K      ------   ------     ------   ------   ------   ------
6811       Init 0

6805/HC08  8K       ------   ------     ------   ------   ------   ------
           Init 0

6809,      64K      ------   ------     ------   ------   ------   ------
6309       Init 0

68HC12     64K      ------   ------     ------   ------   ------   ------
           Init 0

68HC16     1M       ------   ------     ------   ------   ------   ------
           Init 0

H8/300     64K      ------   ------     ------   ------   ------   ------
H8/300H    16M
           Init 0

H8/500     64K      ------   ------     ------   ------   ------   ------
(Min)      Init 0

H8/500     16M      ------   ------     ------   ------   ------   ------
(Max)      Init 0

SH7000/    4G       ------   ------     ------   ------   ------   ------
7600       Init 0

6502,      64K      ------   ------     ------   ------   ------   ------
MELPS740   Init 0

65816,     16M      ------   ------     ------   ------   ------   ------
MELPS7700  Init 0

MELPS4500  8K       416      ------     ------   ------   ------   ------
           Init 0   Init 0

M16        4G       ------   ------     ------   ------   ------   ------
           Init 0

M16C       1M       ------   ------     ------   ------   ------   ------
           Init 0

MCS-48,    4K       ------   256        256      ------   ------   ------
MCS-41     Init 0            Init 0     Init 0

MCS-51     64K      256      256        64K      ------   0--255   ------
           Init 0   Init 0   Init 80H*) Init 0            Init 0

MCS-251    16M      ------   ------     ------   ------   ------   512
           Init 0                                                  Init 0

MCS-96     64K      ------   ------     ------   ------   ------   ------
           Init 0

8080,      64K      ------   ------     ------   ------   ------   256
8085       Init 0                                                  Init 0

80x86,     64K      64K      ------     64K      ------   ------   64K
V30/35     Init 0   Init 0              Init 0                     Init 0

XA         16M      16M      ------     ------   ------   ------   2K
           Init 0   Init 0                                         Init 1K

AVR        8K       64K      ------     ------   ------   ------   64
           Init 0   Init 0                                         Init 0

29xxx      4G       ------   ------     ------   ------   ------   ------
           Init 0

80C166,    256K     ------   ------     ------   ------   ------   ------
80C167     16M
           Init 0

Z80,       64K      ------   ------     ------   ------   ------   256
Z180,      512K **)                                                256
Z380       4G                                                      4G
           Init 0                                                  Init 0

Z8         64K      256      ------     64K      ------   ------   ------
           Init 0   Init 0              Init 0

TLCS-900,  16M      ------   ------     ------   ------   ------   ------
900L       Init 0

TLCS-90    64K      ------   ------     ------   ------   ------   ------
           Init 0

TLCS-870   64K      ------   ------     ------   ------   ------   ------
           Init 0

TLCS-47    64K      1K       ------     ------   ------   ------   16
           Init 0   Init 0                                           Init 0

TLCS-9000  16M      ------   ------     ------   ------   ------   ------
           Init 0

PIC16C5x   2K       32       ------     ------   ------   ------   ------
           Init 0   Init 0

PIC16C64,  8K       512      ------     ------   ------   ------   ------
PIC16C86   Init 0   Init 0

PIC17C42   64K      256      ------     ------   ------   ------   ------
           Init 0   Init 0

ST62xx     4K       256      ------     ------   ------   ------   ------
           Init 0   Init 0

6804       4K       256      ------     ------   ------   ------   ------
           Init 0   Init 0

32010      4K       144      ------     ------   ------   ------   8
32015      4K       256                                            8
           Init 0   Init 0                                         Init 0

320C2x     64K      64K      ------     ------   ------   ------   16
           Init 0   Init 0                                         Init 0

320C3x     16M      ------   ------     ------   ------   ------   ------
           Init 0

320C5x     64K      64K      ------     ------   ------   ------   64K
           Init 0   Init 0                                         Init 0

370xxx     64K      ------   ------     ------   ------   ------   ------
           Init 0

MSP430     64K      ------   ------     ------   ------   ------   ------
           Init 0

COP8       8K       256      ------     ------   ------   ------   ------
           Init 0   Init 0

ÊPD78(C)10 64K      ------   ------     ------   ------   ------   ------
           Init 0

75K0       16K      4K       ------     ------   ------   ------   ------
           Init 0   Init 0

78K0       64K      ------   ------     ------   ------   ------   ------
           Init 0   

*) Da der 8051 kein RAM jenseits 80h hat, mu· dieser Wert fÅr den 8051
   als Zielprozessor auf jeden Fall mit ORG angepa·t werden!!
**) Da der Z180 weiterhin logisch nur 64K ansprechen kann, ist der
    ganze Adre·raum nur mittels PHASE-Anweisungen erreichbar!

Falls in einer Prozessorfamilie verschiedene Varianten unterschied-
lich gro·e Adre·rÑume haben, ist jeweils der maximale Raum aufge-
fÅhrt.

ORG wird in erster Linie benîtigt, um dem Code eine neue Startadres-
se zu geben und damit verschiedene, nicht zusammenhÑngende CodestÅcke
in einem Programm unterzubringen.


	3.2.2.  CPU 		(alle Prozessoren)
	- - - - - -

Mit diesem Befehl wird festgelegt, fÅr welchen Prozessor im weiteren
Code erzeugt werden soll.  Die Befehle der anderen Prozessorfamilien
sind dann nicht greifbar und erzeugen eine Fehlermeldung!

Die Prozessoren kînnen grob in Familien unterschieden werden, in den
Familien dienen unterschiedliche Typen nocheinmal zur Feinunterschei-
dung:

a) 68008 --> 68000 --> 68010 --> 68012 --> 68332 --> 68340 -->
   68360 --> 68020 --> 68030

In dieser Familie liegen die Unterschiede in hinzukommenden Befehlen
und Adressierungsarten (ab 68020).  Eine kleine Ausnahme stellt der
68030 dar, dem 2 Befehle fehlen: CALLM und RTM.  Die beiden Vertreter
der 683xx-Famile haben den gleichen Prozessorkern (eine leicht abge-
magerte 68020-CPU), jedoch vîllig unterschiedliche Peripherie.

b) 56000

c) PPC403 --> MPC505 --> MPC601 --> RS6000

Der PCC403 ist eine abgespeckte Version der PowerPC-Linie ohne
Gleitkommaeinheit, demzufolge sind sÑmtliche Gleitkommabefehle
bei ihm gesperrt; dafÅr sind einige mikrocontrollerspezifische
Befehle enthalten, die er als einziges Mitglied in dieser Familie
kennt.  Der MPC505 (eine Mikrokontroller-Variante mit FPU) unter-
scheidet sich solange vom 601er nur in den Peripherieregistern,
wie ich es nicht besser wei· - [Mot505] hÑlt sich da noch etwas
bedeckt...  Die RS6000-Reihe kennt noch einige Befehle mehr (die
auf vielen 601er-Systemen emuliert werden, um vollstÑndige
KompatibilitÑt herzustellen), au·erdem verwendet IBM z.T. andere
Mnemonics fÅr diese reinen Workstation-Prozessoren, als Remineszenz
an die 370er-Gro·rechner...

d) 6800 --> 6301 --> 6811

WÑhrend der 6301 nur neue Befehle definiert, liefert der 6811 ne-
weiteren Befehlen ein zweites Indexregiser Y zur Adressierung.

e) 6809/6309 und 6805/68HC08

Diese Prozessoren sind zwar teilweise quellcodekompatibel zu den
anderen 68xx-ern, haben aber ein anderes BinÑrcodeformat und einen
deutlich eingeschrÑnkteren (6805) bzw. erweiterten (6809) Befehls-
satz.  Der 6309 ist eine CMOS-Version des 6809, die zwar offiziell
nur kompatibel zum 6809 ist, inoffiziell aber mehr Register und
deutlich mehr Befehle besitzt (siehe [Kaku]).

f) 68HC12

g) 68HC16

h) HD6413308 --> HD6413309

Diese beiden Namen reprÑsentieren die 300er und 300H-Varianten der
H8-Familie; die H-Version besitzt dabei einen grî·eren Adre·raum
(16 MByte statt 64 KByte), doppelt so breite Register (32 Bit) und
kennt einige zusÑtzliche Befehle und Adressierungsarten.  Trotzdem
ist sie binÑr aufwÑrtskompatibel.

i) HD6475328 --> HD6475348 --> HD6475368 --> HD6475388

Diese Prozessoren besitzen alle den gleichen CPU-Kern; Die unter-
schiedlichen Typen dienen lediglich der Einbindung des korrekten
Registersatzes in der Datei REG53X.INC.

j) SH7000 --> SH7600

Der Prozessorkern des 7600ers bietet eine Handvoll Befehle mehr, die
LÅcken im Befehlssatz des 7000ers schlie·en (verzîgerte, bedingte
sowie relative und indirekte SprÅnge, Multiplikationen mit 32-Bit-Ope-
randen sowie Multiplizier/Addier-Befehle).

k) 6502 --> 65(S)C02 / MELPS740

Die CMOS-Version definiert einige zusÑtzliche Befehle, au·erdem sind
bei einigen Befehlen Adressierungsarten hinzugekommen, die beim 6502
nicht mîglich waren.  Die Mitsubishi-Mikrokontroller dagegen erwei-
tern den 6502-Befehlssatz in erster Linie um Bitoperationen und Mul-
tiplikations-/Divisionsbefehle.  Bis auf den unbedingten Sprung und
Befehle zur Inkrementierung/Dekremetierung des Akkumulatos sind die
Erweiterungen disjunkt.  Dem 65SC02 fehlen die Bitmanipulationsbefehle
des 65C02

l) MELPS7700, 65816

Neben einer "16-Bit-Version" des 6502-Befehlssatzes bieten diese Pro-
zessoren einige Befehlserweiterungen.  Diese sind aber grî·erenteils
disjunkt, da sie sich an ihren jeweiligen 8-bittigen Vorbildern (65C02
bzw. MELPS-740) orientieren.  Z.T. werden auch andere Mnemonics fÅr
gleiche Befehle verwendet.

m) MELPS4500

n) M16

o) M16C

p) 8021, 8022, 8039, 80C39, 8048, 80C48, 8041, 8042

Bei den ROM-losen Versionen 8039 und 80C39 sind die Befehle verboten,
die den BUS (Port 0) ansprechen.  Der 8021 und 8022 sind Sonderver-
sionen mit stark abgemagertem Befehlssatz, wofÅr der 8022 zwei A/D-
Wandler und die dazugehîrigen Steuerbefehle enthÑlt.  Die CMOS-Ver-
sionen lassen sich mit dem IDL-Befehl in einen Ruhezustand niedriger
Stromaufnahme ÅberfÅhren.  Der 8041 und 8042 haben einige Zusatz-
befehle zur Steuerung der Busschnittstelle, dafÅr fehlen aber einige
andere Befehle.  DarÅber hinaus ist bei diesen Prozessoren der Pro-
grammadre·raum nicht extern erweiterbar, weshalb AS das Codesegment
bei diesen Prozessoren auf 1 bzw. 2 KByte begrenzt.

q) 87C750 --> 8051, 8052, 80C320 und 80515 --> 80C251

Der 87C750 kann nur max. 2 kByte Programmspeicher adressieren, wes-
halb die LCALL- und LJMP-Befehle bei ihm fehlen.  Zwischen den drei
mittleren Prozessoren nimmt AS selber Åberhaupt keine Unterscheidung
vor, sondern verwaltet den Unterschied lediglich in der Variablen
MOMCPU (s.u.), die man mit IF-Befehlen abfragen kann.  Der 80C251
hingegen stellt einen drastischen Fortschritt in Richtung 16/32 Bit,
grî·erer Adre·rÑume und orthogonalerem Befehlssatz dar.

r) 8096 --> 80196

Neben einem anderen Satz von SFRs (die Åbrigens von Unterversion zu
Unterversion stark differieren) kennt der 80196 eine Reihe von zu-
sÑtzlichen Befehlen und kennt einen "Windowing"-Mechanismus, um das
grî·ere interne RAM anzusprechen.

s) 8080 und 8085

Der 8085 kennt zusÑtzlich die Befehle RIM und SIM zum Steuern der
Interruptmaske und der zwei I/O-Pins.

t) 8086 --> 80186 --> V30 --> V35

Hier kommen nur neue Befehle dazu.  Die entsprechenden 8-Bitter
sind wegen ihrer BefehlskompatibilitÑt nicht aufgefÅhrt, fÅr ein 8088-
System ist also z.B. 8086 anzugeben.

u) XAG1, XAG2, XAG3

Diese Prozessoren unterscheiden sich nur in der Grî·e des eingebauten
ROMs, die in STDDEFXA.INC definiert ist.

v) AT90S1300 --> AT90S2312 --> AT90S8414

Der erste Vertreter der AVR-Reihe stellt die Minimalkonfiguration dar,
ohne RAM-Speicher und demzufolge auch ohne Load/Store-Befehle.  Die
beiden anderen Prozessoren unterscheiden sich nur im Speicherausbau
und in der eingebauten Peripherie, was in REGAVR.INC differenziert
wird.

w) AM29245 --> AM29243 --> AM29240 --> AM29000

Je weiter man sich in der Liste nach rechts bewegt, desto weniger
Befehle mÅssen in Software emuliert werden.  WÑhrend z.B. der 29245
noch nicht einmal einen Hardware-Multiplizierer besitzt, fehlen den
beiden Vertretern in der Mitte nur die Gleitkommabefehle.  Der 29000
dient dabei als "generischer" Typ, der alle Befehle in Hardware ver-
steht.

x) 80C166 --> 80C167

Der 80C167 hat anstelle 256 KByte max. 16 MByte Adre·raum, au·erdem
kennt er einige zusÑtzliche Befehle fÅr erweiterte Adressierungsmodi
sowie atomare Befehlssequenzen.

y) Z80 --> Z80UNDOC --> Z180 --> Z380

WÑhrend fÅr den Z180 nur die zusÑtzlichen Befehle definiert sind
(d.h. die Z180-MMU findet noch keine BerÅcksichtigung), besitzt der
Z380 32-Bit-Register, einen linearen 4GByte-Adre·raum sowie neben
einer Reihe von Befehlserweiterungen, die den Befehlssatz deutlich
orthogonaler machen, neue Adressierungsmodi (Ansprechen der
IndexregisterhÑlften, Stack-relativ).  Zu einem kleinen Teil exis-
tieren diese Erweiterungen aber auch schon beim Z80 als undokumen-
tierte Befehle, die mit der Variante Z80UNDOC zugeschaltet werden
kînnen.  Eine Liste mit den zusÑtzlichen Befehlen findet sich im
Kapitel mit den prozessorspezifischen Hinweisen.

z) Z8601

aa) 96C141, 93C141

Diese beiden Prozessoren reprÑsentieren die beiden Varianten der Pro-
zessorfamilie: TLCS-900 und TLCS-900L.  Die Unterschiede dieser beiden
Varianten werden in Abschnitt 4.6 genauer beleuchtet.

ab) 90C141

ac) 87C00, 87C20, 87C40, 87C70

Die Prozessoren der TLCS-870 haben zwar den identischen CPU-Kern, je
nach Variante aber eine unteschiedliche Peripherieausstattung.  Zum
Teil liegen Register gleichen Namens auf unterschiedlichen Adressen.
Die Datei STDDEF87.INC benutzt analog zur MCS-51-Familie die hier
mîgliche Unterscheidung, um automatisch den korrekten Symbolsatz be-
reitzustellen.

ad) 47C00 --> 470C00 --> 470AC00

Diese drei Varianten der TLCS-47-Familie haben unterschiedlich gro·e
RAM-und ROM-Adre·bereiche, wodurch jeweils einige Befehle zur Bank-
umschaltung hinzukommen oder wegfallen.

ae) 97C241

af) 16C54 --> 16C55 --> 16C56 --> 16C57

Diese Prozessoren unterscheiden sich durch den verfÅgbaren Programm-
adre·raum, d.h. durch die Adresse, ab der der AS öberlÑufe anmeckert.

ag) 16C84, 16C64

Analog zur MCS-51-Familie findet hier keine Unterscheidung im
Codegenerator statt, die unterschiedlichen Nummern dienen lediglich
der Einblendung der korrekten SFRs in STDDEF18.INC.

ah) 17C42

ai) ST6210/ST6215 --> ST6220/ST6225

Die einzige Unterscheidung, die AS zwischen den beiden Paaren vor-
nimmt, ist der bei den ersten beiden kleinere Adre·raum (2K anstel-
le 4K).  Die Feinunterscheidung dient zur automatischen Unterschei-
dung in der Quelldatei, welche Hardware jeweils vorhanden ist (ana-
log zum 8051/52/515).

aj) 6804

ak) 32010 --> 32015

Der TMS32010 besitzt nur 144 Byte internes RAM, weshalb AS Adressen im
Datensegment auf eben diesen Bereich begrenzt.  FÅr den 32015 gilt diese
BeschrÑnkung nicht, es kann der volle Bereich von 0..255 angesprochen
werden.

al) 320C25 --> 320C26 --> 320C28

Diese Prozessoren unterscheiden sich nur leicht in der On-Chip-Peri-
pherie sowie den Konfigurationsbefehlen.

am) 320C30, 320C31

Der 320C31 ist eine etwas "abgespeckte" Version mit dem gleichen
Befehlssatz, jedoch weniger Peripherie.  In STDDEF3X.INC wird diese
Unterscheidung ausgenutzt.

an) 320C50, 320C51, 320C53

Die Unterscheidung zwischen diesen Prozessoren wird von AS momentan
nicht ausgenutzt. 

ao) 370C010, 370C020, 370C030, 370C040 und 370C050

Analog zur MCS-51-Familie werden die unterschiedlichen Typen nur
zur Unterscheidung der Peripherie in STDDEF37.INC genutzt, der
Befehlssatz ist identisch.

ap) MSP430

aq) COP87L84

Dies ist das momentan einzige unterstÅtzte Mitglied der COP8-Familie 
von National Semiconductor.  Mir ist bekannt, da· die Familie wesent-
lich grî·er ist und auch Vertreter mit unterschiedlich gro·em Befehls-
satz existieren, die nach Bedarf hinzukommen werden.  Es ist eben ein
Anfang, und die Dokumentation von National ist ziemlich umfangreich...

ar) 7810 --> 78C10

Die NMOS-Version besitzt keinen STOP-Modus; der entspechende Befehl
sowie das ZCM-Register fehlen dementsprechend.

as) 75402,
    75004, 75006, 75008,
    75268,
    75304, 75306, 75308, 75312, 75316,
    75328,
    75104, 75106, 75108, 75112, 75116,
    75206, 75208, 75212, 75216,
    75512, 75516

Dieses "FÅllhorn" an Prozessoren unterscheidet sich innerhalb einer
Gruppe nur durch die RAM- und ROM-Grî·e; die Gruppen unter-
einander unterscheiden sich einmal durch ihre on-chip-Peripherie und
zum anderen durch die MÑchtigkeit des Befehlssatzes.

at) 78070

Dies ist das einizige, mir momentan vertraute Mitglied der 78K0-Fa-
milie von NEC.  Es gelten Ñhnliche Aussagen wie zur COP8-Familie!

Beim CPU-Befehl mu· der Prozessortyp als einfache Konstante ange-
geben werden, eine Berechnung Ö la

	CPU	68010+10

ist also nicht zulÑssig.  GÅltige Aufrufe sind z.B.

	CPU 	8051

oder

	CPU	6800

Egal, welcher Prozessortyp gerade eingestellt ist, in der Integer-
variablen MOMCPU wird der momentane Status als Hexadezimalzahl ab-
gelegt.  FÅr den 68010 ist z.B. MOMCPU=$68010, fÅr den 80C48
MOMCPU=80C48H.  Da man Buchstaben au·er A..F nicht als Hexziffer
interpretieren kann, mu· man sich diese bei der Hex-Darstellung
des Prozessors wegdenken. FÅr den Z80 ist z.B. MOMCPU=80H.

Dieses Feature kann man vorteilhaft einsetzen, um je nach Prozessor-
typ unterschiedlichen Code zu erzeugen.  Der 68000 z.B. kennt noch
keinen Befehl fÅr den UnterprogrammrÅcksprung mit Stapelkorrektur.
Mit der Variablen MOMCPU kann man ein Makro definieren, das je nach
Prozessortyp den richtigen Befehl benutzt oder ihn emuliert:

myrtd	macro	disp
	if	MOMCPU<$68010   ; fÅr 68008 & 68000 emulieren
	 move.l	(sp),disp(sp)
	 lea	disp(sp),sp
	 rts
	elseif
	 rtd	#disp		; ab 68010 direkt benutzen
	endif
	endm

	cpu 	68010
	myrtd	12              ; ergibt RTD #12

	cpu	68000
	myrtd	12		; ergibt MOVE.. / LEA.. / RTS

Da nicht alle Prozessornamen nur aus Ziffern und Buchstaben zwischen
A und F bestehen, wird zusÑtzlich der volle Name in der String-Varia-
blen MOMCPUNAME abgelegt.

Implizit schaltet der Assembler mit dem CPU-Befehl das aktuelle Seg-
ment wieder auf Code zurÅck, da dies das einzige Segment ist, das
alle Prozessoren definieren.

Default fÅr den Prozessortyp ist 68008.



	3.2.3. SUPMODE, FPU, PMMU  (680x0, FPU auch 8086..V35,
	- - - - - - - - - - - - -   SUPMODE auch TLCS-900, SH7000,
				    29K, XA und PowerPC)

Mit diesen drei Schaltern kann bestimmt werden, auf
welche Teile des Befehlssatzes verzichtet werden soll, weil die
dafÅr nîtigen Vorbedingungen im folgenden CodestÅck nicht gegeben
sind.  Als Parameter fÅr diese Befehle darf entweder ON oder OFF
gegeben werden, der momentan gesetzte Zustand kann aus einer Varia-
blen ausgelesen werden, die entweder TRUE oder FALSE ist.

Die Befehle bedeuten im einzelnen folgendes:

SUPMODE: erlaubt bzw. sperrt Befehle, fÅr deren AusfÅhrung der Pro-
	 zessor im Supervisorstatus sein mu·.  Die Statusvariable
	 hei·t INSUPMODE.

FPU    : erlaubt bzw. sperrt die Befehle des numerischen Koprozes-
	 sors 8087 bzw. 68881/68882.  Die Statusvariable hei·t FPUAVAIL.

PMMU   : erlaubt bzw. sperrt die Befehle der Speicherverwaltungs-
	 einheit 68851 bzw. der im 68030 eingebauten MMU.  ACHTUNG!
	 Die 68030-MMU erlaubt nur eine rel. kleine Untermange der
	 68851-Befehle.  Der Assembler nimmt hier keine PrÅfung vor!
	 Die Statusvariable hei·t PMMUAVAIL.

Benutzung von auf diese Weise gesperrten Befehlen erzeugt bei SUPMODE
eine Warnung, bei PMMU und FPU eine echte Fehlermeldung.


        3.2.4. FULLPMMU (680x0)
        - - - - - - - -

Motorola hat zwar ab dem 68030 die PMMU in den Prozessor integriert,
diese aber nur mit einer Funktionsuntermenge der externen PMMU 68851
ausgestattet.  AS sperrt bei aktiviertem PMMU-Befehlssatz (s.o.) des-
halb alle fehlenden Befehle, wenn als Zielprozessor 68030 oder hîher
eingestellt wurde.  Nun kann es aber sein, da· in einem System mit
68030-Prozessor die interne MMU abgeschaltet wurde und der Prozessor
mit einer externen 68851 betrieben wird.  Mit FULLPMMU ON kann man 
AS dann mitteilen, da· der vollstÑndige MMU-Befehlssatz zugelassen 
ist.  Umgekehrt kann man, wenn man portablen Code erzeugen will, alle
zusÑtzlichen Befehle trotz 68020-Zielplattform mit FULLPMMU OFF ab-
schalten.  Die Umschaltung darf beliebig oft erfolgen, die momentane
Einstellung kann aus einem gleichnamigen Symbol ausgelesen werden.
ACHTUNG!  Der CPU-Befehl besetzt fÅr 680x0-Argumente implizit diese
Einstellung vor!  FULLPMMU mu· also auf jeden Fall nach dem CPU-Befehl
kommen!


        3.2.4.  PADDING (680x0, XA, H8, SH7000)
	- - - - - - - -

Prozessoren der 680x0-Familie stehen ungeraden Adressen ziemlich
kritisch gegenÅber: Befehle dÅrfen nicht auf einer ungeraden Adresse
beginnen, und Datenzugriffe sind mit ungeraden Adressen bis zum
68010 nur byteorientiert erlaubt.  Die H8/300-Familie setzt bei Zu-
griffen auf ungerade Adressen das unterste Adre·bit einfach ganz auf
Null, die 500er "bedanken" sich wiederum mit einer Exception...
AS bemÅht sich daher, mit DC oder DS aufgebaute Datenstrukturen
immer mit einer geraden Bytezahl abzulegen.  Das bedeutet bei den Be-
fehlen DS.B und DC.B aber unter UmstÑnden, da· ein FÅllbyte eingefÅgt
werden mu·.  Dieses Verhalten kann man mit dem PADDING-Befehl ein- und
ausschalten.  Als Argument ist analog zu den vorherigen Befehlen ON
oder OFF erlaubt, und die augenblickliche Einstellung kann aus dem
gleichnamigen Symbol ausgelesen werden.


        3.2.5.  MAXMODE (TLCS-900, H8)
	- - - - - - - -

Die Prozessoren der TLCS-900-Reihe kînnen in 2 Betriebsarten arbei-
ten, dem Minimum-und Maximum-Modus.  Je nach momentaner Betriebsart
gelten fÅr den Betrieb und den Assembler etwas andere Eckwerte.
Mit diesem Befehl und den Parametern ON oder OFF teilt man AS mit,
da· der folgende Code im Maximum- oder Minimum-Modus ablÑuft.  Die
momentane Einstellung kann aus der Variablen INMAXMODE ausgelesen
werden.  Voreinstellung ist OFF, d.h. Minimum-Modus.

Analog dazu teilt man im H8-Modus AS mit diesem Befehl mit, ob
mit einem 64K- oder 16MByte-Adre·raum gearbeitet wird.
FÅr den einfachen 300er ist diese Einstellung immer OFF und kann
nicht verÑndert werden.


	3.2.6.  EXTMODE und LWORDMODE (Z380)
	- - - - - - - - - - - - - - -

Der Z380 kann in insgesamt 4 Betriebsarten arbeiten, die sich
durch die Einstellung von 2 Flags ergeben: Das XM-Flag bestimmt,
ob der Prozessor mit einem 64 KByte oder 4 GByte gro·en Adre·raum
arbeiten soll und kann nur gesetzt werden (nach einem Reset steht
es Z80-kompatibel auf 0).  DemgegenÅber legt das LW-Flag fest, ob
Wort-Befehle mit einer WortlÑnge von 16 oder 32 Bit arbeiten
sollen.  Die Stellung dieser beiden Flags beeinflu·t Wertebe-
reichseinschrÑnkungen von Konstanten oder Adressen, weshalb man
AS Åber diese beiden Befehle deren Stellung mitteilen mu·.  Als
Default nimmt AS an, da· beide Flags auf 0 stehen, die momentane
Einstellung (ON oder OFF) kann aus den vordefinierten Variablen
INEXTMODE bzw. INLWORDMODE ausgelesen werden.


	3.2.7.  SRCMODE (MCS-251)
        - - - - - - - -

Intel hat den Befehlssatz der 8051er beim 80C251 deutlich erweitert,
hatte aber leider nur noch einen einzigen freien Opcode fÅr diese
Befehle frei.  Damit der Prozessor nicht auf alle Ewigkeit durch ei-
nen PrÑfix behindert bleibt, hat Intel zwei Betriebsarten vorgesehen:
Den BinÑr- und den Quellmodus.  Im BinÑrmodus ist der Prozessor voll
8051-kompatibel, alle erweiterten Befehle benîtigen den noch freien
Opcode als PrÑfix.  Im Quellmodus tauschen diese neuen Befehle ihre
Position in der Code-Tabelle mit den entsprechenden 8051-Instruktio-
nen, welche dann wiederum mit einem PrÑfix versehen werden mÅssen.
Damit AS wei·, wann er PrÑfixe setzen mu· und wann nicht, mu· man
ihm mit diesem Befehl mitteilen, ob der Prozessor im Quellmodus (ON)
oder BinÑrmodus (OFF) betrieben wird.  Die momentane Einstellung kann
man aus der Variablen INSRCMODE auslesen.  Der Default ist OFF.


        3.2.8.  BIGENDIAN (MCS-51/251, PowerPC)
        - - - - - - - - -

Bei den Prozessoren der 8051-Serie ist Intel seinen eigenen
Prinzipien untreu geworden: Der Prozessor verwendet entgegen
jeglicher Tradition eine Big-Endian-Orientierung von Mehrbytewerten!
WÑhrend dies bei den MCS-51-Prozessoren noch nicht gro·artig auffiel,
da der Prozessor ohnehin nur 8-bittig auf Speicherzellen zugreifen
konnte, man sich die Byte-Anordnung bei eigenen Datenstrukturen also
aussuchen konnte, ist dies beim MCS-251 nicht mehr so, er kann auch
ganze (Lang-)Worte aus dem Speicher lesen und erwartet dabei das MSB
zuerst.  Da dies nicht der bisherigen Arbeitsweise von AS bei der
Konstantenablage entspricht, kann man nun mit diesem Befehl umschal-
ten, ob die Befehle DB, DW, DD, DQ und DT mit Big- oder Little-Endian-
Orientierung arbeiten sollen.  Mit BIGENDIAN OFF (Voreinstellung) wird 
wie bei Ñlteren AS-Versionen zuerst das niederwertigste Byte abgelegt, 
mit BIGENDIAN ON wird die MCS-251-kompatible Variante benutzt. NatÅr- 
lich kann man diese Einstellung beliebig oft im Code Ñndern; die mo-
mentane Einstellung kann aus dem gleichnamigen Symbol ausgelesen wer-
den.


	3.2.9.  SEGMENT (alle Prozessoren)
	- - - - - - - -

Bestimmte Mikrokontroller und Signalprozessoren kennen mehrere
Adre·bereiche, die nicht miteinander mischbar sind und
jeweils auch verschiedene Befehle zur Ansprache benîtigen.  Um auch
diese verwalten zu kînnen (obwohl kein Code in ihnen erzeugt werden
kann), stellt der Assembler mehrere ProgrammzÑhler zur VerfÅgung,
zwischen denen mit dem SEGMENT-Befehl hin-und hergeschaltet werden
kann.  Dies erlaubt es, sowohl in mit INCLUDE eingebundenen Unterpro-
grammen als auch im Hauptprogramm benîtigte Daten an der Stelle zu
definieren, an denen sie benutzt werden.  Im einzelnen werden
folgende Segmente mit folgenden Namen verwaltet:

CODE    : Programcode;
DATA    : direkt adressierbare Daten (dazu rechnen auch SFRs);
XDATA   : im extern angeschlossenen RAM liegende Daten oder
	  X-Adre·raum beim DSP56000;
YDATA   : Y-Adre·raum beim DSP56000;
IDATA   : indirekt adressierbare (interne) Daten;
BITDATA : der Teil des 8051-internen RAMs, der bitweise adressier-
	  bar ist;
IO      : I/O-Adre·bereich.

Zu Adre·bereich und Initialwerten der Segmente siehe Abschnitt 3.2.1.
(ORG).  Je nach Prozessorfamilie sind auch nicht alle Segmenttypen
erlaubt.

Das Bitsegment wird so verwaltet, als ob es ein Bytesegment wÑre,
d.h. die Adressen inkrementieren um 1 pro Bit.

Um es noch einmal klarzustellen: Alle Segmente au·er Code dienen
lediglich der Adre·verwaltung, d.h. man kann keinen Code oder
Konstanten darin definieren.  ZulÑssig sind nur Befehle, die Spei-
cher reservieren (DS, DB ?...).

Labels, die in einem Segment eines bestimmten Typs definiert werden,
erhalten diesen Typ als Attribut.  Damit hat der Assembler eine be-
grenzte PrÅfmîglichkeit, ob mit den falschen Befehlen auf Symbole
in einem Segment zugegriffen wird.  In solchen FÑllen wird der As-
sembler eine Warnung ausgeben.

Beispiel:

	CPU	8051		; MCS-51-Code

	segment	code		; TestcodestÅck

	setb	flag		; keine Warnung
	setb	var		; Warnung : falsches Segment

	segment	data

var	db	?

	segment	bitdata

flag	db	?



	3.2.10. PHASE und DEPHASE   (alle Prozessoren)
	- - - - - - - - - - - - -

In manchen Anwendungen (speziell Z80-Systeme) mu· Code vor der
Benutzung in einen anderen Adre·bereich verschoben werden.  Da der
Assembler davon aber nichts wei·, wÅrde er alle Labels in dem zu
verschiebenden Teil auf die Ladeadressen ausrichten.  Der Program-
mierer mÅ·te SprÅnge innerhalb dieses Bereiches entweder lageunab-
hÑngig kodieren oder die Verschiebung bei jedem Symbol "zu Fu·"
addieren.  Ersteres ist bei manchen Prozessoren gar nicht mîglich,
letzteres sehr fehleranfÑllig.
Mit dem Befehlen PHASE und DEPHASE ist es mîglich, dem Assembler
mitzuteilen, auf welcher Adresse der Code im Zielsystem effektiv
ablaufen wird:

	phase	<Adresse>

informiert den Assembler davon, da· der folgende Code auf der spe-
zifizierten Adresse ablaufen soll.  Der Assembler berechnet darauf-
hindie Differenz zum echten ProgrammzÑhler und addiert diese Dif-
ferenz bei folgenden Operationen dazu:

 - Adre·angabe im Listing
 - Ablage von Labelwerten
 - ProgrammzÑhlerreferenzen in relativen SprÅngen und Adre·aus-
   drÅcken
 - Abfrage des ProgrammzÑhlers mit den Symbolen * bzw. $

Diese "Verschiebung" wird mit dem Befehl

	dephase

wieder aufgehoben.

Obwohl dieses Befehlspaar vornehmlich in Codesegmenten Sinn macht,
verwaltet der Assembler fÅr alle definerten Segmente Phasenwerte.



	3.2.11.  SAVE und RESTORE (alle Prozessoren)
	- - - - - - - - - - - - -

Mit dem Befehl SAVE legt der Assembler den Inhalt folgender
Variablen auf einen internen Stapel:

 - momentan gewÑhlter Prozessortyp (mit CPU gesetzt);
 - momentan aktiver Speicherbereich (mit SEGMENT gesetzt);
 - Flag, ob Listing ein- oder ausgeschaltet ist (mit LISTING
   gesetzt);
 - Flag, ob Expansionen folgender Makros im Listing ausgegeben
   werden sollen (mit MACEXP gesetzt).

Mit dem GegenstÅck RESTORE wird entsprechend der zuletzt gesicherte
Zustand von diesem Stapel wieder heruntergeladen.  Diese beiden
Befehle sind in erster Linie fÅr Includefiles definiert worden, um
in diesen Dateien die obigen Variablen beliebig verÑndern zu kînnen,
ohne ihren originalen Inhalt zu verlieren.  So kann es z.B. sinnvoll
sein, in Includefiles mit eigenen, ausgetesteten Unterprogrammen die
Listingerzeugung auszuschalten:

      SAVE           ; alten Zustand retten

      LISTING  OFF   ; Papier sparen

      .              ; der eigentliche Code
      .

      RESTORE        ; wiederherstellen

GegenÅber einem einfachen LISTING OFF .. ON-PÑrchen wird hier auch
dann der korrekte Zustand wieder hergestellt, wenn die Listingerzeu-
gung bereits vorher ausgeschaltet war.

Der Assembler ÅberprÅft, ob die Zahl von SAVE-und RESTORE-Befehlen
Åbereinstimmt und liefert in folgenden FÑllen Fehlermeldungen:

 - RESTORE und der interne Stapel ist leer;
 - nach Ende eines Passes ist der Stapel nicht leer.


	3.2.12.  ASSUME (diverse)
	- - - - - - - -

        6809
        ....

Im Gegensatz zu seinen "VorgÑngern" wie 6800 und 6502 kann beim 6809
die Lage der direct page, d.h. des Adressbereiches, der mit ein Byte
langen Adressen erreichbar ist, frei bestimmt werden.  Dazu dient
das sog. "Direct Page Register" (DPR), das die Seitennummer festlegt.
Ihm mu· man mittels ASSUME einen passenden Wert zuweisen, wenn man
einen anderen Wert als die Vorgabe von 0 in DPR schreibt, sonst
werden Adressen falscher LÑnge erzeugt...

        68HC16
        ......

Um mit seinen nur 16 Bit breiten Adre·operanden einen 1 MByte gro·en 
Adre·raum ansprechen zu kînnen, bedient sich der 68HC16 einer Reihe
von Bank-Registern, die die fehlenden oberen vier Adre·bits nachlie-
fern.  Davon ist das EK-Register fÅr absolute Datenzugriffe (nicht
SprÅnge!) zustÑndig.  AS ÅberprÅft bei jeder absoluten Adressierung,
ob die oberen vier Bits der Adresse mit dem Åber ASSUME spezifizier-
ten Wert Åbereinstimmen.  Differieren die Werte, gibt AS eine War-
nung aus.  Der Vorgabewert fÅr EK ist 0.

	H8/500
        ......

Im Maximum-Modus wird der erweiterte Adre·raum dieser Prozessorreihe
durch eine Reihe von Bank-Registern adressiert.  Diese tragen die
Namen DP (Register 0..3, absolute Adressen), EP (Register 4/5) und
TP (Stack).  Den momentanen Wert von DP benîtigt AS, um zu ÅberprÅ-
fen, ob absolute Adressen in der momentan adressierbaren Bank liegen;
die beiden anderen Register werden nur fÅr indirekte Adressierungen
benutzt und entziehen sich daher der Kontrolle; ob man ihre Werte
angibt oder nicht, ist daher Geschmackssache.  Wichtig ist dagegen
wieder das BR-Register, das angibt, auf welchen 256-Byte-Bereich
mit kurzen Adressen zugegriffen werden kann.  Allen Registern ist
gemeinsam, da· AS KEINE Initialwerte fÅr sie annimmt, da sie nach
einem Prozessor-Reset undefiniert sind; wer absolut adressieren
will, mu· daher auf jeden Fall DR und DP belegen!

	MELPS740
	........

Die Mikrokontroller dieser Reihe kennen fÅr den JSR-Befehl eine
besonder Adressierungsart "special page", mit deren Hilfe man SprÅnge
in die oberste Seite des internen ROMs kÅrzer kodieren kann.  Diese
ist natÅrlich vom jeweiligen Chip abhÑngig, und es gibt mehr Chips,
als es mit dem CPU-Befehl sinnvoll wÑre, zu kodieren...also mu· ASSUME
herhalten, um die Lage dieser Seite vorzugeben, z.B.

	ASSUME SP:$1f ,

falls das interne ROM 8K gro· ist.


	MELPS7700/65816
        ...............

Diese Prozessoren beinhalten eine Reihe von Registern, deren Inhalt AS
kennen mu·, um den korrekten Code zu erzeugen.  Es handelt sich um
folgende Register:
Name   Bedeutung            Wertebereich  Default

DT     Datenbank            0-$ff           0
PG     Code-Bank            0-$ff           0
DPR    direkt adr. Seite    0-$ffff         0
X      Indexregisterbreite  0 oder 1        0
M      Akkumulatorbreite    0 oder 1        0

Um mich nicht in endlose Wiederholungen zu ergehen, verweise ich fÅr
die Benutzung dieser Werte auf Kapitel 4.7. .  Die Handhabung erfolgt
ansonsten genauso wie beim 8086, d.h. es kînnen auch hier mehrere
Werte auf einmal gesetzt werden und es wird kein Code erzeugt, der
die Register mit den Werten besetzt.  Dies bleibt wieder einzig und
allein dem Programmierer Åberlassen!


	8086
	....

Der 8086 kann Daten aus allen Segmenten in einem Befehl adressieren,
benîtigt jedoch sog. "Segment-PrÑfixe", wenn ein anderes Segment-
register als DS verwendet werden soll.  ZusÑtzlich kann es sein, da·
das DS-Register auf ein anderes Segment verstellt ist, um z.B. Åber
lÑngere Strecken nur Daten im Codesegment zu adressieren.  Da AS
aber keine Sinnanalyse des Codes vornimmt, mu· ihm Åber diesen Befehl
mitgeteilt werden, auf welche Segmente die Segmentregister momentan
zeigen, z.B.

   ASSUME  CS:CODE, DS:DATA    .

Allen vier Segmenten des 8086 (SS,DS,CS,ES) kînnen auf diese Weise
Annahmen zugewiesen werden.  Dieser Befehl erzeugt jedoch KEINEN Code,
um die Werte auch wirklich in die Segmentregister zu laden, dies mu·
vom Programm getan werden.

Die Benutzung diese Befehls hat zum einen die Folge, da· AS bei spo-
radischen Zugriffen ins Codesegment automatisch PrÑfixe voranstellen
kann, andererseits man AS mitteilen kann, da· das DS-Register ver-
stellt wurde und man sich im folgenden explizite CS:-Anweisungen
sparen kann.

GÅltige Argumente hinter dem Doppelpunkt sind CODE, DATA und NOTHING.
Letzterer Wert dient dazu, AS mitzuteilen, da· das Segmentregister
keinen fÅr AS verwendbaren Wert enthÑlt.
Vorinitialisiert sind folgende ASSUMEs:

  CS:CODE, DS:DATA, ES:NOTHING, SS:NOTHING


        XA
        ..

Die XA-Familie besitzt einen Datenadre·raum von 16 MByte, ein Proze·
kann jedoch nur immer innerhalb einer 64K-Seite adressieren, die 
durch das DS-Register vorgegeben wird.  AS mu· man den momentanen
Wert dieses Registers vorgeben, damit er Zugriffe auf absolute 
Adressen ÅberprÅfen kann.


        29K
        ...

Die Prozessoren der 29K-Familie besitzen ein Register RBP, mit dessen
Hilfe BÑnke von 16 Registern vor der Benutzung im User-Modus geschÅtzt
werden kînnen.  Dazu kann man ein entsprechendes Bit in diesem Regis-
ter setzen.  Mit ASSUME kann man AS nun mitteilen, welchen Wert RBP
gerade hat.  Auf diese Weise kann AS warnen, falls versucht wird, im
User-Modus auf geschÅtzte Register zuzugreifen.


	80C166/167
	..........

Obwohl keines der Register im 80C166/167 breiter als 16 Bit ist,
besitzt dieser Prozessor 18/24 Adre·leitungen, kann also bis zu 256
KByte/16 MByte adressieren.  Um diesen Widerspruch unter einen Hut
zu bekommen, verwendet er nicht die von Intel her bekannte (...und
berÅchtigte) Segmentierung oder hat unflexible Bankregister...nein,
er macht Paging!  Dazu wird der "logische" Adre·raum von 64 KByte in
4 Seiten zu 16 KByte eingeteilt, und fÅr jede Seite existiert ein
Seitenregister (bezeichnet als DPP0...DPP3), welche der physikali-
schen 16/1024 Seiten dort eingeblendet wird.  AS versucht nun, den
Adre·raum grundsÑtzlich mit 256 KByte/16 MByte aus der Sicht des
Programmierers zu verwalten, d.h. bei absoluten Zugriffen ermittelt
AS die physikalische Seite und schaut in der mit ASSUME eingestellten
Seitenverteilung nach, wie die Bits 14 und 15 der logischen Adresse
gesetzt werden mÅssen.  Pa·t kein Seitenregister, so wird eine Warnung
ausgegeben.  DefaultmÑ·ig nimmt AS an, da· die vier Register linear
die ersten 64 KByte abbilden, etwa in der folgenden Form:

	ASSUME	DPP0:0,DPP1:1,DPP2:2,DPP3:3

Der 80C167 kennt noch einige Befehle, die die Seitenregister in ihrer
Funktion Åbersteuern kînnen.  Wie diese Befehle die Adre·generierung
beeinflussen, ist im Kapitel mit den prozessorspezifischen Hinweisen
beschrieben.


	TLCS-47
	.......

Der direkte Datenadre·raum dieser Prozessoren (egal ob man direkt
oder Åber das HL-Register adressiert) betrÑgt lediglich 256
Nibbles.  Da die "besseren" Familienmitglieder aber bis zu 1024
Nibbles RAM on chip haben, war Toshiba gezwungen, einen Banking-
mechanismus Åber das DMB-Register einzufÅhren.  AS verwaltet das
Datensegment als einen durchgehenden Adre·raum und prÅft bei jeder
direkten Adressierung, ob die Adresse in der momentan aktiven
Bank liegt.  Die von AS momentan angenommene Bank kann mittels

   ASSUME  DMB:<0..3>

festgelegt werden.  Der Default ist 0.


	ST62xx
	......

Die Mikrokontroller der ST62-Reihe sind in der Lage, einen Teil (64
Byte) des Codebereiches in den Datenbereich einzublenden, z.B. um
Konstanten aus dem ROM zu laden.  Dies bedeutet aber auch, da· zu
einem Zeitpunkt immer nur ein Teil des ROMs adressiert werden kann.
Welcher Teil dies ist, wird durch ein bestimmtes Register bestimmt.
Dem Inhalt dieses Registers kann AS zwar nicht direkt kontrollieren,
man kann ihm aber mit diesem Befehl mitteilen, wenn man dem Register
einen neuen Wert zugewiesen hat.  AS kann dann prÅfen und ggfs. war-
nen, falls auf Adressen im Codesegment zugegriffen wird, die nicht
im "angekÅndigten" Fenster liegt.  Hat die Variable VARI z.B. den
Wert 456h, so setzt

    ASSUME ROMBASE:VARI>>6

die AS-interne Variable auf 11h, und ein Zugriff auf VARI erzeugt
einen Zugriff auf die Adresse 56h im Datensegment.

Anstelle eines Symbols kann auch schlicht NOTHING angegeben werden,
z.B. wenn das Bank-Register temporÑr als Speicherzelle benutzt wird.
Dieser Wert ist auch die Voreinstellung.


	320C3x
	......

Da alle Instruktionsworte dieser Prozessorfamilie nur 32 Bit lang
sind, und von diesen 32 Bit nur 16 Bit fÅr absolute Adressen vorge-
sehen wurden, mÅssen die fehlenden oberen 8 Bit aus dem DP-Register
ergÑnzt werden.  Bei Adressierungen kann man aber trotzdem die volle
24-Bit-Adresse angeben, AS prÅft dann, ob die oberen 8 Bit mit dem
angenommenen Inhalt von DP Åbereinstimmen.  GegenÅber dem LDP-Befehl
weicht ASSUME darin ab, da· man hier nicht eine beliebige Adresse
aus der Speicherbank angeben kann, das Herausziehen der oberen Bits
mu· man also "zu Fu·" machen, z.B. so:

	ldp	@adr
	assume	dp:adr>>16
	.
	.
	ldi	@adr,r2


	ÊPD78(C)10
	..........

Diese Prozessoren besitzen ein Register (V), mit dessen Hilfe die
,,Zeropage'', d.h. die Lage der mit nur einem Byte adressierbaren
Speicherzellen sich in Seitengrenzen im Speicher frei verschieben
lÑ·t.  Da man aber aus BequemlichkeitsgrÅnden nicht mit AusdrÅcken
wie

	inrw    Lo(Zaehler)

arbeiten will, Åbernimmt AS diese Arbeit, allerdings nur unter der
Voraussetzung, da· man ihm Åber einen ASSUME-Befehl den Inhalt
des V-Registers mitteilt.  Wird ein Befehl mit Kurzadressierung
benutzt, so wird ÅberprÅft, ob die obere HÑlfte des Adre·ausdrucks
mit dem angenommenen Inhalt Åbereinstimmt.  Stimmt sie nicht, so
erfolgt eine Warnung.


        75K0
        ....

Da selbst mit Hilfe von Doppelregistern (8 Bit) nicht der komplette
Adre·raum von 12 Bit zu erreichen ist, mu·te NEC (wie andere auch...)
auf Banking zurÅckgreifen: Die oberen 4 Adre·bits werden aus dem
MBS-Register geholt (welchem demzufolge mit ASSUME Werte zwischen 0
und 15 zugeordnet werden kînnen), das aber nur beachtet wird, falls
das MBE-Flag auf 1 gesetzt wurde.  Steht es (wie die Vorgabe ist)
auf 0, so kann man die obersten und untersten 128 Nibbles des
Adre·raumes ohne Bankumschaltung erreichen.  Da der 75402 weder MBE-
Flag noch MBS-Register kennt, ist fÅr ihn der ASSUME-Befehl nicht
definiert; Die Initialwerte von MBE und MBS lassen sich daher nicht
Ñndern.


	3.2.13.  EMULATED (29k)
        - - - - - - - - -

AMD hat die Ausnahmebehandlung fÅr undefinierte Befehle bei der
29000-Serie so definiert, da· fÅr jeden einzelnen Befehl ein Excep-
tionvektor zur VerfÅgung steht.  Dies legt es nahe, durch gezielte
Software-Emulationen den Befehlssatz eines kleineren Mitgliedes
dieser Familie zu erweitern.  Damit nun aber AS diese zusÑtzlichen
Befehle nicht als Fehler anmeckert, erlaubt es der EMULATED-Befehl,
AS mitzuteilen, da· bestimmte Befehle doch erlaubt sind.  Die PrÅ-
fung, ob der momentan gesetzte Prozessor diesen Befehl beherrscht,
wird dann Åbergangen.  Hat man z.B. fÅr einen Prozessor ohne
Gleitkommaeinheit ein Modul geschrieben, das aber nur mit 32-Bit-
IEEE-Zahlen umgehen kann, so schreibt man

        EMULATED FADD,FSUB,FMUL,FDIV
        EMULATED FEQ,FGE,FGT,SQRT,CLASS


	3.3. Datendefinitionen
	----------------------

Die hier beschriebenen Befehle Åberschneiden sich teilweise in ihrer
FunktionalitÑt, jedoch definiert jede Prozessorfamilie andere Namen
fÅr die gleiche Funktion.  Um mit den Standardassemblern konform zu
bleiben, wurde diese Form der Implementierung gewÑhlt.



	3.3.1.  DC[.size]       (680x0, H8, SH7x00, DSP56000, XA)
        - - - - - - - - -

Dieser Befehl legt eine oder mehrere Konstanten des durch das Attribut
bestimmten Typs im Speicher ab.  Die Attribute entsprechen den in
Abschnitt 2.2 definierten, zusÑtzlich ist fÅr Byte-Konstanten die Mîg-
lichkeit vorhanden, StringausdrÅcke im Speicher abzulegen, wie
z.b.

String		dc.b	"Hello world!\0"

Die Parameterzahl darf zwischen 1 und 20 liegen, zusÑtzlich darf jedem
Parameter ein in eckigen Klammern eingeschlossener Wiederholungsfaktor
vorausgehen, z.B. kann man mit

		dc.b	[(*+255)&$ffffff00-*]0

den Bereich bis zur nÑchsten Seitengrenze mit Nullen fÅllen.  Vorsicht!
Mit dieser Funktion kann man sehr leicht die Grenze von 1 KByte erzeug-
ten Codes pro Zeile Quellcode Åberschreiten!

Sollte die Byte-Summe ungerade sein, so wird vom Assembler automatisch
ein weiteres Byte angefÅgt, um die Wortausrichtung von Daten zu erhal-
ten.  Dieses Verhalten kann mit dem PADDING-Befehl ein- und
ausgeschaltet werden.

Mit diesem Befehl abgelegte Dezimalgleitkommazahlen ( DC.P ...) kînnen
zwar den ganzen Bereich der extended precision Åberstreichen, zu be-
achten ist dabei allerdings, da· die von Motorola verfÅgbaren Koprozes-
soren 68881/68882 beim Einlesen solcher Konstanten die Tausenderstelle
des Exponenten ignorieren!

Defaultattribut ist W, also 16-Bit-Integerzahlen.

Beim DSP56000 ist der Datentyp auf Integerzahlen festgelegt (ein
Attribut ist deshalb weder nîtig noch erlaubt), die im Bereich
-8M..16M-1 liegen dÅrfen.   Stringkonstanten sind ebenfalls erlaubt,
wobei jeweils drei Zeichen in ein Wort gepackt werden.


	3.3.2.  DS[.size]       (680x0, H8, SH7x00, DSP56000, XA)
	- - - - - - - - -

Mit diesem Befehl lÑ·t sich zum einen Speicherplatz fÅr die angegebene
Zahl im Attribut beschriebener Zahlen reservieren.  So reserviert

	DS.B	20

z.B. 20 Bytes Speicher,

	DS.X    20

aber 240 Byte !

Die andere Bedeutung ist die Ausrichtung des ProgrammzÑhlers, die
mit der Wertangabe 0 erreicht wird.  So wird mit

	DS.W	0

der ProgrammzÑhler auf die nÑchste gerade Adresse aufgerundet, mit

	DS.D	0

dagegen auf die nÑchste Langwortgrenze.  Eventuell dabei freiblei-
bende Speicherzellen sind nicht etwa mit Nullen oder NOPs gefÅllt,
sondern undefiniert.

Vorgabe fÅr die Operandengrî·e ist - wie Åblich - W, also 16 Bit.

Beim 56000 ist die Operandengrî·e auf Worte (a 24 Bit) festgelegt,
Attribute gibt es deswegen wie bei DC auch hier nicht.


	3.3.3. DB,DW,DD,DQ und DT (Intel, Zilog, Toshiba, NEC, TMS370,
	- - - - - - - - - - - - -  Siemens, AMD, M16(C), COP8)

Diese Befehle stellen sozusagen das Intel-GegenstÅck zu DS und DC
dar, und wie nicht anders zu erwarten ist die Logik etwas anders:
Zum einen wird die Kennung der Operandengrî·e in das Mnemonic ver-
legt:

 DB: Byte oder ASCII-String wie bei DC.B
 DW: 16-Bit-Integer
 DD: 32-Bit-Integer oder single precision
 DQ: double precision   ( 64 Bit )
 DT: extended precision ( 80 Bit )

Zum anderen erfolgt die Unterscheidung, ob Konstantendefinition oder
Speicherreservierung, im Operanden.  Eine Reservierung von Speicher
wird durch ein ? gekennzeichnet:

	db	?	; reserviert ein Byte
        dw	?,?	; reserviert Speicher fÅr 2 Wîrter (=4 Byte)
        dd	-1	; legt die Konstante -1 (FFFFFFFFH) ab !

Speicherreservierung und Konstantendefinition dÅrfen NICHT IN EINER
Anweisung gemischt werden:

	db	"Hallo",?	; --> Fehlermeldung

ZusÑtzlich ist noch der DUP-Operator erlaubt, der die mehrfache Abla-
ge von Konstantenfolgen oder die Reservierung ganzer Speicherblîk-
ke erlaubt:

	db	3 dup (1,2)	; --> 1 2 1 2 1 2
	dw	20 dup (?)	; reserviert 40 Byte Speicher.

Wie man sehen kann, mu· das DUP-Argument geklammert werden, darf da-
fÅr aber auch wieder aus mehreren Teilen bestehen, die selber auch
wieder DUPs sein kînnen...das ganze funktioniert also rekursiv.
DUP ist die einzige Stelle, an der man mit einer anderen Grenze des
Assemblers in BerÅhrung kommen kann: maximal kînnen 1024 Byte Code
oder Daten in einer Zeile erzeugt werden.  Dies bezieht sich NICHT
auf die Reservierung von Speicher, nur auf die Definition von Kon-
stantenfeldern!

Um mit dem M80 vertrÑglich zu sein, darf im Z80-Modus anstelle von
DB / DW auch DEFB / DEFW geschrieben werden.

Analog stellen BYTE/ADDR bzw. WORD/ADDRW beim COP8 einen Alias fÅr 
DB bzw. DW dar, wobei die beiden Paare sich jedoch in der Byte-Order 
unterscheiden: Die Befehle, die von National zur Adre·ablage vorge-
sehen waren, benutzen Big-Endian, BYTE bzw. WORD jedoch Little-Endian.


	3.3.4. DS (Intel, Zilog, Toshiba, NEC, TMS370, Siemens, AMD, 
        - - - - -  M16(C), COP8)

Dieser Befehl stellt eine Kurzschreibweise dar, um Speicherbereiche
zu reservieren:

        DS       <Anzahl>

ist eine Kurzschreibweise fÅr

        DB       <Anzahl> DUP (?)

dar, lie·e sich also prinzipiell auch einfach Åber ein Makro reali-
sieren, nur scheint dieser Befehl in den Kîpfen einiger mit Motoro-
la-CPUs gro· gewordener Leute (gell, Michael?) so fest verdrahtet
zu sein, da· sie ihn als eingebauten Befehl erwarten...hoffentlich
sind selbige jetzt zufrieden ;-)


	3.3.5. BYT oder FCB	(6502,68xx)
        - - - - - - - - - - 

Mit diesem Befehl werden im 65xx/68xx-Modus Byte-Konstanten oder
ASCII-Strings abgelegt, er entspricht also DC.B beim 68000 oder
DB bei Intel.


	3.3.6. BYTE             (ST62xx, 320C2x, 320C5x, MSP)
	- - - - - -

Dito.  Ein im 320C2x/5x-Modus vor dem Befehl stehendes Label wird
als untypisiert gespeichert, d.h. keinem Adre·raum zugeordnet.
Der Sinn dieses Verhaltens wird bei den prozessorspezifischen
Hinweisen erlÑutert.


	3.3.7. ADR oder FDB     (6502,68xx)
	- - - - - - - - - - 

Mit diesem Befehl werden im 65xx/68xx-Modus Wortkonstanten abge-
legt, er entspricht also DC.W beim 68000 oder DW bei Intel.


	3.3.8. WORD             (ST62xx, 320C2x, 320C3x, 320C5x,
	- - - - - -             (MSP)

FÅr den 320C3x werden hiermit 32-Bit-Worte abgelegt, fÅr die
beiden anderen Familien 16-Bit-Worte.  Ein im 320C2x/5x-Modus vor
dem Befehl stehendes Label wird als untypisiert gespeichert, d.h.
keinem Adre·raum zugeordnet.  Der Sinn dieses Verhaltens wird bei
den prozessorspezifischen Hinweisen erlÑutert.


	3.3.9. LONG             (320C2x, 320C5x)
	- - - - - -

Hiermit werden 32-Bit-Integer im Speicher abgelegt, und zwar in
der Reihenfolge LoWord-HiWord.  Ein eventuell vor dem Befehl
stehendes Label wird dabei wieder als untypisiert abgelegt
(der Sinn dieser Ma·nahme ist in den prozessorspezifischen
Hinweisen erlÑutert).


	3.3.10. SINGLE und EXTENDED (320C3x)
	- - - - - - - - - - - - - -

Mit diesen Befehlen werden Gleitkomma-Konstanten im Speicher
abgelegt, jedoch nicht im IEEE-Format, sondern in den vom Prozessor
verwendeten 32- und 40-Bit-Formaten.  Da 40 Bit nicht mehr in eine
Speicherzelle hineinpassen, werden im Falle von EXTENDED immer derer
2 pro Wert belegt.  Im ersten Wort finden sich die oberen 8 Bit (der
Exponent), der Rest (Vorzeichen und Mantisse) in zweiten Wort.


	3.3.11.  FLOAT und DOUBLE (320C2x, 320C5x)
	- - - - - - - - - - - - -

Mit diesen Befehlen kînnen 32- bzw. 64-Bit-Gleitkommazahlen
im IEEE-Format im Speicher abgelegt werden.  Dabei wird das
niederwertigste Byte jeweils auf der ersten Speicherstelle
abgelegt.  Ein eventuell vor dem Befehl stehendes Label wird
wieder als untypisiert gespeichert (der Sinn dieser Ma·nahme
ist in den prozessorspezifischen Hinweisen erlÑutert).


	3.3.12. EFLOAT, BFLOAT und TFLOAT (320C2x, 320C5x)
	- - - - - - - - - - - - - - - - -

Auch diese Befehle legen Gleitkommazahlen im Speicher ab,
jedoch in einem nicht-IEEE-Format, das evtl. leichter von
Signalprozessoren zu verarbeiten ist:

EFLOAT: Mantisse mit 16 Bit, Exponent mit 16 Bit
BFLOAT: Mantisse mit 32 Bit, Exponent mit 16 Bit
DFLOAT: Mantisse mit 64 Bit, Exponent mit 32 Bit

Gemeinsam ist den Befehlen, da· die Mantisse vor dem
Exponenten abgelegt wird (Lo-Word jeweils zuerst) und
beide im Zweierkomplement dargestellt werden.  Ein eventuell
vor dem Befehl stehendes Label wird wieder als untypisiert
gespeichert (der Sinn dieser Ma·nahme ist in den prozessor-
spezifischen Hinweisen erlÑutert).


	3.3.13.  Qxx und LQxx (320C2x,320C5x)
	- - - - - - - - - - -

Mit diesen Befehlen kînnen Gleitkommazahlen in einem
Festkommaformat abgelegt werden.  xx ist dabei eine zwei-
stellige Zahl, mit deren Zweierpotenz der Gleitkommawert vor
der Umwandlung in eine ganze Zahl multipliziert werden soll.
Er bestimmt also praktisch, wieviele Bits fÅr die Nachkomma-
stellen reserviert werden sollen.  WÑhrend aber Qxx nur ein
Wort (16 Bit) ablegt, wird das Ergebnis bei LQxx in 2
Worten (loWord zuerst) abgelegt.  Das sieht dann z.B. so
aus:

     q05   2.5       	; --> 0050h
     lq20  ConstPI	; --> 43F7h 0032h

Mich mîge niemand steinigen, wenn ich mich auf meinem HP28
verrechnet haben sollte...


	3.3.14.  DATA           (PIC, 320xx, AVR, MELPS-4500)
	- - - - - - -

Mit diesem Befehl werden Daten im aktuellen Segment abgelegt, wobei
sowohl Integer- als auch Stringwerte zulÑssig sind.  Bei Strings be-
legt beim 16C5x/16C8x, 17C4x im Datensegment und 4500er ein Zeichen
ein Wort, bei AVR, 17C4x im Codesegment und 3201x/3202x passen zwei
Zeichen in ein Wort (LSB zuerst belegt), beim 320C3x sogar derer 4
(MSB zuerst).  Im Gegensatz dazu mu· im Datensegment des 4500ers ein
Zeichen auf zwei Speicherstellen verteilt werden.  Der Wertebereich
fÅr Integers entspricht der Wortbreite des jeweiligen Prozessors im
jeweiligen Segment.  Das bedeutet, da· DATA beim 320C3x die Funktion
von WORD mit einschlie·t (die von SINGLE Åbrigens auch, wenn AS das
Argument als Gleitkommazahl erkennt).


	3.3.15.  ZERO           (PIC)
	- - - - - - -

Dieser Befehl legt einen durch den Parameter spezifizierte Zahl von
Nullworten (=NOPs) im Speicher ab. Es kînnen maximal 512 Nullen mit
einem Befehl abgelegt werden.


        3.3.16. FB und FW       (COP8)
        - - - - - - - - -

Mit diesen Befehlen kann ein grî·erer Block von Speicher (dessen
LÑnge in Bytes bzw. Worten der erste Parameter angibt) mit einer
Byte-bzw. Wortkonstanten gefÅllt werden, die durch den zweiten
Parameter angegeben wird.  Die Maximalgrî·e des Blocks betrÑgt 1024
Elemente fÅr FB bzw. 512 Elemente fÅr FW.


	3.3.17. ASCII und ASCIZ (ST62xx)
	- - - - - - - - - - - -

Mit diesen beiden Befehlen kînnen Stringkonstanten im Speicher ab-
gelegt werden.  WÑhrend ASCII nur die reinen Daten im Speicher ab-
legt, versieht ASCIZ automatisch JEDEN angegebenen String mit einem
NUL-Zeichen am Ende.


	3.3.18.  STRING und RSTRING (320C2x, 320C5x)
	- - - - - - - - - - - - - -

Diese Befehle funktionieren analog zu DATA, jedoch werden hier
Integer-AusdrÅcke grundsÑtzlich als Bytes mit einem entsprechend
eingeschrÑnkten Wertebereich betrachtet, wodurch es mîglich wird,
die Zahlen zusammen mit anderen Zahlen oder Zeichen paarweise in
Worte zu verpacken.
Die beiden Befehle unterscheiden sich lediglich in der Reihenfol-
ge der Bytes in einem Wort: Bei STRING wird zuerst das obere und
danach das untere gefÅllt, bei RSTRING ist es genau umgekehrt.

Ein eventuell vor dem Befehl stehendes Label wird wieder als
untypisiert gespeichert.  Der Sinn dieser Ma·nahme ist im
entsprechenden Kapitel mit den prozessorspezifischen Befehlen
erlÑutert.


        3.3.19. FCC             (6502,68xx)
        - - - - - -

Mit diesem Befehl werden im 65xx/68xx-Modus String-Konstanten 
abgelegt.  Beachten Sie jedoch, da· im Gegensatz zum Original-
assembler AS11 von Motorola (dessentwegen dieser Befehl existiert, 
bei AS ist diese Funktion im BYT-Befehl enthalten), String-Argu-
mente nur in GÑnsefÅ·chen und nicht in Hochkommas oder SchrÑg-
strichen eingeschlossen werden dÅrfen!


	3.3.20.  DFS oder RMB   (6502,68xx)
	- - - - - - - - - - -

Dieser Befehl dient im 65xx/68xx-Modus zur Reservierung von Spei-
cher, er entspricht DS.B beim 68000 oder DB ? bei Intel.


	3.3.21. BLOCK           (ST62xx)
	- - - - - - -

Dito.


	3.3.22. RES             (PIC, MELPS-4500, 3201x, 
	- - - - - -              320C2x, 320C5x, AVR)

Dieser Befehl dient zur Reservierung von Speicher.  Er reserviert
im Codesegment immer Wîrter (10/12/14/16 Bit), im Datensegment bei
den PICs Bytes, beim 4500er Nibbles sowie bei Texas ebenfalls Wîrter.


	3.3.23. BSS        (320C2x, 320C3x, 320C5x, MSP)
	- - - - - -

BSS arbeitet analog zu RES, lediglich ein eventuell vor dem
Befehl stehendes Symbol wird beim 320C2x/5x als untypisiert ge-
speichert.  Der Sinn dieser Ma·nahme kann im Kapitel mit den 
prozessorspezifischen Hinweisen nachgelesen werden.


        3.3.24. DSB und DSW (COP8)
        - - - - - - - - - -

Diese beiden Befehle stellen im COP8-Modus die zum ASMCOP von 
National kompatible Methode dar, Speicher zu reservieren.  
WÑhrend DSB nur einzelne Bytes freihÑlt, reserviert DSW Wîrter 
und damit effektiv doppelt soviel Bytes wie DSB.


	3.3.25. ALIGN      (alle Prozessoren)
	- - - - - - -

ALIGN mit einem dahinterstehenden Integerausdruck erlaubt es, den
ProgrammzÑhler auf eine bestimmte Adresse auszurichten.  Die Aus-
richtung erfolgt dergestalt, da· der ProgrammzÑhler so weit er-
hîht wird, da· er ein ganzzahliges mehrfaches des Argumentes
wird.  In seiner Funktion entspricht ALIGN also DS.x 0 beim den
680x0ern, nur ist die Ausrichtung noch flexibler.

Beispiel:

	align 2

macht den ProgrammzÑhler gerade.  Wie auch bei DS.x 0 ist der
freibleibende Speicherraum undefiniert.


	3.3.26. LTORG      (SH7000)
	- - - - - - -

Da der SH7000-Prozessor seine Register immediate nur mit 8-Bit-
Werten laden kann, AS dem Programmierer jedoch vorgaukelt, da·
es eine solche EinschrÑnkung nicht gÑbe, mu· er die dabei ent-
stehenden Konstanten irgendwo im Speicher ablegen.  Da es nicht
sinnvoll wÑre, dies einzeln zu tun (wobei jedes Mal Sprungbe-
fehle anfallen wÅrden...), werden die Literale gesammelt und
kînnen vom Programmierer mit diesem Befehl gezielt blockweise
(z.B. am Ende eines Unterprogrammes) abgelegt werden.  Zu den
zu beachtenden Details und Fallen sei auf das Kapitel mit den
SH7000-spezifischen Dingen hingewiesen.


	3.4. Makrobefehle	(alle Prozessoren)
	-----------------

Kommen wir nun zu dem, was einen Makroassembler vom normalen As-
sembler unterscheidet: der Mîglichkeit, Makros zu definieren (ach
was ?!).

Unter Makros verstehe ich hier erst einmal einen Block von Anwei-
sungen (normal oder Pseudo), die mit bestimmten Befehlen zu einem
Block zusammengefa·t werden und dann auf bestimmte Weise bearbei-
tet werden kînnen.  Zur Bearbeitung solcher Blîcke kennt der As-
sembler folgende Befehle:

	3.4.1.  MACRO
        - - - - - - -

ist der wohl wichtigste Befehl zur Makroprogrammierung.  Mit der
Befehlsfolge

<Name>	MACRO	[Parameterliste]
	<Befehle>
	ENDM

wird das Makro <Name> als die eingeschlossene Befehlsfolge defi-
niert.  Diese Definition alleine erzeugt noch keinen Code!  DafÅr
kann fortan die Befehlsfolge einfach durch den Namen abgerufen
werden, das Ganze stellt also eine Schreiberleichterung dar.  Um
die ganze Sache etwas nÅtzlicher zu machen, kann man bei der Ma-
krodefinition eine Parameterliste mitgeben.  Die Parameternamen
werden wie Åblich durch Kommas getrennt und mÅssen - wie der Makro-
name selber - den Konventionen fÅr Symbolnamen (2.4.) genÅgen.

Sowohl Makronamen als auch -parameter sind von einer Umschaltung
von AS in den case-sensitiven Modus betroffen.

Makros sind Ñhnlich wie Symbole lokal, d.h. bei Definition in
einer Sektion sind sie nur in dieser Sektion und ihren Unter-
sektionen bekannt.  Dieses Verhalten lÑ·t sich aber durch die
weiter unten beschriebenen Optionen PUBLIC und GLOBAL in weiten
Grenzen steuern.

Neben den eigentlichen Makroparametern kînnen in der Parameterliste
auch Steuerparameter enthalten sein, die die Abarbeitung des be-
troffenen Makros beeinflussen; diese Parameter werden von normalen
Parametern dadurch unterschieden, da· sie in geschweifte Klammern
eingeschlossen sind.  Es sind folgende Steuerparameter definiert:

- EXPAND / NOEXPAND : legen fest, ob bei der spÑteren Verwendung
  diese Makros der expandierte Code mit angezeigt werden soll.
  Default ist der durch den Pseudobefehl MACEXP festgelegte Wert.

- PUBLIC[:Sektionsname] : ordnet das Makro nicht der aktuellen,
  sondern einer ihr Åbergeordneten Sektion zu.  Auf diese Weise
  kann eine Sektion Makros fÅr die "Au·enwelt" zur VerfÅgung
  stellen.  Fehlt eine Sektionsangabe, so wird das Makro vîllig
  global, d.h. ist Åberall benutzbar.

- GLOBAL[:Sektionsname] : legt fest, da· neben diesem Makro noch ein
  weiteres Makro abgelegt werden soll, das zwar den gleichen Inhalt
  hat, dessen Name aber zusÑtzlich mit dem Namen der Sektion ver-
  sehen ist, in der es definiert wurde und das der spezifizierten
  Sektion zugeordnet werden soll.  Bei dieser mu· es sich um eine
  Obersektion zu der aktuellen Sektion handeln; fehlt die Angabe,
  so wird das zusÑtzliche Makro global sichtbar.  Wird z.B. ein
  Makro A in der Sektion B definiert, die wiederum eine Untersektion
  der Sektion C ist, so wÅrde neben z.B. dem Makro A ein weiteres
  globales mit dem Namen C_B_A erzeugt.  WÅrde dagegen B als Ziel-
  sektion angegeben, so wÅrde das Makro B_A hei·en und der Sektion
  A zugeordnet.  Diese Option ist defaultmÑ·ig ausgeschaltet und hat
  auch nur einen Effekt, falls sie innerhalb einer Sektion benutzt
  wird.  Das lokal bekannte Originalmakro wird von ihr nicht beein-
  flu·t.

- EXPORT / NOEXPORT : legen fest, ob die Definition dieses Makros
  in einer getrennten Datei abgelegt werden soll, falls die
  Kommandozeilenoption -M gegeben wurde.  Auf diese Weise kînnen
  einzelne Definitionen "privater" Makros selektiv ausgeblendet
  werden.  Der Default ist FALSE, d.h. die Definition wird nicht in
  der Datei abgelegt.  Ist zusÑtzlich die GLOBAL-Option gegeben
  worden, so wird das Makro mit dem modifizierten Namen abgelegt.

Diese eben beschriebenen Steuerparameter werden von AS aus der
Parameterliste ausgefiltert, haben also keine weitere Wirkung in
der folgenden Verarbeitung und Benutzung.

Beim Aufruf eines Makros werden die beim Aufruf angegebenen Para-
meternamen Åberall textuell im Befehlsblock eingesetzt und der
sich so ergebene Assemblercode wird normal assembliert.  Sollten
beim Aufruf zu wenige Parameter angegeben werden, werden Null-
strings eingefÅgt.  Wichtig ist zu wissen, da· bei der Makroex-
pansion keine RÅcksicht auf eventuell in der Zeile enthaltene
Stringkonstanten genommen wird.  Zu diesem Detail gilt die alte
IBM-Regel:

 It's not a bug, it's a feature!

Diese LÅcke kann man bewu·t ausnutzen, um Parameter mittels String-
vergleichen abzuprÅfen.  So kann man auf folgende Weise z.B. prÅfen,
wie eine Makroparameter aussieht:

mul     MACRO   para,parb
	IF      UpString("PARA")<>"A"
         MOV    a,para
	ENDIF
        IF      UpString("PARB")<>"B"
         MOV    b,parb
        ENDIF
	mul     ab
	ENDM

Wichtig ist bei obigem Beispiel, da· der Assembler alle Parameter-
namen im case-insensitiven Modus in Gro·buchstaben umsetzt,
in Strings aber nie eine Umwandlung in Gro·buchstaben erfolgt.
Die Makroparameternamen mÅssen in den Stringkonstanten daher gro·
geschrieben werden.

FÅr die Makroparameter gelten die gleichen Konventionen wie bei
normalen Symbolen, mit der Ausnahme, da· hier nur Buchstaben und
Ziffern zugelassen sind, also weder Punkte noch Unterstriche.
Diese EinschrÑnkung hat ihren Grund in einem verstecktem Feature:
Der Unterstrich erlaubt es, einzelne Makroparameternamen zu einem
Symbol zusammenzuketten, z.B. in folgendem Beispiel:

concat	macro	part1,part2
	call	part1_part2
        endm

Der Aufruf

	concat	Modul,Funktion

ergibt also

	call	Modul_Funktion




Um alle Klarheiten auszurÑumen, ein einfaches Beispiel:

Ein Intelverblîdeter Programmierer mîchte die Befehle PUSH/POP
unbedingt auch auf dem 68000 haben.  Er lîst das Problem folgen-
derma·en:

push	macro	op
	move    op,-(sp)
	endm

pop	macro	op
	move	(sp)+,op
	endm

Schreibt man nun im Code

	push	d0
	pop	a2

so wird daraus

	move.w	d0,-(sp)
	move.w	(sp)+,a2

Eine Makrodefinition darf nicht Åber Includefilegrenzen hinausgehen.

In MakrorÅmpfen definierte Labels werden immer als lokal betrachtet,
ein expliziter LOCAL-Befehl ist also nicht erforderlich ( und ist
auch nicht definiert ).  Ist es aus irgendwelchen GrÅnden erforder-
lich, so kann man es mit LABEL definieren, dessen Anwendung (wie bei
BIT, SFR...) immer globale Symbole ergibt :

<Name>	label	$

Da der Assembler beim Parsing einer Zeile zuerst die Makroliste und
danach die Prozessorbefehle abklappert, lassen sich auch Prozessor-
befehle neu definieren.  Die Definition sollte dann aber vor der er-
sten Benutzung des Befehles durchgefÅhrt werden, um Phasenfehler wie
im folgenden Beispiel zu vermeiden:

	bsr	ziel

bsr	macro	target
	jsr	ziel
	endm

	bsr	ziel

Im ersten Pass ist bei der Assemblierung des BSR-Befehles das Makro
noch nicht bekannt, es wird ein 4 Byte langer Befehl erzeugt.  Im
zweiten Pass jedoch steht die Makrodefinition sofort (aus dem er-
sten Pass) zur VerfÅgung, es wird also ein 6 Byte langer JSR kodiert.
Infolgedessen sind alle darauffolgenden Labels um zwei zu niedrig,
bei allen weitern Labels sind Phasenfehler die Folge, und ein weiterer
Pass ist erforderlich.

Da durch die Definition eines Makros ein gleichnamiger Maschinen- oder
Pseudobefehl nicht mehr zugreifbar ist, gibt es eine HintertÅr, die
Originalbedeutung zu erreichen: Stellt man dem Mnemonic ein ! voran,
so wird das Durchsuchen der Makroliste unterdrÅckt.  Das kann bei-
spielsweise nÅtzlich sein, um Befehle in ihrer MÑchtigkeit zu erwei-
tern, z.B. die Schiebebefehle beim TLCS-90:

srl	macro	op,n		; Schieben um n Stellen
	rept	n		; n einfache Befehle
	 !srl	op
	endm
	endm

Fortan hat der SRL-Befehl einen weiteren Parameter...


	3.4.2.  IRP
	- - - - - -

ist die eine vereinfachte Form von Makrodefinitionen fÅr den Fall,
da· eine Befehlsfolge einmal auf mehrere Operanden angewendet werden
soll und danach nicht mehr gebraucht wird.  IRP benîtigt als ersten
Parameter ein Symbol fÅr den Operanden, und danach eine (fast) be-
liebige Menge von Parametern, die nacheinander in den Befehlsblock
eingesetzt werden.  Um eine Menge von Registern auf den Stack zu
schieben, kann man z.B. schreiben

	irp	op, acc,b,dpl,dph
	push	op
	endm

was in folgendem resultiert:

	push	acc
        push	b
        push	dpl
        push	dph

Benutzte Labels sind wieder fÅr jeden Durchgang automatisch lokal.


	3.4.3. REPT
        - - - - - -

ist die einfachste Form der Makrobenutzung.  Der im Rumpf angegebene
Code wird einfach sooft assembliert, wie der Integerparameter von
REPT angibt.  Dieser Befehl wird hÑufig in kleinen Schleifen anstelle
einer programmierten Schleife verwendet, um den Schleifenoverhead zu
sparen.

Der VollstÑndigkeit halber ein Beispiel:

	rept	3
        rr	a
        endm

rotiert den Akku um 3 Stellen nach rechts.

Symbole sind wiederum fÅr jede einzelne Repetition lokal.

Ist das Argument von REPT kleiner oder gleich Null, so wird Åberhaupt
keine Expansion durchgefÅhrt.  Dies ist ein Unterschied zu frÅheren
Versionen von AS, die hier etwas "schlampig" waren und immer mindes-
tens eine Expansion ausfÅhrten.


	3.4.4.  WHILE
	- - - - - - -

WHILE arbeitet analog zu REPT, allerdings tritt an die Stelle einer
festen Anzahl als Argument ein boolescher Ausdruck, und der zwischen
WHILE und ENDM eingeschlossene Code wird sooft assenbliert, bis der
Ausdruck logisch falsch wird.  Im Extremfall kann dies bedeuten, da·
der Code Åberhaupt nicht assembliert wird, falls die Bedingung bereits
beim Eintritt in das Konstrukt falsch ist.  Andererseits kann es na-
tÅrlich auch passieren, da· die Bedingung immer wahr bleibt, und AS
lÑuft bis an das Ende aller Tage...hier sollte man also etwas Umsicht
walten lassen, d.h. im Rumpf mu· eine Anweisung stehen, die die Be-
dingung auch beeinflu·t, z.B. so:

cnt     set     1
sq      set     cnt*cnt
        while   sq<=1000
	 dc.l    sq
cnt      set     cnt+1
sq       set     cnt*cnt
        endm

Dieses Beispiel legt alle Quadratzahlen bis 1000 im Speicher ab.

Ein unschînes Detail bei WHILE ist im Augenblick leider noch, da·
am Ende der Expansion eine zusÑtzliche Leerzeile, die im Quellrumpf
nicht vorhanden war, eingefÅgt wird.  Dies ist ein "Dreckeffekt", der
auf einer SchwÑche des Makroprozessors beruht und leider nicht so
einfach zu beheben ist.  Hoffentlich stîrt es nicht allzusehr....


	3.4.5.  EXITM
        - - - - - - -

EXITM stellt einen Weg dar, um eine Makroexpansion oder einen der
Befehle REPT, IRP oder WHILE vorzeitig abzubrechen.  Eine solche
Mîglichkeit hilft zum Beispiel, umfangreichere Klammerungen mit
IF-ENDIF-Sequenzen in Makros Åbersichtlicher zu gestalten.  Sinn-
vollerweise ist ein EXITM aber selber auch immer bedingt, was zu
einem wichtigen Detail fÅhrt: Der Stack, der Åber momentan offene
IF- oder SWITCH-Konstrukte Buch fÅhrt, wird auf den Stand vor
Beginn der Makroexpansion zurÅckgesetzt.  Dies ist fÅr bedingte
EXITM's zwingend notwendig, da das den EXITM-Befehl in irgendeiner
Form einschlie·ende ENDIF oder ENDCASE nicht mehr erreicht wird
und AS ohne einen solchen Trick eine Fehlermeldung erzeugen 
wÅrde.  Weiterhin ist es fÅr verschachtelte Makrokonstruktionen 
wichtig, zu beachten, da· EXITM immer nur das momentan innerste
Konstrukt abbricht!  Wer aus seiner geschachtelten Konstruktion
vollstÑndig "ausbrechen" will, mu· auf den hîheren Ebenen eben-
falls EXITM's vorsehen!


	3.4.6. FUNCTION
	- - - - - - - -

FUNCTION ist zwar kein Makrobefehl im engeren Sinne, da hierbei aber
Ñhnliche Mechanismen wie bei Makroersetzungen angewendet werden,
soll er hier beschrieben werden.
Dieser Befehl dient dazu, neue Funktionen zu definieren, die in For-
melausdrÅcken wie die vordefinierten Funktionen verwendet werden
kînnen.  Die Definition mu· in folgender Form erfolgen:

<Name>  FUNCTION <Arg>,..,<Arg>,<Ausdruck>

Die Argumente sind die Werte, die sozusagen in die Funktion "hineinge-
steckt" werden.  In der Definition werden fÅr die Argumente symboli-
sche Namen gebraucht, damit der Assembler bei der Benutzung der Funk-
tion wei·, an welchen Stellen die aktuellen Werte einzusetzen ist.
Dies kann man an folgendem Beispiel sehen:

isdigit FUNCTION ch,(ch>='0')&&(ch<='9')

Diese Funktion ÅberprÅft, ob es sich bei dem Argument (wenn man es
als Zeichen interpretiert) um eine Ziffer im momentan gÅltigen Zei-
chencode handelt (der momentane Zeichencode ist mittels CHARSET ver-
Ñnderbar, daher die vorsichtige Formulierung).

Die Argumentnamen (in diesem Falle CH) mu· den gleichen hÑrteren
Symbolkonventionen genÅgen wie Parameter bei einer Makrodefinition,
d.h. die Sonderzeichen . und _ sind nicht erlaubt.

Selbstdefinierte Funktionen werden genauso benutzt wie eingebaute,
d.h. mit einer durch Kommas getrennten, geklammerten Argumentliste:

        IF isdigit(Zeichen)
         message "\{Zeichen} ist eine Ziffer"
        ELSEIF
         message "\{Zeichen} ist keine Ziffer"
	ENDIF

Bei dem Aufruf der Funktion werden die Argumente nur einmal berechnet
und danach an allen Stellen der Formel eingesetzt, um den Rechenauf-
wand zu reduzieren und Seiteneffekte zu vermeiden.  Bei Funktionen
mit mehreren Argumenten mÅssen die einzelnen Argumente durch Kommata
getrennt werden.

ACHTUNG! Analog wie bei Makros kann man mit der Definition von Funk-
tionen bestehende Funktionen umdefinieren.  Damit lassen sich auch
wieder Phasenfehler provozieren.  Solche Definitionen sollten daher
auf jeden Fall vor der ersten Benutzung erfolgen!

Da die Berechnung des Funktionsergebnisses anhand des Formelaus-
druckes auf textueller Ebene erfolgt, kann der Ergebnistyp von
dem Typ des Eingangsargumentes abhÑngen.  So kann bei folgender
Funktion

double function x,x+x

das Ergebnis ein Integer, eine Gleitkommazahl oder sogar ein String
sein, je nach Typ des Arguments!

Bei der Definition und Ansprache von Funktionen wird im case-sensitiven
Modus zwischen Gro·- und Kleinschreibung unterschieden, im Gegensatz
zu eingebauten Funktionen!


	3.5. bedingte Assemblierung (alle Prozessoren)
	---------------------------

Der Assembler unterstÅtzt die bedingte Assemblierung mit Hilfe der
Befehle IF... sowie SWITCH... .  Diese Befehle wirken zur Assemblier-
zeit, indem entsprechend der Bedingung Teile Åbersetzt oder Åber-
sprungen werden.  Diese Befehle sind also nicht mit den IF-State-
ments hîherer Programmiersprachen zu vergleichen ( obwohl es sehr
verlockend wÑre, Assembler um die Strukturierungsbefehle hîherer
Sprachen zu erweitern...).

Die folgenden Konstrukte dÅrfen beliebig (bis zum SpeicherÅberlauf)
geschachtelt werden.


        3.5.1.  IF / ELSEIF / ENDIF
        - - - - - - - - - - - - - -

IF ist das gebrÑuchlichere und allgemeiner verwendbare Konstrukt.
Die allgemeine Form eines IF-Befehles lautet folgenderma·en:

	IF      <Ausdruck 1>
	.
        .
        <Block 1>
        .
        .
	ELSEIF  <Ausdruck 2>
        .
        .
	<Block 2>
        .
        .
        (mîgliche weitere ELSEIFs)

        .
        .
        ELSEIF
	.
	.
        <Block n>
        .
	.
        ENDIF

IF dient als Einleitung und wertet den ersten Ausdruck aus und assem-
bliert Block 1, falls der Ausdruck wahr (d.h. ungleich 0) ist.  Alle
weiteren ELSEIF-Teile werden dann ignoriert.  Falls der Ausdruck aber
nicht wahr ist, wird Block 1 Åbersprungen und Ausdruck 2 ausgewertet.
Sollte dieser nun wahr sein, wird Block 2 assembliert.  Die Zahl der
ELSEIF-Teile ist variabel und ergibt eine IF-THEN-ELSE-Leiter belie-
biger LÑnge.  Der dem letzten ELSEIF (ohne Parameter) zugeordnete
Block wird nur assembliert, falls alle vorigen AusdrÅcke falsch erga-
ben und bildet sozusagen einen "Default-Zweig".  Wichtig ist, da· von
den Blîcken immer nur EINER assembliert wird, und zwar der erste,
dessen zugeordnetes IF/ELSEIF einen wahren Ausdruck hatte.

Die ELSEIF-Teile sind optional, d.h. auf IF darf auch direkt ENDIF
folgen, ein parameterloses ELSEIF bildet aber immer den letzten
Zweig.

Ein ELSEIF bezieht sich immer auf das letzte, noch nicht abgeschlos-
sene IF.

Neben IF sind noch folgende weitere bedingte Befehle definiert:

IFDEF <Symbol>   : wahr, falls das angegebene Symbol definiert wurde.
		   Die Definition mu· vor IFDEF erfolgt sein.
IFNDEF <Symbol>  : Umkehrung zu IFDEF.
IFUSED <Symbol>  : wahr, falls das Symbol bisher mindestens einmal
		   benutzt wurde.
IFNUSED <Symbol> : Umkehrung zu IFUSED.
IFEXIST <Name>   : wahr, falls die angegebene Datei existiert.
		   FÅr Schreibweise und Suchpfade gelten gleiche
		   Regeln wie beim INCLUDE-Befehl (siehe Abschnitt
		   3.8.2.).
IFNEXIST <Name>  : Umkehrung zu IFEXIST.
IFB <Arg-Liste>  : wahr, falls alle Argumente der Parameterliste leer 
                   sind.
IFNB <Arg-Liste> : Umkehrung zu IFB.


	3.5.2  SWITCH / CASE / ELSECASE / ENDCASE
        - - - - - - - - - - - - - - - - - - - - -

CASE ist ein Spezialfall von IF und fÅr den Fall gedacht, da· ein
Ausdruck mit einer Reihe von Werten verglichen werden soll.  Dies
ist natÅrlich auch mit IF und einer Reihe von ELSEIFs machbar, die
folgende Form

            SWITCH  <Ausdruck>
            .
	    .
            CASE    <Wert 1>
	    .
            <Block 1>
            .
            CASE    <Wert 2>
	    .
            <Block 2>
            .
            (weitere CASE-Blîcke)
	    .
            CASE    <Wert n-1>
            .
            <Block n-1>
            .
            ELSECASE
            .
            <Block n>
	    .
            ENDCASE

bietet den Vorteil, da· der zu prÅfende Ausdruck nur einmal hinge-
schrieben und berechnet werden mu·, er ist also weniger fehleranfÑl-
lig und etwas schneller als eine IF-Kette, dafÅr natÅrlich auch
nicht so flexibel.

Es ist mîglich, bei den CASE-Anweisungen mehrere, durch Kommata
getrennte Werte anzugeben, um den entsprechenden Block in mehreren
FÑllen assemblieren zu lassen.  Der ELSECASE-Zweig dient wiederum
als "Auffangstelle" fÅr den Fall, da· keine der CASE-Bedingungen
greift.  Fehlt er und fallen alle PrÅfungen negativ aus, so gibt AS
eine Warnung aus.

Auch wenn die Wertelisten der CASE-Teile sich Åberlappen, so wird
immer nur EIN Zweig ausgefÅhrt, und zwar bei Mehrdeutigkeiten der
erste.

SWITCH dient nur der Einleitung des ganzen Konstruktes; zwischen ihm
und dem ersten CASE darf beliebiger Code stehe (andere IFs dÅrfen
aber nicht offen bleiben!), im Sinne eines durchschaubaren Codes
sollte davon aber kein Gebrauch gemacht werden.


	3.6. Listing-Steuerung   (alle Prozessoren)
	----------------------

	3.6.1. PAGE
        - - - - - -

Mit PAGE kann man AS die Dimensionen des Papiers, auf dem das Listing
ausgedruckt werden soll, mitteilen.  Als erster Parameter wird dabei
die Anzahl von Zeilen angegeben, nach der AS automatisch einen Zeilen-
vorschub ausgeben soll.  Zu berÅcksichtigen ist allerdings, da· bei
dieser Angabe die Kopfzeilen inklusive einer evtl. mit TITLE spezi-
fizierten Zeile nicht mitgerechntet werden.  Der Minimalwert fÅr die
Zeilenzahl ist 5, der Maximalwert 255.  Eine Angabe von 0 fÅhrt dazu,
da· AS Åberhaupt keine automatischen SeitenvorschÅbe ausfÅhrt, sondern
nur noch solche, die explizit durch NEWPAGE-Befehle oder implizit am
Ende des Listings (z.B. vor der Symboltabelle) von AS ausgelîst wur-
den.
Die Angabe der Breite des Listings in Zeichen kann als optionaler
zweiter Parameter erfolgen und erfÅllt zwei Zwecke: Zum einen lÑuft
der ZeilenzÑhler von AS korrekt weiter, wenn eine Quell-Zeile Åber
mehrere Listing-Zeilen geht, zum anderen gibt es Drucker (wie z.B.
Laserdrucker), die beim öberschreiten des rechten Randes nicht automa-
tisch in eine neue Zeile umbrechen, sondern den Rest einfach "ver-
schlucken".  Aus diesem Grund fÅhrt AS auch den Zeilenumbruch selbst-
stÑndig durch, d.h. zu lange Zeilen werden in BruchstÅcke zerlegt, die
eine LÑnge kleiner oder gleich der eingestellten LÑnge haben.  In Zu-
sammenhang mit Druckern, die einen automatischen Zeilenumbruch besit-
zen, kann das aber zu doppelten ZeilenvorschÅben fÅhren, wenn man als
Breite exakt die Zeilenbreite des Druckers angibt.  Die Lîsung in einem
solchen Fall ist, als Zeilenbreite ein Zeichen weniger anzugeben.
Die eingestellte Zeilenbreite darf zwischen 5 und 255 Zeichen liegen;
analog zur SeitenlÑnge bedeutet ein Wert von 0, da· AS keine Splittung
der Listing-Zeilen vornehmen soll; eine BerÅcksichtigung von zu langen
Zeilen im Listing beim Seitenumbruch kann dann natÅrlich auch nicht
mehr erfolgen.

Die Defaulteinstellung fÅr die SeitenlÑnge ist 60 Zeilen, fÅr die
Zeilenbreite 0; letztere Wert wird auch angenommen, wenn PAGE nur mit
einem Argument aufgerufen wird.

ACHTUNG! AS hat keine Mîglichkeit, zu ÅberprÅfen, ob die eingestellte
Listing-LÑnge und Breite mit der Wirklichkeit Åbereinstimmen!


	3.6.2.  NEWPAGE
	- - - - - - - -

NEWPAGE kann dazu benutzt werden, einen Seitenvorschub zu erzwingen,
obwohl die Seite noch gar nicht voll ist.  Dies kann z.B. sinnvoll
sein, um logisch voneinander getrennte Teile im Assemblerprogramm
auch seitenmÑ·ig zu trennen.  Der programminterne ZeilenzÑhler wird
zurÅckgesetzt, der SeitenzÑhler um Eins heraufgezÑhlt.  Der optio-
nale Parameter steht in Zusammenhang mit einer hierarchischen Seiten-
numerierung, die AS bis zu einer Kapiteltiefe von 4 unterstÅtzt.
0 bedeutet dabei immer die tiefste Kapitelebene, der Maximalwert kann
sich wÑhrend des Laufes verÑndern, wenn das auch verwirrend wirken
kann, wie folgendes Beispiel zeigt:

Seite 1,   Angabe NEWPAGE 0  ---> Seite 2
Seite 2,   Angabe NEWPAGE 1  ---> Seite 2.1
Seite 2.1, Angabe NEWPAGE 1  ---> Seite 3.1
Seite 3.1, Angabe NEWPAGE 0  ---> Seite 3.2
Seite 3.2, Angabe NEWPAGE 2  ---> Seite 4.1.1

Je nach momentan vorhandener Kapiteltiefe kann NEWPAGE <Nummer> also
an verschiedenen Stellen eine Erhîhung bedeuten.  Ein automatischer
Seitenvorschub wegen ZeilenÅberlauf oder ein fehlender Parameter ist
gleichbedeutend mit NEWPAGE 0.  Am Ende des Listings wird vor Ausgabe
der Symboltabelle ein implizites NEWPAGE <bish. Maximum> durchge-
fÅhrt, um sozusagen ein neues Hauptkapitel zu beginnen.


	3.6.3. MACEXP
        - - - - - - -

Mit dem Befehl

     macexp off

kann man erreichen, da· bei Makroexpansionen nur noch der Makroauf-
ruf und nicht der expandierte Text ausgegeben wird.  Die ist bei
makrointensivem Code sinnvoll, um das Listing nicht ins Uferlose
wachsen zu lassen.  Mit

     macexp on

wird die vollstÑndige Listingform wieder eingeschaltet, dies ist auch
die Defaultvorgabe.

Zwischen der Bedeutung von MACEXP fÅr Makros und der fÅr alle anderen
makroartigen Konstrukte (z.B. REPT) besteht ein subtiler Unterschied:
WÑhrend Makros intern ein Flag besitzen, das anzeigt, ob Expansionen
dieses Makros ausgegeben werden sollen oder nicht, wirkt MACEXP direkt
auf alle anderen Konstrukte, die "vor Ort" aufgelîst werden.  Der Sinn
dieser Differenzierung besteht darin, da· es Makros geben kann, die
ausgetestet sind und die man nicht mehr sehen will, andere aber sehr
wohl noch.  MACEXP dient hier als Default fÅr das bei der Definition
des Makros zu setzende Flag, der mit den Steuerparametern NOEXPAND/
EXPAND Åbersteuert werden kann.

Die momentane Einstellung lÑ·t sich aus dem Symbol MACEXP auslesen.


	3.6.4.  LISTING
	- - - - - - - -

funktioniert wie MACEXP und akzeptiert die gleichen Parameter, 
arbeitet aber wesentlich radikaler: Mit

     listing off

wird Åberhaupt nichts mehr im Listing ausgegeben.  Diese Anweisung
macht Sinn fÅr erprobte Codeteile oder Includefiles, um den Papier-
verbrauch nicht ins Unerme·liche zu steigern.  ACHTUNG! Wer spÑter
das GegenstÅck vergi·t, bekommt auch keine Symboltabelle mehr zu
sehen!  ZusÑtzlich zu ON und OFF akzeptiert LISTING auch NOSKIPPED
und PURECODE als Argument.  Mit der NOSKIPPED-Einstellung werden
aufgrund bedingter Assemblierung nicht assemblierte Teile nicht im
Listing aufgefÅhrt, wÑhrend PURECODE - wie der Name schon erahnen
lÑ·t - auch die IF-Konstrukte selber nicht mehr im Listing auffÅhrt.
Diese Einstellungen sind nÅtzlich, wenn man Makros, die anhand von
Parametern verschiedene Aktionen ausfÅhren, benutzt, und im Listing
nur noch die jeweils benutzten Teile sehen mîchte.

Die momentane Einstellung lÑ·t sich aus dem Symbol LISTING (0=OFF,
1=ON, 2=NOSKIPPED, 3=PURECODE) auslesen.


	3.6.5.  PRTINIT und PRTEXIT
	- - - - - - - - - - - - - -

Bei der Listingausgabe auf Druckern ist es oftmals sinnvoll, den
Drucker in eine andere Betriebsart (z.B. Schmalschrift) umzuschal-
ten und am Ende des Listings diese Betriebsart zu deaktivieren. Mit
diesen Befehlen kann die Ausgabe dieser Steuerfolgen automatisiert
werden, indem man mit PRTINIT <String> die Zeichenfolge angibt, die
vor Listingbeginn an das AusgabegerÑt geschickt werden soll und mit
PRTEXIT <String> analog den Deinitialisierungsstring.  In beiden
FÑllen mu· <String> ein Stringausdruck sein.  Die Schreibungsregeln
fÅr Stringkonstanten ermîglichen es, ohne Verrenkungen Steuerzeichen
in den String einzubauen.

Bei der Ausgabe dieser Strings unterscheidet der Assembler NICHT,
wohin das Listing geschickt wird, d.h. Druckersteuerzeichen wer-
den rÅcksichtslos auch auf den Bildschirm geschickt!

Beispiel :

Bei Epson-Druckern ist es sinnvoll, sie fÅr die breiten Listings
in den Kompre·druck zu schalten.  Die beiden Zeilen

	prtinit "\15"
	prtexit "\18"

sorgen dafÅr, da· der Kompre·druck ein- und nach dem Druck wieder
ausgeschaltet wird.

	3.6.6.  TITLE
	- - - - - - -

Normalerweise versieht der Assembler bereits jede Listingseite mit
einer Titelzeile, die Quelldatei, Datum und Uhrzeit enthÑlt.  Mit
diesem Befehl kann man den Seitenkopf um eine beliebige zusÑtzliche
Zeile erweitern.  Der anzugebende String ist dabei ein beliebiger
Stringausdruck.

Beispiel:

Bei dem bereits oben angesprochenenen Epson-Drucker soll eine Titel-
zeile im Breitdruck ausgegeben werden, wozu vorher der Kompre·modus
abgeschaltet werden mu·:

	title	"\18\14Breiter Titel\15"

(Epson-Drucker schalten den Breitdruck automatisch am Zeilenende
aus.)


	3.7. lokale Symbole 	(alle Prozessoren)
        -------------------

Bei den lokalen Labels und den dazu eingefÅhrten Sektionen handelt
es sich um eine grundlegend neue Funktion, die mit Version 1.39
eingefÅhrt wird.  Da dieser Teil sozusagen "1.0" ist, ist er
sicherlich noch nicht der Weisheit letzter Schlu·.  Anregungen und
(konstruktive) Kritik sind daher besonders erwÅnscht.  Insbesondere
habe ich die Verwendung von Sektionen hier so dargestellt, wie ich
sie mir vorstelle.  Es kann dadurch passiert sein, da· die RealitÑt
nicht ganz meinem Modell im Kopf entspricht.  FÅr den Fall von Dis-
krepanzen verspreche ich, da· die RealitÑt der Dokumentation ange-
pa·t wird, und nicht umgekehrt, wie es bei grî·eren Firmen schon
einmal vorgekommen sein soll...

AS erzeugt keinen linkfÑhigen Code (und wird es wohl auch nicht in
nÑherer Zukunft tun :-( ).  Diese Tatsache zwingt dazu, ein Programm
immer im ganzen zu Åbersetzen.  Dieser Technik gegenÅber hÑtte eine
Aufteilung in Linker-Module einige Vorteile:

 - kÅrzere öbersetzungszeiten, da lediglich die geÑnderten Module
   neu Åbersetzt werden mÅssen;
 - die Mîglichkeit, durch Definition îffentlicher und privater Symbole
   definierte Schnittstellen zwischen den Modulen festzulegen;
 - Durch die geringere LÑnge der einzelnen Module reduziert sich die
   Anzahl der Symbole im einzelnen Modul, so da· kÅrzere und trotzdem
   eindeutige Symbolnamen benutzt werden kînnen.

Insbesondere der letzte Punkt hat mich persînlich immer etwas gestîrt:
War ein Label-Name einmal am Anfang eines 2000 Zeilen langen Programmes
benutzt, so durfte er nirgendwo wieder verwendet werden --- auch nicht am
anderen Ende des Quelltextes, wo Routinen mit ganz anderem Kontext
standen.  Ich war dadurch gezwungen, zusammengesetzte Namen der Form

   <Unterprogrammname>_<Symbolname>

zu verwenden, die dann LÑngen zwischen 15 und 25 Zeichen hatten und
das Programm unÅbersichlich machten.  Das im folgenden eingehender
beschriebene Sektionen-Konzept sollte zumindest den beiden letzten
genannten Punkten abhelfen.  Es ist vollstÑndig optional: Wollen Sie
keine Sektionen verwenden, so lassen Sie es einfach bleiben und ar-
beiten weiter wie unter den Ñlteren AS-Versionen.


	3.7.1. Grunddefinition (SECTION/ENDSECTION)
	- - - - - - - - - - - - - - - - - - - - - -

Eine Sektion stellt einen durch spezielle Befehle eingerahmten Teil des
Assembler-Programmes dar und hat einen vom Programmierer festlegbaren,
eindeutigen Namen:

        .
        .
        <anderer Code>
        .
        .
	SECTION <Sektionsname>
        .
        .
        <Code in der Sektion>
        .
        .
	ENDSECTION [Sektionsname]
        .
	.
        <anderer Code>
        .
        .
\end{verbatim}

entsprechen; da AS Sektions-und Symbolnamen in getrennten Tabellen
speichert, darf ein Name sowohl fÅr ein Symbol als auch eine Sektion
verwendet werden.  Sektionsnamen mÅssen in dem Sinne eindeutig sein,
da· auf einer Ebene nicht zwei Sektionen den gleichen Namen haben
dÅrfen (was es mit den "Ebenen" auf sich hat, erlÑutere ich im
nÑchsten Abschnitt).  Das Argument zu ENDSECTION ist optional, es darf
auch weggelassen werden; Falls es weggelassen wird, zeigt AS den Namen
der Sektion an, der er das ENDSECTION zugeordnet hat.  Code in einer
Sektion wird von AS genauso behandelt wie au·erhalb, lediglich mit
drei entscheidenden Unterschieden:

 - Innerhalb der Sektion definierte Symbole (z.B. Labels, EQUs...)
   werden mit einer von AS intern vergebenen, der Sektion zugeordneten
   Nummer versehen.  Diese Symbole sind von Code au·erhalb der Sektion
   nicht ansprechbar (das lÑ·t sich natÅrlich durch Pseudobefehle va-
   riieren, aber dazu spÑter mehr).
 - Durch das zusÑtzliche Attribut kann ein Symbolname sowohl au·erhalb
   der Sektion als auch innerhalb definiert werden, das Attribut er-
   laubt also, Symbolnamen mehrfach zu benutzen, ohne da· AS Protest
   anmeldet.
 - Falls ein Symbol sowohl au·erhalb als auch innerhalb definiert ist,
   wird innerhalb der Sektion das "lokale" verwendet, d.h. AS sucht in
   der Symboltabelle zuerst nach einem Symbol des gewÅnschten Namens,
   das auch gleichzeitig der Sektion zugeordnet wurde.  Erst danach
   wird nach einem globalen Symbol dieses Namens gefahndet.

Mit diesem Mechanismus kann man z.B. den Code in Module aufteilen, wie
man es mit einem Linker getan hÑtte.  Eine feinere Aufteilung wÑre da-
gegen, alle Routinen in getrennte Sektionen zu verpacken.  Je nach
LÑnge der Routinen kînnen die nur intern benîtigten Symbole dann sehr
kurze Namen haben.

DefaultmÑ·ig unterscheidet AS Gro·-und Kleinschreibung in Sektions-
namen nicht; schaltet man jedoch in den case-sensitiven Modus um, so
wird die Schreibweise genauso wie bei Symbolnamen berÅcksichtigt.

Die bisher beschriebene Aufteilung wÅrde in etwa der Sprache C ent-
sprechen, in der alle Funktionen auf gleicher Ebene nebeneinander ste-
hen.  Da mein "hochsprachliches" Vorbild aber Pascal ist, bin ich noch
einen Schritt weiter gegangen:


        3.7.2.  Verschachtelung und Sichtbarkeitsregeln
        - - - - - - - - - - - - - - - - - - - - - - - -

Es ist erlaubt, in einer Sektion weitere Sektionen zu definieren,
analog zu der Mîglichkeit in Pascal, in einer Prozedur/Funktion wei-
tere Prozeduren zu definieren.  Dies zeigt folgendes Beispiel:

sym     EQU        0

        SECTION    ModulA

         SECTION    ProcA1

sym       EQU        5

	 ENDSECTION ProcA1

         SECTION    ProcA2

sym       EQU        10

	 ENDSECTION ProcA2

	ENDSECTION ModulA


	SECTION    ModulB

sym      EQU        15

	 SECTION    ProcB

	 ENDSECTION ProcB

	ENDSECTION ModulB

Bei der Suche nach einem Symbol sucht AS zuerst ein Symbol, das der
aktuellen Sektion zugeordnet ist, und geht danach die ganze "Liste"
der Vatersektionen durch, bis er bei den globalen Symbolen angekommen
ist.  Im Beispiel sehen die Sektionen folgende Werte fÅr das Symbol
sym:

    Sektion      Wert     aus Sektion...

    Global         0         Global
    ModulA         0         Global
    ProcA1         5         ProcA1
    ProcA2        10         ProcA2
    ModulB        15         ModulB
    ProcB         15         ModulB

Diese Regel kann man durchbrechen, indem man explizit an den Symbol-
namen die Sektion anhÑngt, aus der man das Symbol holen will, und
zwar in eckigen Klammern am Ende des Symbolnamens:

	move.l  #sym[ModulB],d0

Es dÅrfen dabei nur Sektionsnamen verwendet werden, die eine Obersek-
tion zur aktuellen Sektion darstellen.  Als Sonderwert sind die Namen
PARENT0..PARENT9 erlaubt, mit denen man die n-ten "Vatersektionen"
relativ zur momentanen Sektion ansprechen kann; PARENT0 entspricht
also der momentanen Sektion selber, PARENT1 der direkt Åbergeordneten
usw.  Anstelle PARENT1 kann man auch kurz nur PARENT schreiben.
LÑ·t man dagegen den Platz zwischen den Klammern komplett frei, also
etwa so

	move.l  #sym[],d0 ,

so erreicht man das globale Symbol.  ACHTUNG! Wenn man explizit ein
Symbol aus einer Sektion anspricht, so wird auch nur noch bei den
Symbolen dieser Sektion gesucht, der Sektionsbaum wird nicht mehr
bis nach oben durchgegangen!

Analog zu Pascal ist es erlaubt, da· verschiedene Sektionen Untersek-
tionen gleichen Namens haben dÅrfen, das Prinzip der LokalitÑt ver-
hindert hier Irritationen.  M.E. sollte man davon aber trotzdem spar-
samen Gebrauch machen, da in Symbol-und Querverweisliste Symbole zwar
mit der Sektion, in der sie definiert wurden, gekennzeichnet werden,
aber nicht mit der Åber dieser Sektion evtl. liegenden "Sektions-
hierarchie" (das hÑtte einfach den Platz in der Zeile gesprengt);
Unterscheidungen sind dadurch nicht erkennbar.

Da ein SECTION-Befehl von selber kein Label definiert, besteht hier
ein wichtiger Unterschied zu Pascal: Eine Pascal-Prozedur kann ihre
Unterprozeduren/funktionen automatisch "sehen", unter AS mu· man noch
einen Einsprungpunkt extra definieren.  Das kann man z.B. mit folgen-
dem Makro-PÑrchen tun:

proc    MACRO   name
        SECTION name
name    LABEL   $
	ENDM

endp    MACRO   name
        ENDSECTION name
        ENDM

Diese Beispiel zeigt gleichzeitig, da· die LokalitÑt von Labels in
Makros nicht von den Sektionen beeinflu·t wird, deshalb der Trick mit
dem LABEL-Befehl.

NatÅrlich ist mit dieser Definition das Problen noch nicht ganz ge-
lîst, bisher ist das Einsprung-Label ja noch lokal und von au·en
nicht zu erreichen.  Damit sind wir auch schon beim passenden Thema:


	3.7.3.  PUBLIC und GLOBAL
	- - - - - - - - - - - - -

Die PUBLIC-Anweisung erlaubt es, die Zugehîrigkeit eines Symbols zu
einer bestimmten Sektion zu verÑndern.  Es ist mîglich, mit einem
PUBLIC-Befehl mehrere Symbole zu bearbeiten, ohne BeschrÑnkung der
Allgemeinheit will ich aber ein Beispiel mit nur einer Variable ver-
wenden: Im einfachsten Falle erklÑrt man ein Symbol als vollstÑndig
global, d.h. es ist von allen Stellen des Programmes ansprechbar:

	PUBLIC  <Name>

Da ein Symbol bei seiner Definition endgÅltig in der Symboltabelle
einsortiert wird, mu· diese Anweisung VOR der Definition des Symbols
erfolgen.  Alle PUBLICs werden von AS in einer Liste vermerkt und bei
ihrer Definition aus dieser Liste wieder entfernt.  Bei Beendigung
einer Sektion gibt AS Fehlermeldungen fÅr alle nicht aufgelîsten
"VorwÑrtsreferenzen" aus.

Angesichts des hierarchischen Sektionenkonzepts erscheint die Methode,
ein Symbol als vollstÑndig global zu definieren, reichlich brachial.
Es geht aber auch etwas differenzierter, indem man zusÑtzlich einen
Sektionsnamen angibt:

	PUBLIC  <Name>:<Sektion>

Damit wird das Symbol der genannten Sektion zugeordnet und damit auch
allen ihren Untersektionen zugÑnglich (es sei denn, diese definieren
wiederum ein Symbol gleichen Namens, das dann das "globalere" Åber-
steuert).  NaturgemÑ· protestiert AS, falls mehrere Untersektionen
ein Symbol gleichen Namens auf die gleiche Ebene exportieren wollen.
Als Spezialwert fÅr <Sektion> ist PARENT zugelassen, dieser Wert
bedeutet, das Symbol genau eine Ebene hinaufzuexportieren.
Es sind als Sektionen nur der momentanen Sektion Åbergeordnete Sektio-
nen zugelassen, also keine, die im Baum aller Sektionen in einem
anderen Zweig stehen.  Sollten dabei mehrere Sektionen den gleichen
Namen haben (dies ist legal), so wird die tiefste gewÑhlt.

Mit diesem Werkzeug kann das obige Prozedurmakro nun Sinn ergeben:

proc    MACRO   name
        SECTION name
	PUBLIC  name:PARENT
name    LABEL   $
        ENDM

Diese Einstellung entspricht dem Modell von Pascal, in der eine Un-
terprozedur auch nur von ihrem "Vater" gesehen werden kann, jedoch
nicht vom "Gro·vater".

Falls mehrere Untersektionen versuchen, ein Symbol gleichen Namens
in die gleiche Obersektion zu exportieren, meckert AS Åber doppelt
definierte Symbole, was an sich ja korrekt ist.  War das gewollt,
so mu· man die Symbole in irgendeiner Weise "qualifizieren", damit
sie voneinander unterschieden werden kînnen.  Dies ist mit der
GLOBAL-Anweisung mîglich.  Die Syntax von GLOBAL ist der von PUBLIC
identisch, das Symbol bleibt aber lokal, anstatt einer hîheren
Sektion zugeordnet zu werden.  Stattdessen wird ein weiteres Symbol
gleichen Werts erzeugt, dem jedoch der Untersektionsname mit einem
Unterstrich vorangestellt wird, und nur dieses Symbol wird der
Sektionsangabe entsprechend îffentlich gemacht.  Definieren z.B.
zwei Sektionen A und B ein Symbol SYM und exportieren es mit GLOBAL
zu ihrer Vatersektion, so werden dort die Symbole unter den Namen
A_SYM und B_SYM eingeordnet.

Falls zwischen Quell- und Zielsektion mehrere Stufen stehen sollten,
so wird entsprechend der komplette Namenszweig an den Symbolnamen
angehÑngt.


	3.7.4.  FORWARD
	- - - - - - - -

So schîn das bisher besprochene Modell ist, ein bei Pascal nicht
auftauchendes Detail macht érger: die bei Assembler mîglichen Vor-
wÑrtsreferenzen.  Bei VorwÑrtsreferenzen kann es sein, da· AS im
ersten Pass auf ein Symbol einer hîheren Sektion zugreift.  Dies
ist an sich nicht weiter tragisch, solange im zweiten Pass das rich-
tige Symbol genommen wird, es kînnen aber UnfÑlle der folgenden Art
passieren:

loop:   .
        <Code>
	.
	.
	SECTION sub
	.               ; ***
	.
	bra.s   loop
	.
	.
loop:   .
	.
	ENDSECTION
	.
	.
	jmp     loop    ; Hauptschleife

AS wird im ersten Pass das globale Label loop verwenden, sofern das
ProgrammstÅck bei <Code> hinreichend lang ist, wird er sich Åber eine
zu gro·e Sprungdistanz beklagen und den zweiten Pass erst gar nicht
versuchen.  Um die Uneindeutigkeit zu vermeiden, kann man natÅrlich
explizit angeben, woher das Symbol kommen soll:

	bra.s   loop[sub]

Falls ein lokales Symbol hÑufig referenziert wird, kînnen die vielen
Klammern mit dem FORWARD-Befehl eingespart werden.  Das Symbol
wird damit explizit als lokal angekÅndigt.  AS wird dann bei Zugriffen
auf dieses Symbol automatisch nur im lokalen Symbolbereich suchen.  In
diesem Falle mÅ·te an der mit *** gekennzeichneten Stelle dafÅr der
Befehl

	FORWARD loop

stehen.

Damit FORWARD Sinn macht, mu· es nicht nur vor der Definition des
Symbols, sondern vor seiner ersten Benutzung in der Sektion gegeben
werden.  Ein Symbol gleichzeitig privat und îffentlich zu definieren,
ergibt keinen Sinn und wird von AS auch angemahnt.


	3.7.5.  Geschwindigkeitsaspekte
        - - - - - - - - - - - - - - - -

Die mehrstufige Suche in der Symboltabelle und die Entscheidung, mit
welchem Attribut ein Symbol eingetragen werden soll, kosten naturgemÑ·
etwas Rechenzeit.  Ein 1800 Zeilen langes 8086-Progamm z.B. wurde nach
der Umstellung auf Sektionen statt in 33 in 34,5 Sekunden assembliert
(80386 SX, 16MHz, 3 DurchgÑnge).  Der Overhead hÑlt sich also in Gren-
zen: Ob man ihn in Kauf nehmen will, ist (wie am Anfang erwÑhnt) eine
Frage des Geschmacks;  man kann AS genauso gut ohne Sektionen verwen-
den.


        3.8. Diverses
	-------------


        3.8.1. SHARED           (alle Prozessoren)
	- - - - - - -

Mit diesem Befehl weist man den AS an, die in der Parameterliste 
angegebenen Symbole (egal ob Integer, Gleitkomma oder String) im
Sharefile mit ihren Werten abzulegen.  Ob eine solche Datei Åber-
haupt und in welchem Format erzeugt wird, hÑngt von den in 2.1. be-
schriebenen Kommandozeilenschaltern ab.  Findet AS diesen Befehl und 
es wird keine Datei erzeugt, fÅhrt das zu einer Warnung.

VORSICHT! Ein eventuell der Befehlszeile anhÑngender Kommentar wird 
in die erste, ausgegebene Zeile mit Åbertragen (sofern die Argument-
liste von SHARED leer ist, wird nur der Kommentar ausgegeben).  Falls
die Share-Datei fÅr C oder Pascal erzeugt wird, sind einen C/Pascal-
Kommentar schlie·ende Zeichenfolgen ("*/" bzw. "*)") im Kommentar zu
vermeiden.  AS prÅft dies nicht!


        3.8.2.  INCLUDE         (alle Prozessoren)
	- - - - - - - -

Dieser Befehl fÅgt die im Parameter angegebene Datei (die optional in
Hochkommas eingeschlossen sein darf) so im Text ein, als ob sie dort
stehen wÅrde.  Dieser Befehl ist sinnvoll, um Quelldateien aufzuspal-
ten, die alleine nicht in den Speicher passen wÅrden oder um sich
"Toolboxen" zu erzeugen.

Falls der angegebene Dateiname keine Endung hat, wird er automatisch
um die Endung "INC" erweitert.

Mit der Kommandozeilenoption -i <Pfadliste> lÑ·t sich eine Liste von
Verzeichnissen angeben, in denen automatisch zusÑtzlich nach der In-
cludedatei gesucht werden soll.  Wird die Datei nicht gefunden, so
ist dies ein FATALER Fehler, d.h. der Assembler bricht sofort ab.

Aus KompatibilitÑtsgrÅnden ist es erlaubt, den Dateinamen in GÑnse-
fÅ·chen zu schreiben,

	include	stddef51
und
	include	"stddef51.inc"

sind also Ñquivalent.  ACHTUNG! Wegen dieser Wahlfreiheit ist hier
nur eine Stringkonstante, aber kein Stringausdruck zulÑssig!

Sollte der Dateiname eine Pfadangabe enthalten, so wird die Suchliste
ignoriert.


	3.8.3.   BINCLUDE (alle Prozessoren)
        - - - - - - - - -

BINCLUDE dient dazu, in den von AS erzeugten Code BinÑrdaten einzu-
betten, die von einem anderen Programm erzeugt wurden (das kann 
natÅrlich theoretisch auch von AS selber erzeugter Code sein...).
BINCLUDE hat drei Formen:

   BINCLUDE <Datei>

In dieser Form wird die Datei komplett eingebunden.

   BINCLUDE <Datei>,<Offset>

In dieser Form wird der Inhalt der Datei ab <Offset> bis zum Ende
der Datei eingebunden.

   BINCLUDE <Datei>,<Offset>,<LÑnge>

In dieser Form werden <LÑnge> Bytes ab Offset <Offset> eingebunden.

Es gelten die gleichen Regeln bezÅglich Suchpfaden wie bei INCLUDE.


	3.8.4.  MESSAGE, WARNING, ERROR und FATAL (alle Prozessoren)
	- - - - - - - - - - - - - - - - - - - - -

Der Assembler prÅft zwar die Quelltexte so streng wie mîglich und
liefert diffenzierte Fehlermeldungen, je nach Anwendung kann es
aber sinnvoll sein, unter bestimmten Bedingungen zusÑtzliche Fehler-
meldungen auszulîsen, mit denen sich logische Fehler automatisch
prÅfen lassen.  Der Assembler unterscheidet drei Typen von Fehler-
meldungen, die Åber die drei Befehle auch dem Programmierer zugÑng-
lich sind:

- WARNING : Fehler, die auf mîglicherweise falschen oder ineffi-
	    zienten Code hinweisen.  Die Assemblierung lÑuft weiter,
	    eine Codedatei wird erzeugt.

- ERROR   : echte Fehler im Programm.  Die Assemblierung lÑuft wei-
	    ter, um mîgliche weitere Fehler in einem Durchgang ent-
	    decken und korrigieren zu kînnen.  Eine Codedatei wird
	    nicht erzeugt.

- FATAL   : schwerwiegende Fehler, die einen sofortigen Abbruch des
	    Assemblers bedingen.  Eine Codedatei kann mîglicherweise
	    entstehen, ist aber unvollstÑndig.

Allen vier Befehlen ist das Format gemeinsam, in dem die Fehlermel-
dung angegeben werden mu·: Ein beliebig (berechneter?!) Stringaus-
druck, der damit sowohl eine Konstante als auch variabel sein darf.

Diese Anweisungen ergeben nur in Zusammenhang mit bedingter Assem-
blierung Sinn.  Ist fÅr ein Programm z.B. nur ein begrenzter Adre·-
raum vorhanden, so kann man den öberlauf folgenderma·en testen:

ROMSize		equ	8000h		; 27256-EPROM

ProgStart:
		.
		.
		<das eigentliche Programm>
		.
		.
ProgEnd:

		if 	ProgEnd-ProgStart>ROMSize
		 error	"\aDas Programm ist zu lang!"
		endif

Neben diesen fehlererzeugenden Befehlen gibt es noch den Befehl
MESSAGE, der einfach nur eine Meldung auf der Konsole bzw. im
Listing erzeugt.  Seine Benutzung ist den anderen drei Befehlen
gleich.


	3.8.5. READ (alle Prozessoren)
	- - - - - -

READ ist sozusagen das GegenstÅck zu der vorigen Befehlsgruppe: mit
ihm ist es mîglich, wÑhrend der Assemblierung Werte von der Tastatur
einzulesen.  Wozu das gut sein soll?  Um das darzulegen, soll hier
ausnahmsweise einmal das Beispiel vor die genauere ErlÑuterung gezo-
gen werden:

Ein Programm benîtigt zum Datentransfer einen Puffer mit einer zur
öbersetzungszeit festzulegenden Grî·e.  Um die Grî·e des Puffers
festzulegen, kînnte man sie einmal mit EQU in einem Symbol ablegen,
es geht aber auch interaktiv mit READ:

      IF     MomPass=1
       READ  "Puffergrî·e",BufferSize
      ENDIF

Auf diese Weise kînnen Programme sich wÑhrend der öbersetzung inter-
aktiv konfigurieren, man kann sein Programm z.B. jemandem geben, der
es mit seinen Parametern Åbersetzen kann, ohne im Quellcode "herum-
stochern" zu mÅssen.  Die im Beispiel gezeigte IF-Abfrage sollte
Åbrigens immer verwendet werden, damit der Anwender nur einmal mit
der Abfrage belÑstigt wird.

READ Ñhnelt sehr stark dem SET-Befehl, nur da· der dem Symbol zuzu-
weisende Wert nicht rechts vom SchlÅsselwort steht, sondern von der
Tastatur eingelesen wird.  Dies bedeutet z.B. auch, da· AS anhand
der Eingabe automatisch festlegt, ob es sich um eine Integer- oder
Gleitkommazahl oder einen String handelt und anstelle einzelner
Konstanten auch ganze FormelausdrÅcke eingegeben werden kînnen.

READ darf entweder nur einen Parameter oder zwei Parameter haben,
denn die Meldung zur Eingabeaufforderung ist optional.  Fehlt sie,
so gibt AS eine aus dem Symbolnamen konstruierte Meldung aus.


	3.8.6.  RELAXED (alle Prozessoren)
	- - - - - - - -

DefaultmÑ·ig ist einer Prozessorfamilie eine bestimmte Schreibweise
von Integer-Konstanten zugeordnet (die i.a. der Herstellervorgabe
entspricht, solange der nicht eine allzu abgefahrene Syntax be-
nutzt...).  Nun hat aber jeder seine persînlichen Vorlieben fÅr die
eine oder andere Schreibweise und kann gut damit leben, da· sich sei-
ne Programme nicht mehr mit dem Standard-Assembler Åbersetzen lassen.
Setzt man ein

      RELAXED ON

an den Programmanfang, so kann man fortan alle Schreibweisen beliebig
gemischt und durcheinander verwenden; bei jedem Ausdruck versucht AS
automatisch zu ermitteln, welche Schreibweise verwendet wurde.  Da·
diese Automatik nicht immer das Ergebnis liefert, das man sich vorge-
stellt hat, ist auch der Grund, weshalb diese Option explizit einge-
schaltet werden mu· (und man sich davor hÅten sollte, sie einfach in
einem existierenden Programm dazuzusetzen): Ist nicht durch vor- oder
nachgestellte Zeichen zu erkennen, da· es sich um Intel- oder Motoro-
la-Konstanten handelt, wird im C-Modus gearbeitet.  Eventuell voran-
gestellte, eigentlich ÅberflÅssige Nullen haben in diesem Modus durch-
aus eine Bedeutung:

      move.b  #08,d0

Diese Konstante wÅrde als Oktalkonstante verstanden werden, und weil
Oktalzahlen nur Ziffern von 0..7 enthalten kînnen, fÅhrt das zu einem
Fehler.  Dabei hÑtte man in diesem Fall noch GlÅck gehabt, bei der
Zahl 077 z.B. hÑtte man ohne Meldung Probleme bekommen.  Ohne
RELAXED-Modus wÑre in beiden FÑllen klar gewesen, da· es sich um dezi-
male Konstanten handelt.

Die momentane Einstellung kann aus dem gleichnamigen Symbol ausgelesen
werden.

	3.8.7.  END ( alle Prozessoren )
	- - - - - -

END kennzeichnet das Ende des Assemblerprogrammes.  Danach noch in
der Quelldatei stehende Zeilen werden ignoriert.  WICHTIG: END
darf zwar aus einem Makro heraus aufgerufen werden, der Stapel der
bedingten Assemblierung wird aber nicht automatisch abgerÑumt.  Das
folgende Konstrukt fÅhrt daher zu einer Fehlermeldung:

	IF KeineLustMehr
	 END
	ENDIF

Optional darf END auch einen Integer-Ausdruck als Argument haben, der
den Startpunkt des Programmes vermerkt.  Dieser wird von AS in einem
speziellen Record der Datei gespeichert und kann z.B. von P2HEX wei-
terverarbeitet werden.

END war eigentlich schon immer in AS definiert, nur war es bei
frÅheren Versionen von AS aus KompatibilitÑt zu anderen Assemblern
vorhanden und hatte keine Wirkung.


	4. Prozessorspezifische Hinweise
	================================

Ich habe mich bemÅht, die einzelnen Codegeneratoren mîglichst
kompatibel zu den Originalassemblern zu halten, jedoch nur soweit,
wie es keinen unvertretbaren Mehraufwand bedeutete.  Wichtige Unter-
schiede, Details und Fallstricke habe ich im folgenden aufgelistet.

	4.1. 6811
	---------

"Wo gibt es denn das zu kaufen, den HC11 in NMOS?", fragt jetzt
vielleicht der eine oder andere.  Gibt es natÅrlich nicht, aber
ein H lÑ·t sich nun einmal nicht in einer Hexzahl darstellen,
und dann habe ich die Buchstaben gleich ganz weggelassen...

Ab und zu ist man gezwungen, seine Meinung zu revidieren.  Vor
einigen Versionen hatte ich an dieser Stelle noch behauptet, ich
kînne es im Parser von AS nicht realisieren, da· man die Argumente
von BSET/BCLR bzw. BRSET/BRCLR auch mit Leerzeichen trennen kann.
Offensichtlich kann selbiger aber mehr, als ich vermutet habe...nach
der soundsovielten Anfrage habe ich mich noch einmal drangesetzt,
und jetzt scheint es zu laufen.  Man darf sowohl Leerzeichen als
auch Kommas verwenden, aber nicht in allen Varianten, um es nicht
uneindeutig zu machen:  Es gibt zu jeder Befehlsvariante zwei Mîg-
lichkeiten; eine, die nur Kommas verwendet, sowie eine, wie sie
von Motorola wohl definiert wurde (leider sind die DatenbÅcher
nicht immer so gut wie die zugehîrige Hardware...):

   Bxxx  abs8 #mask         entspricht    Bxxx  abs8,#mask
   Bxxx  disp8,X #mask      entspricht    Bxxx  disp8,X,#mask
   BRxxx abs8 #mask adr     entspricht    BRxxx abs8,#mask,adr
   BRxxx disp8,X #mask adr  entspricht    BRxxx disp8,X,#mask,adr

Dabei steht xxx entweder fÅr SET oder CLR und #mask fÅr die zu
verwendende Bitmaske; der Lattenzaun ist dabei optional.
Anstelle des X-Registers darf natÅrlich auch Y verwendet werden.


	4.2. PowerPC
	------------

Sicher hat es ein bi·chen den Anflug einer Schnapsidee, einen Pro-
zessor, der eher fÅr den Einsatz in Workstations konzipiert wurde,
in AS einzubauen, der sich ja eher an Programmierer von Einplatinen-
computern wendet.  Aber was heute noch das Hei·este vom Hei·en ist,
ist es morgen schon nicht mehr, und sowohl der Z80 als auch der
8088 haben ja inzwischen die Mutation von der Personal Computer-CPU
zum sog. "Mikrocontroller" vollzogen.  Mit dem Erscheinen von
MPC505 und PPC403 hat sich die Vermutung dann auch bestÑtigt, da·
IBM und Motorola diese Prozessorserie auf allen Ebenen durchdrÅcken
wollen.

Die UnterstÅtzung ist momentan noch nicht vollstÑndig: es fehlen
sowohl ein Satz an Pseudobefehlen zur Datenablage sowie die etwas
ungewîhnlicheren, in [Mot601] genannten RS6000-Befehle (die aber
hoffentlich keiner vermi·t...).  Das wird aber nachgeholt, sobald
Informationen verfÅgbar sind!


	4.3. DSP56000
	-------------

Motorola, was ist nur in Dich gefahren!  Wer bei Dir ist nur auf das
schmale Brett gekommen, die einzelnen parallelen Datentransfers
ausgerechnet durch Leerzeichen zu trennen!  Wer immer nun seine Codes
etwas Åbersichtlicher formatieren will, z.B. so:

    move    x:var9 ,r0
    move    y:var10,r3   ,

der ist gekniffen, weil das Leerzeichen als Trennung paralleler Daten-
transfers erkannt wird!

Sei's drum; Motorola hat es so definiert, und ich kann es nicht
Ñndern.  Als Trennung der Operationen sind statt Leerzeichen auch Ta-
bulatoren zugelassen, und die einzelnen Teile sind ja wieder ganz
normal mit Kommas getrennt.

In [Mot56] steht, da· bei den Befehlen MOVEC, MOVEM, ANDI und ORI auch
die allgemeineren Mnemonics MOVE, AND und OR verwendet werden kînnen.
Bei AS geht das (noch) nicht.


        4.4. H8
        -------

Bei der Assemblersyntax dieser Prozessoren hat Hitachi reichlich
bei Motorola abgekupfert (was so verkehrt ja nun auch nicht war...),
nur leider wollte die Firma unbedingt ihr eigenes Format fÅr Hexa-
dezimalzahlen einfÅhren, und dazu noch eines, das Ñhnlich wie bei
Microchip Hochkommas verwendet.  Das konnte (und wollte) ich bei AS
nicht nachvollziehen, bei dem Hochkommas zur Einrahmung von
ASCII-Sequenzen benutzt werden.  Anstelle dessen werden Zahlen in der
Åblichen Motorola-Syntax geschrieben, d.h. mit einem Dollarzeichen.


	4.5. SH7000/7600
	----------------

Leider hat Hitachi auch hier wieder das Extrawurst-Format fÅr Hexa-
dezimalzahlen verwendet, und wieder habe ich in AS das nicht nach-
vollzogen...

Bei der Verwendung von Literalen und dem LTORG-Befehl sind einige
Details zu beachten, wenn man nicht auf einmal mit eigenartigen
Fehlermeldungen konfrontiert werden will:

Literale existieren, weil der Prozessor nicht in der Lage ist,
Konstanten au·erhalb des Bereiches von -128 bis 127 mit
immediate-Adressierung zu laden.  AS (und der Hitachi-Assembler)
verstecken diese UnzulÑnglichkeit, indem sie automatisch entspre-
chende Konstanten im Speicher ablegen, die dann mittels PC-rela-
tiver Adressierung angesprochen werden.  Die Frage, die sich nun
erhebt, ist die, wo diese Konstanten im Speicher abgelegt werden
sollen.  AS legt sie nicht sofort ab, sondern sammelt sie so lange
auf, bis im Programm eine LTORG-Anweisung auftritt.  Dort werden
alle Konstanten abgelegt, wobei deren Adressen mit ganz normalen
Labels versehen werden, die man auch in der Symboltabelle sehen
kann.  Ein Label hat die Form

   LITERAL_s_xxxx_n   .

Dabei reprÑsentiert s den Typ des Literals.  Unterschieden werden
Literale, die 16-Bit-Konstanten (s=W), 32-Bit-Konstanten (s=L)
oder VorwÑrtsreferenzen, bei denen AS die Operandengrî·e nicht
im voraus erkennen kann (s=F), enthalten.  FÅr W oder L bedeutet
xxxx den hexadezimal geschriebenen Wert der Konstante, bei VorwÑrts-
referenzen, bei denen man den Literalwert ja noch nicht kennt,
bezeichnet xxxx eine einfache Durchnumerierung. n kennzeichnet das
wievielte Auftreten dieses Literals in dieser Sektion.  Literale
machen ganz normal die Lokalisierung durch Sektionen mit, es ist
daher zwingend erforderlich, in einer Sektion entstandene Literale
mit LTORG auch dort abzulegen!

Die Durchnumerierung mit n ist erforderlich, weil ein Literal in
einer Sektion mehrfach auftreten kann.  Dies ist einmal bedingt da-
durch, da· die PC-relative Adressierung nur positive Displacements
erlaubt, einmal mit LTORG abgelegte Literale also im folgenden
Code nicht mitbenutzt werden kînnen, andererseits auch, weil die
Reichweite der Displacements beschrÑnkt ist (512 bzw. 1024 Byte).
Ein automatisches LTORG am Ende des Programmes oder beim Umschalten
zu einer anderen CPU erfolgt nicht; findet AS in einer solchen Si-
tuation noch abzulegende Literale, so wird eine Fehlermeldung aus-
gegeben.

Da bei der PC-relativen Adressierung der zur Adressierung heran-
gezogene PC-Wert der Instruktionsadresse+4 entspricht, ist es nicht
mîglich, ein Literal zu benutzen, welches direkt hinter dem betrof-
fenen Befehl abgelegt wird, also z.B. so:

        mov     #$1234,r6
        ltorg

Da der Prozessor dann aber sowieso versuchen wÅrde, Daten als Code
auszufÅhren, sollte diese Situation in realen Programmen nicht auf-
treten.  Wesentlich realer ist aber ein anderer Fallstrick:  Wird
hinter einem verzîgerten Sprung PC-relativ zugegriffen, so ist der
ProgrammzÑhler bereits auf die Sprungzieladresse gesetzt, und das
Displacement wird relativ zum Sprungziel+2 berechnet.  Im folgenden
Beispiel kann daher das Literal nicht erreicht werden:

        bra     Target
        mov	#$12345678,r4        ; wird noch ausgefÅhrt
        .
        .
        ltorg                        ; hier liegt das Literal
        .
        .
Target: mov     r4,r7                ; hier geht es weiter

Da Target+2 hinter dem Literal liegt, wÅrde sich ein negatives
Displacement ergeben.  Besonders haarig wird es, wenn mit den
Befehlen JMP, JSR, BRAF oder BSRF verzweigt wird:  Da AS die
Zieladresse hier nicht ermitteln kann (sie ergibt sich erst zur
Laufzeit aus dem Registerinhalt), nimmt AS hier eine Adresse an,
die nach Mîglichkeit nie pa·t.

Es ist nicht direkt mîglich, aus der Zahl und Grî·e der Literale
auf den belegten Speicher zu schlie·en.  U.u. mu· AS ein FÅllwort
einbauen, um einen Langwort-Wert auf eine durch 4 teilbare Adresse
auszurichten, andererseits kann er mîglicherweise Teile eines
32-bittigen Literals fÅr 16-Bit-Literale mitbenutzten.  Mehrfach
auftretende Literale erzeugen natÅrlich nur einen Eintrag.  Solche
Optimierungen werden fÅr VorwÑrtsreferenzen allerdings ganz unter-
drÅckt, da AS den Wert dieser Literale noch nicht kennt.

Da Literale die PC-relative Adressierung ausnutzten, die nur beim
MOV-Befehl erlaubt sind, beschrÑnken sich Literale ebenfalls auf
die Verwendung in MOV.  Etwas trickreich ist hier die Art und Weise,
in der AS die Operandengrî·e auswertet.  Eine Angabe von Byte oder
Wort bedeutet, da· AS einen mîglichst kurzen MOV-Befehl erzeugt,
der den angegebenen Wert in den unteren 8 oder 16 Bit des Registers
erzeugt, d.h. die oberen 24 oder 16 Bit werden als don't care
behandelt.  Gibt man dagegen Langwort oder gar nichts an, so sagt
dies aus, da· das komplette 32-Bit-Register den angegebenen Wert
enthalten soll.  Das hat z.B. den Effekt, da· in folgendem Beispiel

        mov.b   #$c0,r0
        mov.w   #$c0,r0
        mov.l   #$c0,r0

Der erste Befehl echte immediate-Adressierung erzeugt, der zweite und
dritte jedoch ein Wort-Literal benutzen: Da das Bit 7 in der Zahl ge-
setzt ist, erzeugt der Byte-Befehl effektiv $FFFFFFC0 im Register,
was nach der Konvention nicht das wÑre, was man im zweiten und
dritten Fall haben mîchte.  Im dritten Fall reicht auch ein Wort-Li-
teral, weil das gelîschte Bit 15 des Operanden vom Prozessor in Bit
16..31 fortgesetzt wird.

Wie man sieht, ist dieses ganze Literal-Konzept reichlich kom-
pliziert; einfacher ging's aber wirklich nicht.  Es liegt leider in
der Natur der Sache, da· man manchmal Fehlermeldungen Åber nicht
gefundene Literale bekommt, die eigentlich logisch nicht auftreten
kînnten, weil AS die Literale ja komplett in eigener Regie verwaltet.
Treten aber bei der Assemblierung Fehler erst im zweiten Pass auf, so
verschieben sich z.B. hinter der Fehlerstelle liegende Labels gegen-
Åber dem ersten Pass, weil AS fÅr die jetzt als fehlerhft erkannten
Befehle keinen Code mehr erzeugt.  Da aber Literalnamen u.a. aus
den Werten von Symbolen erzeugt werden, werden als Folgefehler davon
eventuell andere Literalnamen nachgefragt, als im ersten Pass abgelegt
wurden und AS beschwert sich Åber nicht gefundene Symbole...sollten
also neben anderen Fehlern solche Literal-Fehler auftreten, beseitigen
Sie erst die anderen Fehler, bevor Sie mich und alle Literale ver-
fluchen...

Wer aus der Motorola-Ecke kommt und PC-relative Adressierung explizit
benutzen will (z.B. um Variablen lageunabhÑngig zu erreichen), sollte
wissen, da· beim Ausschreiben der Adressierung nach Programmierhand-
buch, also z.B. so:

        mov.l   @(Var,PC),r8

KEINE implizite Umrechnung der Adresse auf ein Displacement erfolgt,
d.h. der Operand wird so eingesetzt, wie er ist (und wÅrde in diesen
Beispiel wohl mit hoher Wahrscheinlichkeit eine Fehlermeldung hervor-
rufen...).  Will man beim SH7x00 PC-relativ adressieren, so tut man
das einfach mit "absoluter" Adressierung, die auf Maschinenebene ja
gar nicht existiert:

        mov.l   Var,r8

Hier wird das Displacement korrekt berechnet (es gelten natÅrlich die
gleichen EinschrÑnkungen fÅr das Displacement wie bei Literalen).


	4.6. MELPS-4500
	---------------

Der Programmspeicher dieser Mikrokontroller ist in Seiten zu 128
Worten eingeteilt.  Diese Einteilung existiert eigentlich nur deswe-
gen, weil es Sprungbefehle gibt, deren Ziel innerhalb der gleichen
Seite liegen darf, und andererseits "lange" Exemplare, die den ganzen
Adre·bereich erreichen kînnen.  Die Standard-Syntax von Mitsubishi
verlangt eigentlich, da· Seite und Offset als getrennte Argument ge-
schrieben werden mÅssen.  Da das aber reichlich unpraktisch ist (an-
sonsten hat man als Programmierer keine Veranlassung, sich um Seiten
zu kÅmmern, mit der Ausnahme von indirekten SprÅngen), erlaubt es AS
auch wahlweise, die Zieladresse linear zu schreiben, also z.B.

      bl     $1234

anstelle

      bl     $24,$34 .


	4.7. MELPS-740
	--------------

Die Mikrokontroller dieser Reihe haben ein sehr nettes, verstecktes
Feature: Setzt man mit dem Befehl SET das Bit 5 des Statusregisters,
so wird bei allen arithmetischen Operationen (und Ladebefehlen) der
Akkumulator durch die durch das X-Register adressierte Speicherzelle
ersetzt.  Dieses Feature syntaxmÑ·ig sauber zu integrieren, ist
bisher nicht geschehen, d.h. es kann bisher nur im "Handbetrieb"
(SET...Befehle mit Akkuadressierung...CLT) genutzt werden.

Nicht alle MELPS-740-Prozessoren implementieren alle Befehle.  An
dieser Stelle mu· der Programmierer aufpassen, da· er nur die Befehle
benutzt, die auch wirklich vorhanden sind, da AS die Prozessoren
dieser Familie nicht nÑher unterscheidet.  Die Besonderheiten der
Special-Page-Adressierung werden bei der ErklÑrung von ASSUME nÑher
erlÑutert.


	4.8. MELPS-7700/65816
	---------------------

Offensichtlich haben diese beiden Prozessorfamilien ausgehend vom
6502 (Åber ihre 8-bittigen VorgÑnger) etwas disjunkte Entwicklungs-
wege hinter sich.  Kurz aufgelistet, ergeben sich folgende Unter-
schiede:

- Der 65816 hat keinen B-Akkumulator.
- Beim 65816 fehlen Multiplikations- sowie Divisionsbefehle.
- Die Befehle SEB, CLB, BBC, BBS, CLM, SEM, PSH, PUL und LDM fehlen
  beim 65816.  An deren Stelle in der Code-Tabelle finden sich TSB,
  TRB, BIT, CLD, SED, XBA, XCE und STZ.

Identische Funktion, jedoch andere Namen haben folgende Befehle:

   65816     MELPS-7700       65816    MELPS-7700

    REP        CLP             PHK        PHG
    TCS        TAS             TSC        TSA
    TCD        TAD             TDC        TDA
    PHB        PHT             PLB        PLT
    WAI        WIT

Besonders tÅckisch sind die Befehle PHB, PLB und TSB: diese Befehle
haben jeweils eine vîllig andere Funktion und Kodierung!

Leider tun diese Prozessoren mit ihrem Speicher etwas, was fÅr mich
auf der nach oben offenen PerversitÑtsskala noch vor der Intel-
mÑ·igen Segmentierung rangiert: sie banken ihn!  Nunja, dies ist
wohl der Preis fÅr die 6502-AufwÑrtskompatibilitÑt; wie dem auch sei,
damit AS den gewÅnschten Code erzeugen kann, mu· man ihn Åber den
ASSUME-Befehl Åber den Inhalt einiger Register in Kenntnis setzen:

Das M-Flag bestimmt, ob die Akkumulatoren A und B 8 Bit (1) oder 16
Bit (0) breit sein sollen.  Analog entscheidet das Flag X Åber die
Breite der Indexregister X und Y.  AS benîtigt die Information Åber
die Registerbreite bei unmittelbarer Adressierung (#<Konstante>),
ob das Argument 8 oder 16 Bit breit sein soll.

Der Speicher ist in 256 BÑnke zu 64 KByte geteilt.  Da alle Register
im Prozessor nur maximal 16 Bit breit sind, kommen die obersten 8
Adre·bits aus 2 speziellen Bank-Registern: DT liefert die oberen 8
Bits bei Datenzugriffen, PG erweitert den 16-bittigen ProgrammzÑhler
auf 24 Bit.  Die vom 6502 her bekannte "Zero-Page" ist mittels des
16 Bit breiten Registers DPR frei innerhalb der ersten Bank ver-
schiebbar.  Trifft AS nun im Code auf eine Adresse (egal ob in einem
absoluten, indizierten oder indirekten Ausdruck), so versucht er der
Reihe nach folgende Adressierungsvarianten:

  1. Liegt die Adresse im Bereich von DPR..DPR+$ff?  Falls ja,
     Verwendung von direkter Adressierung mit 8-Bit-Adresse.
  2. Liegt die Adresse innerhalb der durch DT (bzw. PG fÅr Sprungbe-
     fehle) festgelegten Seite?  Falls ja, Verwendung von absoluter
     Adressierung mit 16-Bit-Adresse.
  3. Falls nichts anderes hilft, Verwendung von langer Adressierung
     mit 24-Bit-Adresse.

Aus dieser AufzÑhlung folgt, da· das Wissen Åber die momentanen Werte
von DT,PG und DPR fÅr die Funktion von AS essentiell ist; sind die
Angaben fehlerhaft, adressiert das Programm "in die WÅste".  Diese
AufzÑhlung geht Åbrigens davon aus, da· alle drei Adre·lÑngen ver-
fÅgbar sind; sollte dies einmal nicht der Fall sein, so wird die
Entscheidungskette entsprechen kÅrzer.

Um die Portierung von 6502-Programmen zu erleichtern, verwendet AS
fÅr Hexadezimalkonstanten die Motorola-Syntax und nicht die von
Mitsubishi Åbrigens auch fÅr die 740er favorisierte Intel/IEEE-
Schreibweise.  Ich halte erstere auch fÅr die bessere Schreibweise,
und die Entwickler des 65816 werden dies vermutlich Ñhnlich gesehen
haben.  Ein fÅr die Portierung Ñhnlich wichtiges Detail ist, da· der
Akkumulator A als Ziel von Operationen auch weggelassen werden darf,
anstelle von LDA A,#0 darf also z.B. auch einfach LDA #0 geschrieben
werden.

Ein echtes Bonbon in dem Befehlssatz sind dagegen die Blocktransfer-
befehle MVN und MVP.  Etwas eigenartig ist nur die Adre·angabe: Bit
0..15 im Indexregister, Bit 16..23 im Befehl.  Bei AS gibt  man als
Argument fÅr beide Speicherblîcke einfach die vollen Adressen an, AS
fischt sich dann die passenden Bits automatisch heraus.  Dies ist ein
feiner, aber wichtiger Unterschied zum Mitsubishi-Assembler, bei dem
man die oberen 8 Bit selber herausziehen mu·.  Richtig bequem wird es
aber erst mit einem Makro im folgendem Stil:

mvpos   macro   src,dest,len
	if      MomCPU=7700h
	 lda    #len
	elseif
	 lda    #(len-1)
	endif
	ldx     #(src&$ffff)
	ldy     #(dest&$ffff)
	mvp     dest,src
	endm

Vorsicht, Falle: Steht im Akkumulator die Zahl n, so transferiert
der Mitsubishi n Bytes, der 65816 jedoch n+1 Bytes!

Sehr nett sind auch die Befehle PSH und PUL, mit deren Hilfe es
mîglich ist, mit einem Befehl einen frei wÑhlbaren Satz von Registern
auf dem Stack zu sichern oder von ihm zu laden.  Nach dem Mitsubishi-
Datenbuch[Mit16] mu· die Angabe der Bitmasken immediate erfolgen, der
Programmierer soll also entweder alle Register<-->Bitstellen-Zuord-
nungen im Kopf behalten oder sich passende Symbole definieren. Hier
habe ich die Syntax eigenmÑchtig erweitert, um die Sache etwas ange-
nehmer zu machen: Es darf eine Liste angegeben werden, die sowohl
immediate-AusdrÅcke als auch Registernamen enthalten darf.  Damit
sind z.B. die Anweisungen

	psh     #$0f

und

	psh     a,b,#$0c

und

	psh     a,b,x,y

Ñquivalent.  Da die immediate-Version weiterhin erlaubt ist, bleibt
AS hier "aufwÑrtskompatibel" zu den Mitsubishi-Assemblern.

Nicht ganz habe ich beim Mitsubishi-Assembler die Behandlung des PER-
Befehles verstanden: Mit diesem Befehl kann man eine 16-Bit-Variable
auf den Stack legen, deren Adresse relativ zum ProgrammzÑhler angege-
ben wird.  Es ist aus der Sicht des Programmierers also eine absolute
Adressierung einer Speicherzelle.  Nichtsdestotrotz verlangt Mitsu-
bishi eine immediate-Adressierung, und das Argument wird so in den
Code eingesetzt, wie es im Quelltext steht.  Die Differenz mu· man sel-
ber ausrechnen, was mit der EinfÅhrung von symbolischen Assemblern ja
abgeschafft werden sollte...da ich aber auch ein bi·chen "kompatibel"
denken mu·, enthÑlt AS eine Kompromi·lîsung: WÑhlt man immediate-
Adressierung (also mit Gartenzaun), so verhÑlt sich AS wie das Origi-
nal von Mitsubishi.  LÑ·t man ihn jedoch weg, so berechnet AS die
Differenz vom Argument zum momentanen ProgrammzÑhler und setzt diese
ein.

éhnlich sieht es beim PEI-Befehl aus, der den Inhalt einer 16-Bit-
Variablen auf der Zeropage auf den Stack legt:  Obwohl der Operand
eine Adresse ist, wird wieder immediate-Adressierung verlangt.  Hier
lÑ·t AS schlicht beide Versionen zu (d.h. mit oder ohne Gartenzaun).


	4.9. M16
        --------

Die M16-Familie ist eine Familie Ñu·erst komplexer CISC-Prozessoren
mit einem entsprechend komplizierten Befehlssatz.  Zu den Eigenschaf-
ten dieses Befehlssatzes gehîrt es unter anderem, da· bei Operationen
mit zwei Operanden beide Operanden verschiedene LÑngen haben dÅrfen.
Die bei Motorola Åbliche und von Mitsubishi Åbernommene Methode, die
Operandengrî·e als Attribut an den Befehl anzuhÑngen, mu·te daher er-
weitert werden: Es ist erlaubt, auch an die Operanden selber Attri-
bute anzuhÑngen.  So wird im folgenden Beispiel

        mov     r0.b,r6.w

Register 0 8-bittig gelesen, auf 32 Bit vorzeichenerweitert und das
Ergebnis in Register 6 kopiert.  Da man in 9 von 10 FÑllen aber von
diesen Mîglichkeiten doch keinen Gebrauch macht, kann man weiterhin
die Operandengrî·e an den Befehl selber schreiben, z.B. so:


        mov.w   r0,r6

Beide Varianten dÅrfen auch gemischt verwendet werden, eine Grî·en-
angabe am Operanden Åbersteuert dann den "Default" am Befehl.  Eine
Ausnahme stellen Befehle mit zwei Operanden dar.   Bei diesen ist
der Default fÅr den Quelloperanden die Grî·e des Zieloperanden. In
folgendem Beispiel

        mov.h   r0,r6.w

wird also auf Register 0 32-bittig zugegriffen, die Grî·enangabe
am Befehl wird Åberhaupt nicht mehr benutzt.  Finden sich Åberhaupt
keine Angaben zur Operandengrî·e, so wird Wort(w) verwendet.  Merke:
im Gegensatz zu den 68000ern bedeutet dies 32 und nicht 16 Bit!

Reichlich kompliziert sind auch die verketteten Adressierungsmodi;
dadurch, da· AS die Verteilung auf Kettenelemente automatisch vor-
nimmt, bleibt die Sache aber einigerma·en Åbersichtlich.  Die einzige
Eingriffsmîglichkeit, die bei AS gegeben ist (der Originalassembler
von Mitsubishi/Green Hills kann da noch etwas mehr), ist die expli-
zite Festlegung von Displacement-LÑngen mittels der AnhÑngsel :4,
:16 und :32.


	4.10. MCS-48
	------------

Der maximale Adre·raum dieser Prozessoren betrÑgt 4 KByte.  Dieser
Raum ist jedoch nicht linear organisiert (wie kînnte das bei Intel
auch anders sein...), sondern in 2 BÑnke zu 2 KByte geteilt.  Ein
Wechsel zwischen diesen beiden BÑnken ist nur durch die Befehle CALL
und JMP erlaubt, indem vor dem Sprung das hîchste Adre·bit mit den
Befehlen

  SEL MB0  bzw.  SEL MB1

vorgegeben wird.  Um den Wechsel zwischen den BÑnken zu vereinfachen,
ist eine Automatik in den Befehlen JMP und CALL eingebaut, die einen
dieser beiden Befehle einfÅgt, falls die Adresse des Sprungbefehles
und das Sprungziel in unterschiedlichen BÑnken liegen.  Die explizite
Benutzung der SEL-Befehle sollte daher nicht notwendig sein (obwohl
sie mîglich ist) und kann die Automatik auch durcheinanderbringen,
wie in dem folgenden Beispiel:

 000: SEL MB1
      JMP 200h

AS nimmt an, da· das MB-Flag auf 0 steht und fÅgt keinen SEL MB0-Be-
fehl vor dem Sprung ein, mit der Folge, da· der Prozessor zur Adresse
A00h springt.

Weiterhin ist zu beachten, da· ein Sprungbefehl unter UmstÑnden nicht
2, sondern 3 Bytes lang ist und der Code entsprechend lÑnger wird.


	4.11. MCS-51
	------------

Dem Assembler liegt eine Datei STDDEF51.INC bei, in der alle Bits und
SFRs der Prozessoren 8051, 8052 und 80515 verzeichnet sind.  Je nach
Einstellung des Prozessortyps mit dem CPU-Befehl wird dabei die kor-
rekte Untermenge eingebunden, die richtige Reihenfolge fÅr den Anfang
eines Programmes ist daher

	CPU     <Prozessortyp>
	INCLUDE stddef51.inc   ,

sonst fÅhren die MCS-51-Pseudobefehle in der Include-Datei zu
Fehlermeldungen.

Da der 8051 keinen Befehl kennt, um die Register 0..7 auf den Stack
zu legen, mu· mit deren absoluten Adressen gearbeitet werden.  Diese
hÑngen aber von der momentan aktiven Registerbank ab.  Um diesem Mi·-
stand etwas abzuhelfen, ist in der Include-Datei das Makro USING de-
finiert, dem als Parameter die Symbole Bank0..Bank3 gegeben werden
kînnen.  Das Makro belegt daraufhin die Symbole AR0..AR7 mit den
passenden absoluten Adressen der Register.  Dieses Makro sollte nach
jeder Bankumschaltung benutzt werden.  Es erzeugt selber keinen Code
zur Umschaltung!

Das Makro fÅhrt in der Variablen RegUsage gleichzeitig Buch Åber
alle jemals benutzten RegisterbÑnke; Bit 0 entspricht Bank 0, Bit 1
der Bank 1 usw. .  Der Inhalt kann am Ende der Quelldatei z.B. mit
folgendem CodestÅck ausgegeben werden:

	irp             bank,bank0,bank1,bank2,bank3
	 if             (RegUsage&(2^bank))<>0
	  message       "Bank \{BANK} benutzt"
	 endif
	endm

Mit der Mehrpass-FÑhigkeit ab Version 1.38 wurde es mîglich, zusÑtz-
lich die Befehle JMP und CALL einzufÅhren.  Bei der Kodierung von
SprÅngen mit diesen Befehlen wÑhlt AS je nach Adre·lage automatisch
die optimale Variante, d.h. SJMP/AJMP/LJMP fÅr JMP und ACALL/LCALL
fÅr CALL.  Es ist natÅrlich weiterhin mîglich, die Varianten direkt
zu verwenden, um eine bestimmte Kodierung zu erzwingen.


	4.12. MCS-251
        -------------

Intel hat sich beim 80C251 ja bemÅht, den öbergang fÅr den Program-
mierer auf die neue Familie so weich wie mîglich zu gestalten, was
darin gipfelt, da· alte Anwendungen ohne NeuÅbersetzung auf dem neuen
Prozessor ablaufen kînnen.  Sobald man jedoch den erweiterten Be-
fehlssatz der 80C251 nutzen will, gilt es, einige Details zu beachten,
die sich als versteckte Fu·angeln auftun.

An vorderster Stelle steht dabei die Tatsache, da· der 80C251 keinen
getrennten Bitadre·raum mehr hat.  Es sind nunmehr alle SFRs unab-
hÑngig von ihrer Adre·lage sowie die ersten 128 Speicherstellen des
internen RAMs bitadressierbar.  Mîglich wird dies dadurch, da· die
Bitadressierung nicht mehr Åber einen zusÑtzlichen virtuellen Adre·-
raum, der andere Adre·rÑume Åberdeckt, erfolgt, sondern so wie bei
anderen Prozessoren auch durch eine zweidimensionale Adressierung, die
aus der Speicherstelle, die das Bit beinhaltet sowie der Bitstelle
im Byte besteht.  Dies bedeutet zum einen, da· bei einer Bitangabe
wie z.B. PSW.7 AS die Zerlegung der Teile links und rechts vom Punkt
selber vornimmt.  Es ist also nicht mehr nîtig, mittels eines SFRB-
Befehls wie noch beim 8051 explizit 8 Bitsymbole zu erzeugen.  Dies
bedeutet zum anderen, da· es den SFRB-Befehl Åberhaupt nicht mehr
gibt.  Wird er in zu portierenden 8051-Programmen benutzt, kann er
durch einen einfachen SFR-Befehl ersetzt werden.

Weiterhin hat Intel in den unterschiedlichen Adre·rÑumen des 8051
gehîrig aufgerÑumt: Der Bereich des internen RAMs (DATA bzw. IDATA),
der XDATA-Bereich und er bisherige CODE-Bereich wurden in einem
einzigen, 16 MByte gro·en CODE-Bereich vereinigt.  Das interne RAM
beginnt bei Adresse 0, das interne ROM beginnt bei Adresse ff0000h,
dorthin mu· also auch der Code mittels ORG hinverlagert werden.
Ausgelagert wurden dagegen die SFRs in einen eigenen Adre·raum (der
bei AS als IO-Segment definiert ist).  In diesem neuen Adre·raum
haben sie aber die gleichen Adressen wie beim 8051.  Der SFR-Befehl
kennt diesen Unterschied und legt mit ihm erzeugte Symbole je nach
Zielprozessor automatisch ins DATA- bzw. IO-Segment.  Da es keinen
Bit-Adre·raum mehr gibt, funktioniert der BIT-Befehl vîllig anders:
anstelle einer linearen Adresse von 0 bis 255 beinhalten Bit-Symbole
jetzt in Bit 0..7 die Adresse, in Bit 24..26 die Bitstelle.  Damit ist
es jetzt leider nicht mehr so einfach mîglich, Felder von Flags mit
symbolischen Namen anzulegen: Wo man beim 8051 noch z.B.

        segment bitdata

bit1	db	?
bit2	db	?

oder

defbit	macro	name
name	bit	cnt
cnt	set	cnt+1
	endm

schreiben konnte, hilft jetzt nur noch die zweite Variante weiter, z.B.
so:

adr	set	20h	; Startadresse Flags im internen RAM
bpos	set	0

defbit  macro   name
name    bit     adr.bpos
bpos    set     bpos+1
        if      bpos=8
bpos     set     0
adr      set     adr+1
        endif
        endm

Ein weiteres, kleines Detail: Da Intel als Kennzeichnung fÅr den Carry
nun CY statt C bevorzugt, sollte man ein eventuell benutztes Symbol
umbenennen.  AS versteht aber auch weiterhin die alte Variante in den
Befehlen CLR, CPL, SETB, MOV, ANL, und ORL.  Gleiches gilt sinngemÑ·
fÅr die dazugekommenen Register R8..R15, WR0..WR30, DR0..DR28, DR56,
DR60, DPX und SPX.

Intel mîchte es gerne, da· man absolute Adressen in der Form XX:YYYY
schreibt, wobei XX eine 64K-Bank im Adre·raum angibt bzw. mit einem
S Adressen im IO-Raum kennzeichnet.  Wie man sich schon denken kann,
halte ich davon nicht allzu viel, weshalb man an allen Stellen Adres-
sen genauso gut linear angeben kann; lediglich um das S fÅr die Kenn-
zeichnung von I/O-Adressen kommt man nicht herum, z.B. hier:

Carry   bit   s:0d0h.7

Ohne den PrÑfix wÅrde AS die absolute Adresse in das Code-Segment
legen, und dort sind ja nur die ersten 128 Bit bitadressierbar...

Wie auch schon beim 8051 gibt es die generischen Befehle JMP und
CALL, die je nach Adre·lage automatisch die kÅrzeste Variante
einsetzen.  WÑhrend JMP aber die Variante mit 24 Bit mitberÅck-
sichtigt, tut CALL dies aus gutem Grund nicht: Der ECALL-Befehl legt
nÑmlich im Gegensatz zu ACALL und LCALL 3 Bytes auf den Stack, und
man hÑtte sonst einen CALL-Befehl, bei dem man nicht mehr genau
wei·, was er tut.  Bei JMP tritt diese Problem nicht auf.

Aus einer Sache bin ich nicht ganz schlau geworden: Der 80251 kann
auch immediate-Operanden auf den Stack legen, und zwar sowohl ein-
zelne Bytes als auch ganze Wîrter.  FÅr beide Varianten ist aber
der gleiche Befehl PUSH vorgesehen - und woher soll bitte ein Assem-
bler bei einer Anweisung wie

        push #10

wissen, ob ein Byte oder ein Wort mit dem Wert 10 auf den Stack gelegt
werden soll?  Daher gilt im Augenblick die Regelung, da· PUSH grund-
sÑtzlich ein Byte ablegt; wer ein Wort ablegen will, schreibt einfach
PUSHW anstelle PUSH.

Noch ein gutgemeinter Ratschlag: Wer den erweiterten Befehlssatz des
80C251 nutzt, sollte den Prozessor auch tunlichst im Source-Modus
betreiben, sonst werden alle neuen Anweisungen ein Byte lÑnger!  Um
die originÑren 8051-Anweisungem, die dafÅr im Source-Modus lÑnger
werden, ist es nicht besonders schade: Sie werden entweder von AS
automatisch durch neue, leistungsfÑhigere ersetzt oder sind be-
treffen veraltete Adressierungsarten (indirekte Adressierung mit
8-Bit-Registern).


	4.13. 8086..V35
	---------------

Eigentlich hatte ich mir geschworen, die Segmentseuche der 8086er
aus diesem Assembler herauszuhalten.  Da aber nun eine Nachfrage
kam und Studenten flexiblere Menschen als die Entwickler dieses
Prozessors sind, findet sich ab sofort auch eine rudimentÑre Unter-
stÅtzung dieser Prozessoren in AS.  Unter "rudimentÑr" verstehe ich
dabei nicht, da· der Befehlssatz nicht vollstÑndig abgedeckt wird,
sondern da· ich nicht den ganzen Wust an Pseudoanweisungen integriert
habe, die sich bei MASM, TASM & Co. finden.
AS ist auch nicht in erster Linie geschrieben worden, um PC-Programme
zu entwickeln (Gott bewahre, das hie·e wirklich, das Rad neu zu er-
finden), sondern zur Programmentwicklung fÅr Einplatinenrechner, die
eben unter anderem auch mit 8086ern bestÅckt sein kînnen.

För Unentwegte, die mit AS doch DOS-Programme schreiben wollen, eine
kleine Liste dessen, was zu beachten ist:

 - Es kînnen nur COM-Programme erzeugt werden.
 - Verwenden Sie nur das CODE-Segment, und legen Sie auch alle Vari-
   ablen darin ab.
 - Alle Segmentregister werden von DOS auf das Codesegment vorini-
   tialisiert.  Ein ASSUME DS:DATA, SS:DATA am Programmanfang ist
   daher notwendig.
 - DOS lÑdt den Code ab Adresse 100h.  Ein ORG auf diese Adresse ist
   daher zwingend.
 - Die Umwandlung in eine BinÑrdatei erfolgt mit P2BIN (s.u.), wobei
   als Adre·bereich $-$ anzugeben ist.

AS unterstÅtzt fÅr diese Prozessoren nur ein Small-Programmiermodell,
d.h. EIN Codesegment mit maximal 64 KByte und ein ebenfalls hîchstens
64 KByte gro·es Datensegment mit nicht initialisierten Daten.
Zwischen diesen beiden Segmenten kann mit dem SEGMENT-Befehl hin-und
hergeschaltet werden.  Aus dieser Tatsache folgert, da· SprÅnge immer
intrasegmentÑr sind, sofern sie sich auf Adressen im Codesegment
beziehen.  Sofern weite SprÅnge doch einmal erforderlich sein sollten,
kînnen sie mit CALLF und JMPF und einer Speicheradresse oder einen
Segment:Offset-Wert als Argument erreicht werden.

Ein weiteres gro·es Problem dieser Prozessoren ist deren Assembler-
syntax, deren genaue Bedeutung nur aus dem Zusammenhang erkennbar
ist.  So kann im folgenden Beispiel je nach Symboltyp sowohl un-
mittelbare als auch absolute Adressierung gemeint sein:

    mov ax,wert

Bei AS ist immer absolute Adressierung gemeint, wenn um den Operanden
keine eckigen Klammern stehen.  Soll z.B. die Adresse oder der Inhalt
einer Variablen geladen werden, so ergeben sich folgende Unterschie-
de:

Assembler         Adresse             Inhalt
\hline
MASM         mov ax,offset vari   mov ax,vari
             lea ax,vari          mov ax,[vari]
             lea ax,[vari]

AS           mov ax,vari          mov ax,[vari]
             lea ax,[vari]

Der Assembler prÅft bei Symbolen, ob sie im Datensegment liegen und
versucht, automatisch einen passenden SegmentprÑfix einzufÅgen, z.B.
falls ohne CS-PrÑfix auf Symbole im Code zugegriffen wird.  Dieser
Mechanismus kann jedoch nur funktionieren, falls der ASSUME-Befehl
(siehe dort) korrekt angewendet wurde.

Die Intel-Syntax verlangt eine Abspeicherung, ob an einem Symbol
Bytes oder Wîrter abgelegt wurden.  AS nimmt diese Typisierung nur
vor, falls in der gleichen Zeile wie das Label ein DB oder DW steht.
FÅr alle anderen FÑlle mu· mit den Operatoren WORD PTR, BYTE PTR usw.
explizit angegeben werden, um was fÅr eine Operandengrî·e es sich
handelt.  Solange ein Register an der Operation beteiligt ist, kann
auf diese Kennzeichnung verzichtet werden, da durch den Registernamen
die Operandengrî·e eindeutig bestimmt ist.

Der Koprozessor in 8086-Systemen wird Åblicherweise durch den TEST-
Eingang des Prozessors synchronisiert, indem selbiger mit dem BUSY-
Ausgang des Koprozessors verbunden wird.  AS unterstÅtzt dieses
Handshaking, indem vor jedem 8087-Befehl automatisch ein WAIT-Befehl
eingefÅgt wird.  Ist dies aus irgendwelchen GrÅnden unerwÅnscht
(z.B. wÑhrend der Initialisierung), so mu· im Opcode hinter dem F
ein N eingefÅgt werden; aus

   FINIT
   FSTSW  [vari]

wird so z.B.

   FNINIT
   FNSTSW [vari]

Diese Variante ist bei ALLEN Koprozessorbefehlen erlaubt.


	4.14. XA
        --------

éhnlich wie sein VorgÑnger MCS/51, jedoch im Unterschied zu seinem 
"Konkurrenten" MCS/251 besitzt der Philips XA einen getrennten Bit-
adre·raum, d.h. alle mit Bitbefehlen manipulierbaren Bits haben eine
bestimmte, eindimensionale Adresse, die in den Maschinenbefehlen auch
so abgelegt wird.  Die naheliegende Mîglichkeit, diesen dritten 
Adre·raum (neben Code und Daten) auch so in AS anzubieten, habe ich 
nicht nutzen kînnen, und zwar aus dem Grund, da· ein Teil der Bit-
adressen im Gegensatz zum MCS/51 nicht mehr eindeutig ist: Bits mit
den Adressen 256 bis 511 bezeichnen Bits der Speicherzellen 20h..3fh
aus dem aktuellen Datensegment.  Dis bedeutet aber, da· diese Adressen
je nach Situation unterschiedliche Bits ansprechen kînnen - ein defi-
nieren von Bits mit Hilfe von DC-Befehlen, was durch ein extra Segment
mîglich geworden wÑre, wÅrde also nicht ÅbermÑ·ig viel Sinn ergeben.
Zur Definition einzelner, symbolisch ansprechbarer Bits steht aber 
nach wie vor der BIT-Befehl zur VerfÅgung, mit dem beliebige Bitadres-
sen (Register, RAM, SFR) definiert werden kînnen.  FÅr Bitadressen im 
internen RAM wird auch die 64K-Bank-Adresse gespeichert, so da· AS 
Zugriffe ÅberprÅfen kann, sofern das DS-Register korrekt mit ASSUME
vorbesetzt wurde.

Der XA benutzt die gleichen Pseudobefehle zur Konstantenablage wie
die 68000-Familie.  Dies bedeutet dummerweise auch, da· defaultmÑ·ig
die Anzahl abgelegter Bytes auf eine gerade Zahl aufgerundet wird. 
Beim XA sind gerade Adressen nicht so zwingend, deshalb ist ein 
PADDING OFF am Anfang schon fast obligatorisch...

Nichts drehen kann man dagegen an den BemÅhungen von AS, potentielle
Sprungziele (also Zeilen im Code mit Label) auf gerade Adressen auszu-
richten.  Dies macht AS genauso wie andere XA-Assembler auch durch
EinfÅgen von NOPs vor dem fraglichen Befehl.  


	4.15. Z80UNDOC
        --------------

Da es von Zilog naturgemÑ· keine Syntaxvorgaben fÅr die undokumen-
tierten Befehle gibt und wohl auch nicht jeder den kompletten Satz
kennt, ist es vielleicht sinnvoll, diese Befehle hier kurz aufzu-
zÑhlen:

Wie auch beim Z380 ist es mîglich, die Byte-HÑlften von IX und IY
einzeln anzusprechen.  Im einzelnen sind dies folgende Varianten:

 INC Rx              LD R,Rx             LD  Rx,n
 DEC Rx              LD Rx,R             LD  Rx,Ry
 ADD/ADC/SUB/SBC/AND/XOR/OR/CP A,Rx

Dabei stehen Rx bzw. Ry fÅr IXL, IXU, IYL oder IYU.  Zu beachten
ist jedoch, da· in der LD Rx,Ry-Variante beide Register aus dem
gleichen Indexregister stammen mÅssen.

Die Kodierung von Schiebebefehlen besitzt noch eine undefinierte
Bitkombination, die als SLIA-Befehl zugÑnglich ist.  SLIA
funktioniert wie SLA, es wird jedoch eine Eins und nicht eine Null
in Bit 0 eingeschoben.  Dieser Befehl kann, wie alle anderen
Schiebebefehle auch, noch in einer weiteren Variante geschrieben
werden:

 SLIA R,(XY+d)

Dabei steht R fÅr ein beliebiges 8-Bit-Register (aber nicht eine
IndexregisterhÑlfte...), und (XY+d) fÅr eine normale indexregister-
relative Adressierung.  Das Ergebnis dieser Operation ist, da· das
Schiebeergebnis zusÑtzlich ins Register geladen wird.  Dies funk-
tioniert auch bei den RES- und SET-Befehlen:

 SET/RES R,n,(XY+d)

Des weiteren gibt es noch zwei versteckte I/O-Befehle:

 IN (C) bzw. TSTI
 OUT (C),0

Deren Funktionsweise sollte klar sein.  ACHTUNG! Es gibt keine
Garantie dafÅr, da· alle Z80-Masken alle diese Befehle beherrschen,
und die Z80-Nachfolger lîsen zuverlÑssig Traps aus.  Anwendung
daher auf eigene Gefahr...


	4.16. Z380
	----------

Da dieser Prozessor als Enkel des wohl immer noch beliebtesten
8-Bit-Prozessors konzipiert wurde, war es bei der Entwicklung
unabdingbar, da· dieser bestehende Z80-Programme ohne énderung
ausfÅhren kann (natÅrlich geringfÅgig schneller, etwa um den
Faktor 10...).  Die erweiterten FÑhigkeiten kînnen daher nach
einem Reset mit zwei Flags zugeschaltet werden, die XM (extended
Mode, d.h. 32- statt 16-Bit-Adre·raum) und LW (long word mode,
d.h. 32- statt 16- Bit-Operanden) hei·en.  Deren Stand mu· man
AS Åber die Befehle EXTMODE und LWORDMODE mitteilen, damit
Adressen und Konstantenwerte gegen die korrekten Obergrenzen
geprÅft werden.  Die Umschaltung zwischen 32- und 16-Bit-Befehlen
bewirkt natÅrlich nur bei solchen Befehlen etwas, die auch in
einer 32-Bit-Version existieren; beim Z380 sind das momentan
leider nur Lade- und Speicherbefehle, die ganze Aritmetik kann
nur 16-bittig ausgefÅhrt werden.  Hier sollte Zilog wohl noch
einmal etwas nachbessern, sonst kann man den Z380 selbst beim
besten Willen nur als "16-Bit-Prozessor mit 32-Bit-Erweiterungen"
bezeichnen...

Kompliziert wird die Sache dadurch, da· die mit LW eingestellte
Operandengrî·e fÅr einzelne Befehle mit den PrÑfixen DDIR W
und DDIR LW Åbersteuert werden kann.  AS merkt sich das Auf-
treten solcher Befehle und schaltet dann fÅr den nÑchsten
Prozessorbefehl automatisch mit um.  Andere DDIR-Varianten
als W und LW sollte man Åbrigens nie explizit verwenden, da
AS bei zu langen Operanden diese automatisch einsetzt, und das
kînnte zu Verwirrungen fÅhren.  Die Automatik geht Åbrigens
so weit, da· in der Befehlsfolge

	DDIR    LW
	LD      BC,12345678h

automatisch der erforderliche IW-PrÑfix mit in die vorange-
hende Anweisung hineingezogen wird, effektiv wird also der
Code

	DDIR    LW,IW
	LD      BC,12345678h

erzeugt.  Der im ersten Schritt erzeugte Code fÅr DDIR LW
wird verworfen, was an einem kleinen R im Listing zu erkennen
ist.


	4.17. TLCS-900(L)
	-----------------

Diese Prozessoren kînnen in zwei Betriebsarten laufen, einmal im
Minimum-Modus, der weitgehende Z80- und TLCS90-Quellcodekompati-
bilitÑt bietet, und zum anderen im Maximum-Modus, in dem der
Prozessor erst seine wahren QualitÑten entfaltet.  Die Hauptunter-
schiede zwischen den beiden Betriebsarten sind:

 - Breite der Register WA,BC,DE und HL: 16 oder 32 Bit;
 - Anzahl der Registerbanks: 8 oder 4;
 - Programmadre·raum: 64 KByte oder 16 MByte;
 - Breite von RÅcksprungadressen: 16 oder 32 Bit.

Damit AS gegen die richtigen Grenzen prÅfen kann, mu· man ihm zu
Anfang mit dem Befehl MAXMODE (siehe dort) mitteilen, in welcher
Betriebsart der Code ausgefÅhrt werden wird; Voreinstellung ist
der Minimum-Modus.

Je nach Betriebsart mÅssen demzufolge auch die 16- oder 32-Bit-
Versionen der Bankregister zur Adressierung verwendet werden, d.h.
WA, BC, DE und HL im Minimum-Modus sowie XWA, XBC, XDE und XHL im
Maximum-Modus.  Die Register XIX..XIZ und XSP sind IMMER 32 Bit
breit und mÅssen zur Adressierung auch immer in dieser Form ver-
wendet werden; hier mu· bestehender Z80-Code also auf jeden Fall
angepa·t werden (neben der Tatsache, da· es gar keinen I/O-Adre·-
raum mehr gibt und alle I/O-Register memory-mapped sind...).

Die von Toshiba gewÑhlte Syntax ist in der Hinsicht etwas unglÅck-
lich, als da· zur Anwahl der vorherigen Registerbank ein Hochkomma
(') benutzt wird.  Dieses Zeichen wird von den prozessorunabhÑngigen
Teilen von AS bereits zur Kennzeichnung von Zeichenkonstanten be-
nutzt.  Im Befehl

  ld wa',wa

erkennt AS z.B. weder das Komma zur Parametertrennung, noch wandelt
er den zweiten Parameter im Gro·buchstaben um.  Dieses Problem kann
man aber umgehen, indem man ein umgekehrtes Hochkomma (`) verwendet,
z.B.

  ld wa`,wa

Toshiba liefert fÅr die TLCS-900-Reihe selber einen Assembler
(TAS900), der sich in einigen Punkten von AS unterscheidet:

    Symbolkonventionen

 - TAS900 unterscheidet Symbolnamen nur auf den ersten 32
   Zeichen.  AS dagegen speichert Symbolnamen immer in der vollen
   LÑnge (bis 255 Zeichen) und unterscheidet auch auf dieser LÑnge.

 - Unter TAS900 kînnen Integerkonstanten sowohl in C-Notation (mit
   vorangestellter 0 fÅr oktal bzw. 0x fÅr hexadezimal) als auch in
   normaler Intel-Notation geschrieben werden.  AS unterstÅtzt in der
   Default-Einstellung NUR die Intel-Notation. Mit dem RELAXED-Befehl
   bekommt man (unter anderem) auch die C-Notation.

 - AS macht keinen Unterschied zwischen Gro·- und Kleinschreibung,
   TAS900 hingegen unterscheidet Gro·-und Kleinbuchstaben in
   Symbolnamen.

    Syntax

AS ist bei vielen Befehlen in der SyntaxprÅfung weniger streng als
TAS900, bei einigen weicht er (sehr) geringfÅgig ab.  Diese Erwei-
terungen bzw. énderungen dienen teilweise der leichteren Portierung
von bestehendem Z80-Code, teilweise einer Schreiberleichterung und
teilweise einer besseren OrthogonalitÑt der Assemblersyntax:

 - Bei den Befehlen LDA, JP und CALL verlangt TAS, da· Adre·ausdrÅcke
   wie XIX+5 nicht geklammert sein dÅrfen, wie es sonst Åblich ist.
   AS verlangt im Sinne der OrthogonalitÑt fÅr LDA dagegen immer eine
   Klammerung, bei JP und CALL ist sie dagegen fÅr einfache, absolute
   Adressen optional.

 - Bei den bedingten Befehlen JP, CALL, JR und SCC stellt AS es dem
   Programmierer frei, die Default-Bedingung "T" (= true) als ersten
   Parameter anzugeben oder nicht.  TAS900 hingegen erlaubt es nur,
   die Default-Bedingung implizit zu benutzen (also z.B. jp (xix+5)
   anstelle von jp t,(xix+5)).

 - AS erlaubt beim EX-Befehl auch Operandenkombinationen, die zwar
   nicht direkt im User's Manual [Tosh900] genannt werden, aber durch
   Vertauschung auf eine genannte zurÅckgefÅhrt werden kînnen.  Kom-
   binationen wie EX f',f oder EX wa,(xhl) werden damit mîglich.
   TAS900 hingegen lÑ·t nur die "reine Lehre" zu.

 - AS erlaubt, bei den Befehlen INC und DEC die Angabe des Inkrements
   oder Dekrements wegzulassen, wenn dies 1 ist.  Unter TAS900 dagegen
   mu· auch eine 1 hingeschrieben werden.

 - éhnlich verhÑlt es sich bei allen Schiebebefehlen: Ist der zu ver-
   schiebende Operand ein Register, so verlangt TAS900, da· auch eine
   Schiebeamplitude von 1 ausgeschrieben werden mu·; ist dagegen eine
   Speicherstelle der Operand, so ist die Schiebezahl (hardwarebe-
   dingt) immer 1 und darf auch nicht hingeschrieben werden.  Unter AS
   dagegen ist die Schiebezahl 1 immer optional und auch fÅr alle Ope-
   randentypen zulÑssig.

    Makroprozessor

Der Makroprozessor wird TAS900 als externes Programm vorgeschaltet und
besteht aus zwei Komponenten: einem C-artigen PrÑprozessor und einer
speziellen Makrosprache (MPL), die an hîhere Programmiersprachen erin-
nert.  Der Makroprozessor von AS dagegen orientiert sich an "klassi-
schen" Makroassemblern wie dem M80 oder MASM (beides Programme von
Microsoft).  Er ist fester Bestandteil des Programmes.

    Ausgabeformat

TAS900 erzeugt relokatiblen Code, so da· sich mehrere, getrennt assem-
blierte Teile zu einem Programm zusammenbinden lassen.  AS hingegen
erzeugt direkt absoluten Maschinencode, der nicht linkbar ist.  An ei-
ne Erweiterung ist (vorlÑufig) nicht gedacht.

    Pseudoanweisungen

Bedingt durch den fehlenden Linker fehlen in AS eine ganze Reihe von
fÅr relokatiblen Code erforderlichen Pseudoanweisungen, die TAS900
implementiert.  In gleicher Weise wie bei TAS900 sind folgende Anwei-
sungen vorhanden:

   EQU, DB, DW, ORG, ALIGN, END, TITLE, SAVE, RESTORE,

wobei die beiden letzteren einen erweiterten Funktionsumfang haben.
Einige weitere TAS900-Pseudobefehle lassen sich durch Ñquivalente AS-
Befehle ersetzen:



TAS900         AS                   Bedeutung/Funktion

DL <Daten>     DD <Daten>           Speicher in Langworten belegen
DSB <Zahl>     DB <Zahl> DUP (?)    Speicher byteweise reservieren
DSW <Zahl>     DW <Zahl> DUP (?)    Speicher wortweise reservieren
DSD <Zahl>     DD <Zahl> DUP (?)    Speicher langwortweise reservieren
$MIN[IMUM]     MAXMODE OFF          folgender Code im Minimum-Modus
$MAX[IMUM]     MAXMODE ON           folgender Code im Maximum-Modus
$SYS[TEM]      SUPMODE ON           folgender Code im System-Modus
$NOR[MAL]      SUPMODE OFF          folgender Code im User-Modus
$NOLIST        LISTING OFF          Assemblerlisting ausschalten
$LIST          LISTING ON           Assemblerlisting einschalten
$EJECT         NEWPAGE              neue Seite im Listing beginnen

Von Toshiba existieren zwei Versionen des Prozessorkerns, wobei die
L-Variante eine "Sparversion" darstellt.  Zwischen TLCS-900 und
TLCS-900L macht AS folgende Unterschiede:

 - Die Befehle MAX und NORMAL sind fÅr die L-Version nicht erlaubt,
   der MIN-Befehl ist fÅr die Vollversion gesperrt.
 - Die L-Version kennt den Normal-Stapelzeiger XNSP/NSP nicht, dafÅr
   das Steuerregister INTNEST.

Die Befehle SUPMODE und MAXMODE werden nicht beeinflu·t, ebenso nicht
deren initiale Einstellung OFF.  Die Tatsache, da· die L-Version im
Maximum-Modus startet und keinen Normal-Modus kennt, mu· also vom
Programmierer berÅcksichtigt werden.  AS zeigt sich jedoch insofern
kulant gegenÅber der L-Variante, als da· Warnungen wegen privilegier-
ter Anweisungen im L-Modus unterdrÅckt werden.


	4.18. TLCS-90
	-------------

Vielleicht fragt sich der eine oder andere, ob bei mir die Reihenfolge
durcheinandergekommen ist, es gab ja von Toshiba zuerst den 90er als
"aufgebohrten Z80" und danach den 900er als 16-Bit-Version.  Nun, ich
bin einfach Åber den 900er zum 90er gekommen (Danke, Oliver!).  Die
beiden Familien sind sich sehr artverwandt, nicht nur was ihre Syntax
angeht, sondern auch ihre Architektur.  Die Hinweise fÅr den 90er sind
daher eine Untermenge derer fÅr den 900er: Da Schieben, Inkrementieren
und Dekrementieren hier nur um eins mîglich sind, braucht und darf die-
se eins auch nicht als erstes Argument hingeschrieben werden.  Bei
den Befehlen LDA, JP und CALL mîchte Toshiba wieder die Klammern um
Speicheroperanden weglassen, bei AS mÅssen sie aber aus GrÅnden der
OrthogonalitÑt gesetzt werden (der tiefere Grund ist natÅrlich, da·
ich mir damit eine Sonderabfrage im Parser gespart habe, aber das sagt
man nicht so laut).

Die TLCS-90er besitzen bereits prinzipiell einen Adre·raum von 1
MByte, dieser Raum erschlie·t sich aber nur bei Datenzugriffen Åber
die Indexregister.  AS verzichtet daher auf eine BerÅcksichtigung
der Bankregister und begrenzt den Adre·raum fÅr Code auf 64 KByte.
Da der Bereich jenseits aber sowieso nur Åber indirekte Adressierung
erreichbar ist, sollte dies keine allzu gro·e EinschrÑnkung darstel-
len.

	4.19. TLCS-870
	--------------

Schon wieder Toshiba...diese Firma ist im Augenblick wirklich sehr
produktiv!  Speziell dieser Spro· der Familie (Toshibas Mikrokon-
troller sind sich ja alle in BinÑrkodierung und Programmiermodell
recht Ñhnlich) scheint auf den 8051-Markt abzuzielen: Die Methode,
Bitstellen durch einen Punkt getrennt an den Adre·ausdruck anzu-
hÑngen, hatte ja beim 8051 ihren Ursprung, fÅhrt jetzt aber auch
genau zu den Problemen, die ich beim 8051 geahnt hatte: Der Punkt
ist jetzt einerseits legales Zeichen in Symbolnamen, andererseits
aber auch Teil der Adre·syntax, d.h. AS mu· Adresse und Bitstelle
trennen und einzeln weiterverarbeiten.  Diesen Interessenkonflikt
habe ich vorerst so gelîst, da· der Ausdruck von HINTEN an nach
Punkten durchsucht wird und so der letzte Punkt als Trenner gilt,
eventuelle weitere Punkte werden dem Symbolnamen zugerechnet.
Es gilt weiterhin die flehentliche Bitte, im eigenen Interesse auf
Punkte in Symbolnamen zu verzichten, sie fÅhren nur zu Verwir-
rungen:

   LD    CF,A.7         ; Akku Bit 7 nach Carry
   LD	 C,A.7          ; Konstante A.7 nach Akku


	4.20. TLCS-47
	-------------

Mit dieser 4-Bit-Prozessorfamilie dÅrfte wohl das unter Ende dessen
erreicht sein, was AS unterstÅtzen kann.  Neben dem ASSUME-Befehl
fÅr das Datenbankregister (siehe dort) ist eigentlich nur ein Detail
erwÑhnenswert: im Daten- und I/O-Segment werden keine Bytes, sondern
Nibbles reserviert (eben 4-Bitter...).  Die Sache funktioniert Ñhnlich
wie das Bitdatensegment beim 8051, wo ein DB ja nur einzelne Bit re-
serviert, nur da· es hier eben Nibbles sind.

Toshiba hat fÅr diese Prozessorfamilie einen "erweiterten Befehlssatz"
in Makroform definiert, um das Arbeiten mit diesem doch recht be-
schrÑnkten Befehlssatz zu erleichtern.  Im Fall von AS ist er in der
Datei STDDEF47.INC definiert.  Einige Befehle, deren makromÑ·ige
Realisierung nicht mîglich war, sind allerdings "eingebaut" und stehen
daher auch ohne die Include-Datei zur VerfÅgung:

 - der B-Befehl, der die jeweils optimale Version des Sprungbefehls
   (BSS, BS oder BSL) automatisch wÑhlt;
 - LD in der Variante HL mit immediate;
 - ROLC und RORC mit einer Schiebeamplitude >1.


	4.21. TLCS-9000
	---------------

Hier ist es zum ersten Mal passiert, da· ich einen Prozessor in AS
implementiert habe, der zu diesem Zeitpunkt noch gar nicht auf dem
Markt war. Toshiba hat sich leider auch vorlÑufig dazu entschieden,
diesen Prozessor "auf Eis" zu legen, bis auf weiteres wird es also
auch kein Silizium geben.  Das hat natÅrlich zur Folge, da· dieser
Teil

 1. ein "Paper-Design" ist, d.h. noch nicht praktisch getestet
    wurde und
 2. Die Unterlagen, die ich zum 9000er hatte [Tosh9000], noch vor-
    lÑufig waren, also noch nicht bis ins letzte Klarheit lieferten.

Fehler in diesem Teil sind also durchaus noch mîglich (und werden
natÅrlich bereinigt, wenn es denn einmal gehen sollte!).  Zumindest
die Handvoll Beispiele in [Tosh9000] werden aber richtig Åbersetzt.


	4.22. 29xxx
        -----------

Wie schon beim ASSUME-Befehl beschrieben, kann AS mit der Kenntnis
Åber den Inhalt des RBP-Registers feststellen, ob im User-Modus
auf gesperrte Register zugegriffen wird.  Diese FÑhigkeit
beschrÑnkt sich natÅrlich auf direkte Zugriffe (also nicht, wenn
die Register IPA...IPC benutzt werden), und sie hat noch einen
weiteren Haken: da lokale Register (also solche mit Nummern>127)
relativ zum Stackpointer adressiert werden, die Bits in RBP sich
aber immer auf absolute Nummern beziehen, wird die PrÅfung fÅr
lokale Register NICHT durchgefÅhrt.  Eine Erweiterung auf lokale
Register wÅrde bedingen, da· AS zu jedem Zeitpunkt den absoluten
Wert von SP kennt, und das wÅrde spÑtestens bei rekursiven Unter-
programmen scheitern...


	4.23. 80C166/167
	----------------

Wie in der ErklÑrung des ASSUME-Befehls schon erlÑutert, versucht
AS, dem Programmierer die Tatsache, da· der Prozessor mehr physi-
kalischen als logischen Speicher hat, soweit als mîglich zu ver-
bergen.  Beachten Sie aber, da· die DPP-Register NUR Datenzugriffe
betreffen und auch dort nur absolute Adressierung, also weder
indirekte noch indizierte Zugriffe, da AS ja nicht wissen kann,
wie die berechnete Adresse zur Laufzeit aussehen wird...
Bei Codezugriffen arbeitet die Pagingeinheit leider nicht, man
mu· also explizit mit langen oder kurzen CALLs, JMPs oder RETs
arbeiten.  Zumindest bei den "universellen" Befehlen CALL und JMP
wÑhlt AS automatisch die kÅrzeste Form, aber spÑtestens beim RET
sollte man wissen, woher der Aufruf kam.  Prinzipiell verlangen
JMPS und CALLS dabei, da· man Segment und Adresse getrennt angibt,
AS ist jedoch so geschrieben, da· der eine Adresse selber zerlegen
kann, z.B.

   jmps   12345h

anstelle von

   jmps   1,2345h

Leider sind nicht alle Effekte der chipinternen Instruktions-Pipeline
versteckt: Werden CP (Registerbankadresse), SP (Stack) oder eines
der Paging-Register verÑndert, so steht der neue Wert noch nicht
fÅr den nÑchsten Befehl zur VerfÅgung.  AS versucht, solche Situa-
tionen zu erkennen und gibt im Falle eines Falles eine Warnung aus.
Aber auch diese Mimik greift nur bei direkten Zugriffen.

Mit BIT definierte Bits werden intern in einem 12-Bit-Wort abgelegt,
wobei die Bitadresse in Bit 4..11 liegt und die Bitnummer in den
unteren vier Bits.  Diese Anordnung erlaubt es, das nÑchsthîhere
bzw. nÑchstniedrigere Bit durch Inkrementieren bzw. Dekrementieren
anzusprechen.  Bei expliziten Bitangaben mit Punkt funktioniert das
aber nicht Åber Wortgrenzen hinaus.  So erzeugt folgender Ausdruck
eine WertebereichsÅberschreitung:

   bclr   r5.15+1

Hier mu· ein BIT her:

msb bit   r5.15
    .
    .
    bclr  msb+1

FÅr den 80C167 ist der SFR-Bereich verdoppelt worden; da· ein Bit im
zweiten Teil liegt, wird durch ein gesetztes Bit 12 vermerkt.  Leider
hatte Siemens bei der Definition des 80C166 nicht vorausgesehen, da·
256 SFRs (davon 128 bitadressierbar) fÅr Nachfolgechips nicht reichen
wÅrden. So wÑre es unmîglich, den zweiten SFR-Bereich von F000H..F1DFH
mit kurzen Adressen oder Bitbefehlen zu erreichen, hÑtten die Entwik-
kler nicht einen Umschaltbefehl eingebaut:

  EXTR #n

Dieser befehl bewirkt, da· fÅr die nÑchsten n Befehle (0<n<5) anstelle
des normalen der erweiterte SFR-Bereich angesprochen werden kann.  AS
erzeugt bei diesm Befehl nicht nur den passenden Code, sondern setzt
intern ein Flag, da· fÅr die nÑchsten n Befehle nur Zugriffe auf den
erweiterten SFR-Bereich zulÑ·t.  Da dÅrfen natÅrlich keine SprÅnge
dabei sein... Bits aus beiden Bereichen lassen sich natÅrlich jederzeit
definieren, ebenso sind komplette Register aus beiden SFR-Bereichen
jederzeit mit absoluter Adressierung erreichbar.  Nur die kurze bzw.
Bitadressierung geht immer nur abwechselnd, Zuwiderhandlungen werden
mit einer Fehlermeldung geahndet.

éhnlich sieht es mit den PrÑfixen fÅr absolute bzw. indirekte Adres-
sierung aus: Da aber sowohl Argument des PrÑfixes als auch der
Adre·ausdruck nicht immer zur öbersetzungszeit bestimmbar sind, sind
die PrÅfungsmîglichkeiten durch AS sehr eingeschrÑnkt, weshalb er es
auch bei Warnungen belÑ·t...im einzelnen sieht das folgenderma·en aus:

 - feste Vorgabe einer 64K-Bank mittels EXTS oder EXTSR: Im Adre·-
   ausdruck werden direkt die unteren 16 Bit der Zieladresse einge-
   setzt.  Haben sowohl PrÑfix als auch Befehl einen konstanten
   Operanden, so wird ÅberprÅft, ob PrÑfixargument und Bit 16..23 der
   Zieladresse identisch sind.

 - feste Vorgabe einer 16K-Seite mittels EXTP oder EXTPR: Im Adre·-
   ausdruck werden direkt die unteren 14 Bit der Zieladresse einge-
   setzt.  Bit 14 und 15 bleiben konstant 0, da sie in diesem Modus
   nicht vom Prozessor ausgewertet werden.  Haben sowohl PrÑfix als
   auch Befehl einen konstanten Operanden, so wird ÅberprÅft, ob
   PrÑfixargument und Bit 14..23 der Zieladresse identisch sind.

Damit das etwas klarer wird, ein Beispiel (die DPP-Register haben
die Reset-Vorbelegung) :

	extp	#7,#1		; Bereich von 112K..128K
	mov	r0,1cdefh	; ergibt Adresse 0defh im Code
	mov	r0,1cdefh	; -->Warnung
	exts	#1,#1		; Bereich von 64K..128K
	mov	r0,1cdefh	; ergibt Adresse 0cdefh im Code
	mov	r0,1cdefh	; -->Warnung


	4.24. PIC16C5x/16C8x
	--------------------

éhnlich wie die MCS-48-Familie teilen auch die PICs ihren Programm-
speicher in mehrere BÑnke auf, da im Opcode nicht genÅgend Platz fÅr
die vollstÑndige Adresse war.  AS verwendet fÅr die Befehle CALL und
GOTO die gleiche Automatik, d.h. setzt die PA-Bits im Statuswort ent-
sprechend Start- und Zieladresse.  Im Gegensatz zu den 48ern ist die-
ses Verfahren hier aber noch deutlich problematischer:

  1. Die Befehle sind nicht mehr nur ein Wort, sondern bis zu drei
     Worten lang, kînnen also nicht mehr in jedem Fall mit einem
     bedingten Sprung Åbergangen werden.
  2. Es ist mîglich, da· der ProgrammzÑhler beim normalen Programm-
     fortgang eine Seitengrenze Åberschreitet.  Die vom Assembler
     angenommene Belegung der PA-Bits stimmt dann nicht mehr mit der
     RealitÑt Åberein.

Bei den Befehlen, die das Register W mit einem anderen Register ver-
knÅpfen, mu· normalerweise als zweiter Parameter angegeben werden, ob
das Ergebnis in W oder im Register abgelegt werden soll.  Bei diesem
Assembler ist es erlaubt, den zweiten Parameter wegzulassen.  Welches
Ziel dann angenommen werden soll, hÑngt vom Typ des Befehls ab: bei
unÑren Operationen wird defaultmÑ·ig das Ergebnis zurÅck ins Register
gelegt. Diese Befehle sind:

    COMF, DECF, DECFSZ, INCF, INCFSZ, RLF, RRF und SWAPF

Die anderen Befehle betrachten W defaultmÑ·ig als Akkumulator, zu dem
ein Register verknÅpft wird:

ADDWF, ANDWF, IORWF, MOVF, SUBWF und XORWF

Die von Microchip vorgegebene Schreibweise fÅr Literale ist ziemlich
abstrus und erinnert an die auf IBM 360/370-Systemen Åbliche Schreib-
weise (GrÅ·e aus Neandertal...).  Um nicht noch einen Zweig in den
Parser einfÅgen zu mÅssen, sind bei AS Konstanten in Motorola-Syntax
zu schreiben (wahlweise auch Intel oder C im RELAXED-Modus).

	4.25. PIC 17C4x
	---------------

FÅr diese Prozessoren gelten im wesentlichen die gleichen Hinweise wie
fÅr ihre kleinen BrÅder, mit zwei Ausnahmen: Die zugehîrige Include-
Datei enthÑlt nur Registerdefinitionen, und die Probleme bei Sprungbe-
fehlen sind deutlich kleiner.  Aus der Reihe fÑllt nur LCALL, der einen
16-Bit-Sprung erlaubt.  Dieser wird mit folgendem "Makro" Åbersetzt:

   MOVLW <Adr15..8>
   MOWF  3
   LCALL <Adr0..7>


	4.26. ST62xx
	------------

Diese Prozessoren kînnen das Code-ROM seitenweise in den Datenbereich
einblenden.  Weil ich nicht die ganze Mimik des ASSUME-Befehles hier
wiederkÑuen mîchte, verweise ich auf das entsprechende Kapitel, in dem
steht, wie man mit diesem Befehl einigerma·en unfallfrei Konstanten
aus dem ROM lesen kann.

Bei nÑhererer Betrachtung des Befehlssatzes fallen einige eingebaute
"Makros" auf.  Hier die Liste der Befehle, die mir aufgefallen sind
(es gibt aber wohl noch mehr...):


    Befehl    in Wirklichkeit

    CLR A     SUB A,A
    SLA A     ADD A,A
    CLR adr   LDI adr,0
    NOP       JRZ PC+1

Insbesondere der letztere Fall verblÅfft doch etwas...Leider fehlen
aber einige Anweisungen wirklich.  So gibt es z.B. zwar einen AND-
Befehl, aber kein OR...von XOR gar nicht zu reden.  In der Datei
STDDEF62.INC finden sich deshalb neben den Adressen der SFRs noch
einige Makros zur Abhilfe.
			   
Der Original-Assembler AST6 von SGS-Thomson verwendet teilweise andere
Pseudobefehle als AS.  Au·er der Tatsache, da· AS Pseudobefehle nicht
mit einem vorangestellten Punkt kennzeichnet, sind folgende Befehle
identisch:

  ASCII, ASCIZ, BLOCK, BYTE, END, ENDM, EQU, ERROR, MACRO,
  ORG, TITLE, WARNING

Folgende AST6-Befehle haben analoge in AS:

     AST6            AS                 Bedeutung/Funktion

     .DISPLAY        MESSAGE            Meldung ausgeben
     .EJECT          NEWPAGE            neue Seite im Listing
     .ELSE           ELSEIF             bed. Assemblierung
     .ENDC           ENDIF              bed. Assemblierung
     .IFC            IF...              bed. Assemblierung
     .INPUT          INCLUDE            Include-Datei einbinden
     .LIST           LISTING, MACEXP    Listing-Einstellung
     .PL             PAGE               SeitenlÑnge Listing
     .ROMSIZE        CPU                Zielprozessor einstellen
     .VERS
     .SET            EVAL               Variablen neu setzen


	4.27. 6804
	----------

Eigentlich habe ich diesen Prozessor ja nur eingebaut, um mich Åber
das seltsame Gebaren von SGS-Thomson zu beklagen: Als ich das 6804-
Datenbuch zum ersten Mal in die Hand bekam, fÅhlte ich mich ob des
etwas "unvollstÑndigen" Befehlssatzes und der eingebauten Makros
spontan an die ST62-Serie vom gleichen Hersteller erinnert.  Ein
genauerer Vergleich der Opcodes fîrderte erstaunliches zu Tage:
Ein 6804-Opcode ergibt sich durch Spiegelung aller Bits im entspre-
chenden ST62-OpCode!  Thomson hat hier also offensichtlich etwas
Prozessorkern-Recycling betrieben...wogegen ja auch nichts einzu-
wenden wÑre, wenn nicht so eine Verschleierungstaktik betrieben
werden wÅrde: andere Peripherie, Motorola- anstelle Zilog-Syntax
sowie das hÑ·liche Detail, in Opcodes enthaltene Argumente (z.B.
Bitfelder mit Displacements) NICHT zu drehen.  Letzterer Punkt
hat mich auch nach lÑngerem öberlegen dazu bewogen, den 6804 doch
in AS aufzunehmen.  Ich wage Åbrigens keine Spekulationen, welche
Abteilung bei Thomson von welcher abgekupfert hat...

Im Gegensatz zur ST62-Version enthÑlt die Include-Datei fÅr den
6804 keine Makros, die die LÅcken im Befehlssatz etwas "auspol-
stern" sollen.  Dies Åberlasse ich dem geneigten Leser als
FingerÅbung!


	4.28. TMS3201x
	--------------

Offensichtlich ist es Ehrgeiz jedes Prozessorherstellers, seine
eigene Notation fÅr Hexadezimalkonstanten zu erfinden.  Texas Instru-
ments war bei diesen Prozessoren besonders originell: ein vorange-
stelltes >-Zeichen!  Die öbernahme dieses Formates in AS hÑtte zu
schweren Konflikten mit den Vergleichs-und Schiebeoperatoren von AS im
Formelparser gefÅhrt.  Ich habe mich deshalb fÅr die Intel-Notation
entschieden, zu der sich TI bei der 340x0-Serie und den 3201x-Nachfol-
gern ja dann auch durchgerungen hat...

Leider hat das Instruktionswort dieser Prozessoren nicht genÅgend
Bits, um bei direkter Adressierung alle 8 Bits zu enthalten, weshalb
der Datenadre·raum logisch in 2 BÑnke zu 128 Wîrtern gespalten ist.
AS verwaltet diesen als ein durchgehendes Segment von 256 Wîrtern und
lîscht bei direkten Zugriffen automatisch das Bit 7 (Ausnahme: Befehl
SST, der nur in die obere Bank schreiben kann). Der Programmierer ist
dafÅr erforderlich, da· das Bank-Bit stets den richtigen Wert hat!

Ein weiterer, nur sehr versteckt im Datenbuch stehender Hinweis: Die
SUBC-Anweisung benîtigt zur AusfÅhrung intern mehr als einen Takt, das
Steuerwerk arbeitet jedoch schon an dem nÑchsten Befehl weiter. Im auf
ein SUBC folgenden Befehl darf deshalb nicht auf den Akkumulator zuge-
griffen werden.  AS nimmt hier keine PrÅfung vor!


	4.29. TMS320C2x
	---------------

Da ich nicht selber diesen Codegenerator geschrieben habe (was nichts
an seiner QualitÑt mindert), kann ich nur kurz hier umrei·en, wieso es
Befehle gibt, bei denen ein vorangestelltes Label als untypisiert,
d.h. keinem Adre·raum zugeordnet, gespeichert wird:  Der 20er der
TMS-Reihe kennt sowohl ein 64 KByte gro·es Code- als auch Datenseg-
ment.  Je nach externer Beschaltung kann man dabei Code- und Datenbe-
reiche Åberlappen, um z.B. Konstanten im Codebereich abzulegen und
auf diese als Daten zuzugreifen (Ablage im Code ist notwendig, weil
AS davon ausgeht, da· ein Datensegment aus RAM besteht, das in einem
Standalone-System nach dem Einschalten keinen definierten Inhalt hat
und verweigert in Segmenten au·er Code deshalb die Ablage von Daten).
Ohne dieses Feature wÅrde AS nun jeden Zugriff auf die abgelegten
Daten mit einer Warnung ("Symbol aus falschem Segment") quittieren.
Im einzelnen erzeugen folgende Pseudobefehle untypisierte Labels:

  BSS, STRING, RSTRING, BYTE, WORD , LONG, FLOAT
  DOUBLE, EFLOAT, BFLOAT und TFLOAT

Sollten doch einmal typisierte Labels gewÅnscht sein, so kann man
sich behelfen, indem man das Label in eine getrennte Zeile vor dem
Pseudobefehl schreibt.  Umgekehrt kann man einen der anderen Pseudo-
befehle mit einem typenlosen Label versehen, indem man vor dem Befehl
das Label mit

<Name>  EQU     $

definiert.


	4.30. TMS320C3x
	---------------

Die grî·ten Magenschmerzen bei diesem Prozessor hat mir die Syntax
paralleler Befehle bereitet, die auf zwei Zeilen verteilt werden,
wobei beide Befehle an sich auch sequentiell ausgefÅhrt werden kînnen.
Deshalb erzeugt AS zuerst den Code fÅr die einzelne erste Operation,
wenn er dann in der zweiten Zeile erkennt, da· eine parallele Awei-
sung vorliegt, wird der zuerst erzeugte Code durch den neuen ersetzt.
Im Listing kann man dies daran erkennen, da· der ProgrammzÑhler
nicht weiterlÑuft und in der zweiten Zeile anstelle eines Doppel-
punktes ein "R" vor dem erzeugten Code steht.

BezÅglich der doppelten senkrechten Striche und ihrer Position in der
Zeile ist man nicht ganz so flexibel wie beim TI-Assembler: Entweder
man schreibt sie anstelle eines Labels (d.h. in der ersten Spalte)
oder direkt vor den zweiten Befehl ohne Leerzeichen, sonst bekommt
der Zeilenparser von AS Probleme...


	4.31. TMS370xxx
	---------------

Obwohl diese Prozessoren keine speziellen Befehle zur Bitmanipulation
besitzen, wird mit Hilfe des Assemblers und des DBIT-Befehles (siehe
dort) die Illusion erzeugt, als ob man einzelne Bits manipulieren
wÅrde.  Dazu wird beim DBIT-Befehl eine Adresse mit einer Bitposition
zusammengefa·t und in einem Symbol abgelegt, das man dann als Argu-
ment fÅr die Pseudobefehle SBIT0, SBIT1, CMPBIT, JBIT0 und JBIT1
verwenden kann.  Diese werden in die Befehle OR, AND, XOR, BTJZ und
BTJO mit einer passenden Bitmaske Åbersetzt.

An diesen Bit-Symbolen ist Åberhaupt nichts geheimnisvolles, es han-
delt sich um schlichte Integerwerte, in deren unterer HÑlfte die
Speicheradresse und in deren oberer HÑlfte die Bitstelle gespeichert
wird.  Man kînnte sich seine Symbole also auch ohne weiteres selber
basteln:

defbit  macro   name,bit,adr
name	equ	adr+(bit<<16)
	endm

aber mit dieser Schreibweise erreicht man nicht den EQU-artigen Stil,
den Texas vorgegeben hat (d.h. das zu definierende Symbol steht an-
stelle eines Labels).  ACHTUNG!  Obwohl DBIT eine beliebige Adresse
zulÑ·t, kînnen fÅr die Pseudobefehle nur die Adressen 0..255 und
1000h..10ffh verwendet werden, eine absolute Adressierungsart kennt
der Prozessor an dieser Stelle nicht...


        4.32. MSP430
        ------------

Der MSP430 wurde als RISC-Prozessor mit minimalem Stromverbrauch 
konzipiert.  Aus diesem Grund ist der Satz von Befehlen, die der
Prozessor in Hardware versteht, auf das absolut notwendige reduziert 
worden (da RISC-Prozessoren keinen Mikrocode besitzen, mu· jeder 
Befehl mit zusÑtzlichem Silizium implementiert werden und erhîht so
den Stromverbrauch).  Eine Reihe von Befehlen, die bei anderen 
Prozessoren in Hardware gegossen wurden, werden beim MSP durch eine 
Emulation mit anderen Befehlen realisiert.  Bei AS finden sich diese 
Befehle mit in der Datei REGMSP.INC.  Wer diese Datei nicht einbindet, 
wird bei Åber der HÑlfte der insgesamt von TI definierten Befehle 
Fehlermeldungen bekommen!!


	4.32. COP8
        ----------

Leider Gottes hat sich auch National dazu entschieden, als Schreib-
weise fÅr nichtdezimale Integer-Konstanten die von IBM-Gro·rechnern
bekannte (und von mir vielgeha·te) Variante X'... zu benutzen.  Das
geht natÅrlich (wie immer) nicht.  Zum GlÅck scheint der ASMCOP aber
auch die C-Variante zuzulassen, und diese wurde deshalb der Default
fÅr die COPs...


        4.33. 75K0
        ----------

Wie bei einigen anderen Prozessoren auch, kennt die Assemblersprache
der 75er von NEC Pseudo-Bitoperanden, d.h. man kann einem Symbol
eine Kombination aus Adresse und Bitnummer zuweisen, die dann bei
bitorientierten Befehlen anstelle direkter AusdrÅcke verwendet werden
kann.  Die drei folgenden Befehle erzeugen daher z.B. identischen
Code:

ADM	sfr     0fd8h
SOC     bit     ADM.3

        skt     0fd8h.3
        skt     ADM.3
        skt     SOC

AS unterscheidet direkte und symbolische Bitzugriffe an einem
bei Symbolen fehlenden Punkt; Punkte in Symbolnamen darf man daher
nicht verwenden, da es sonst zu Mi·verstÑndnissen bei der Auflîsung
kommt.

Die Ablage von Bitsymbolen orientiert sich dabei weitgehend an der
binÑren Kodierung, die die Prozessorhardware selber verwendet:  Es
werden 16 Bit belegt, und es existieren ein "kurzes" und ein "langes"
Format.  Das kurze Format kann folgende Varianten aufnehmen:

 - direkte Zugriffe auf die Bereiche 0FBxH und 0FFxH
 - indirekte Zugriffe der Form Adr.@L (0FC0H <= Adr <= 0FFFH)
 - indirekte Zugriffe der Form @H+d4.bit

Das obere Byte ist auf 0 gesetzt, das untere Byte enthÑlt den gemÑ·
[NEC75] kodierten Bitausdruck.  Das lange Format kennt im Gegensatz
dazu nur direkte Adressierung, kann dafÅr aber (korrekte Einstel-
lungen von MBS und MBE vorausgesetzt) den ganzen Adre·raum abdek-
ken.  Bei langen AusdrÅcken stehen im unteren Byte Bit 7..0 der
Adresse, in Bit 8 und 9 die Bitstelle sowie in Bit 10 und 11
konstant 01.  Letztere ermîglichen es, langes und kurzes Format
einfach durch einen Vergleich des oberen Bytes gegen Null zu
unterscheiden.  Die Bits 12..15 enthalten Bit 8..11 der Adresse;
sie werden zwar nicht zur Generierung des Kodes benîtigt, mÅssen
jedoch gespeichert werden, da eine PrÅfung auf ein korrektes Banking
erst bei der Verwendung des Symboles erfolgen kann.


	4.34. 78K0
        ----------

NEC benutzt in seinen DatenbÅchern zur Kennzeichnung der Zugriffsweise
auf absolute Adressen verschiedene Schreibweisen:

 - absolut kurz: kein PrÑfix
 - absolut lang: vorangestelltes !
 - PC-relativ: vorangestelltes $

Bei AS sind diese PrÑfixe nur notwendig, falls man eine bestimmte 
Adressierung erzwingen will und der Befehl verschiedene Varianten
zulÑ·t.  Setzt man keinen PrÑfix, so wÑhlt AS automatisch die kÅr-
zeste Variante.  Es dÅrfte daher in der Praxis sehr selten notwendig
sein, einen PrÑfix zu verwenden.


	5. Dateiformat
	==============

Das vom Assembler ausgegebene Codedatenformat mu· in der Lage sein,
die Codeteile fÅr unterschiedliche Prozessoren voneinander zu tren-
nen, und sieht daher etwas anders aus als gÑngige Formate.  Obwohl
dem Assembler Tools zur Bearbeitung der Codedateien beiliegen, hal-
te ich es fÅr guten Stil, das Format hier kurz offenzulegen:

Sofern in der Datei Mehrbyte-Integers gespeichert sind, werden sie
im Intelformat abgelegt, d.h. mit dem LSB zuerst.  Diese Regel gilt
bereits fÅr das 16-Bit-Kennungswort mit dem Wert $1489, d.h. jede
Codedatei beginnt mit den Bytes $89/$14.

Danach folgt eine Reihe beliebig vieler "Records", wobei ein Record
entweder ein zusammenhÑngendes Teilfeld des Codes darstellt oder be-
stimmte Zusatzinformationen enthÑlt.  Eine Datei kann auch ohne 
Umschaltung des Prozessortyps mehrere Code-Records enthalten, wenn
Code- oder Konstantenbereiche durch reservierte (und nicht zu initia-
lisierende) Speicherbereiche unterbrochen werden.  Der Assembler ver-
sucht auf diese Weise, die Datei nicht lÑnger als nîtig werden zu las-
sen.

Allen Records ist gemein ist ein Header-Byte, das den Typ des Records
und die damit folgenden Datenstrukturen festlegt.  In einer Pascal-
artigen Form lÑ·t sich die Record-Struktur folgenderma·en beschreiben:

FileRecord = RECORD CASE Header:Byte OF
              $00:(Creator:ARRAY[] OF Char);
              $01..
              $7f:(StartAdr : LongInt;
                   Length   : Word;
                   Data     : ARRAY[0..Length-1] OF Byte);
              $80:(EntryPoint:LongInt);
              $81:(Header   : Byte;
                   Segment  : Byte;
                   Gran     : Byte;
                   StartAdr : LongInt;
                   Length   : Word;
                   Data     : ARRAY[0..Length-1] OF Byte);
             END

Was in dieser Schreibweise nicht ganz zum Ausdruck kommt, ist, da·
die LÑnge von Datenfeldern variabel ist und von Length abhÑngt.

Ein Record mit einem Header-Byte von $81 ist ein Record, der Code
oder Daten aus beliebigen Segmenten beinhalten kann.  Das erste
Byte (Header) gibt an, fÅr welche Prozessorfamilie die folgenden
Daten bzw. der folgende  Code bestimmt ist:  

    Header  Familie               Header  Familie

    $01     680x0, 683xx          $05     PowerPC
    $09     DSP56000              $11     65xx/MELPS-740
    $12     MELPS-4500            $13     M16
    $14     M16C                  $19     65816/MELPS-7700      
    $21     MCS-48                $29     29xxx                 
    $31     MCS-51                $39     MCS-96
    $3b     AVR                   $3c     XA
    $41     8080/8085             $42     8086..V35
    $49     TMS370xxx             $4a     MSP430
    $4c     80C166/167            $51     Z80/180/380
    $52     TLCS-900              $53     TLCS-90
    $54     TLCS-870              $55     TLCS-47
    $56     TLCS-9000             $61     6800, 6301 oder 6811
    $62     6805/HC08             $63     6809
    $64     6804                  $65     68HC16
    $66     68HC12                $68     H8/300(H)
    $69     H8/500                $6c     SH7000
    $6f     COP8                  $70     PIC16C8x
    $71     PIC16C5x              $72     PIC17C4x
    $73     (reserviert)          $74     TMS3201x
    $75     TMS320C2x             $76     TMS320C3x
    $77     TMS320C5x             $78     ST62xx
    $79     Z8                    $7a     ÊPD78(C)10
    $7b     75K0                  $7c     78K0

Das Segment-Feld gibt an, in welchen Adre·raum des Prozessors der 
folgende Code gehîrt.  Dabei gilt folgende Zuordnung:

    Nummer  Segment               Nummer  Segment

    $00     <undefiniert>         $01     CODE
    $02     DATA                  $03     IDATA
    $04     XDATA                 $05     YDATA
    $06     BDATA                 $07     IO

Das Gran-Feld gibt die "GranularitÑt" des Codes an, d.h. die Grî·e 
der kleinsten, adressierbaren Einheit im folgenden Datensatz.  Dieser
Wert ist eine Funktion von Prozessortyp und Segment und ein wichtiges
Detail fÅr die Interpretation der beiden folgenden Felder, die Start-
adresse und LÑnge angeben: WÑhrend die Startadresse sich auf die 
GranularitÑt bezieht, erfolgt die LÑngenangabe immer in Bytes!  WÑre
die Startadresse z.B. $300 und die LÑnge 12, so wÑre die sich ergeben-
de Endadresse bei einer GranularitÑt von 1 $30b, bei einer Granulari-
tÑt von z.B. 4 jedoch $303!  Andere GranularitÑten als eins sind sel-
ten und treten in erster Linie bei Signalprozessoren auf, die nicht 
auf Einzelbyteverarbeitung ausgelegt sind deren Datenspeicher z.B.
aus 64kWorten zu 16 Bit besteht (DSP56K).  Der sich ergebende Spei-
cherplatz betrÑgt dann zwar 128 KByte, er ist aber in 2^16 Worten
organisiert, die mit Adressen von 0,1,2,...65535 adressiert werden!

Die Startadresse ist immer 32-bittig, unabhÑngig von der Adre·breite
der jeweiligen Prozessorfamilie.  Im Gegensatz dazu ist die LÑngenan-
gabe nur 16 Bit lang, ein Record kann also maximal (4+4+2+(64K-1)) = 
65545 Byte lang werden.

Daten-Records mit den Header-Bytes $01..$7f stellen eine Kurzschreib-
weise dar und stellen die AbwÑrtskompatibilitÑt mit fr"uheren Defini-
tionen des Dateiformats her: Das Header-Byte gibt direkt den Pro-
zessortyp gemÑ· der ersten Tabelle an, das Zielsegment ist auf CODE
festgelegt und die GranularitÑt ergibt sich aus dem Prozessortyp, auf-
gerundet auf eine Zweierpotenz von Bytes.  AS bevorzugt diese Records, 
wenn Daten bzw. Code fÅr das CODE-Segment anstehen.

Der Record mit dem Typ-Byte $80 legt den Einsprungpunkt fest, d.h.
die Adresse, an der mit der AusfÅhrung des Programmes begonnen werden
soll.  Ein solcher Record ist das Ergebnis einer END-Anweisung mit
einer entsprechenden Adresse als Argument.

Der letzte Record in der Datei trÑgt das Header-Byte $00 und besitzt
als einziges Datenfeld einen String, dessen Ende durch das Dateiende
definiert ist.  Dieser String spezifiziert, von welchem Programm diese
Datei erzeugt wurde und hat keine weitere Bedeutung.


	6. Hilfsprogramme
	=================

Um die Arbeit mit dem Codeformat des Assemblers etwas zu erleichtern,
lege ich einige Progamme zu deren Bearbeitung bei.  FÅr diese Pro-
gramme gilt sinngemÑ· das gleiche wie in 1.1. !

Allen Programmen gemeinsam sind die Returncodes, die sie liefern:

Returncode   tritt auf bei...

0            kein Fehler
1            Kommandozeilenparameterfehler
2	     I/O-Fehler
3            Dateiformatfehler

Alle Programme lesen wie AS ihre Eingaben von STDIN und schreiben
Meldungen auf STDOUT (bzw. Fehlermeldungen auf STDERR).  Ein-und
Ausgaben sollten sich daher problemlos umleiten lassen.

Sofern Programme im folgenden Zahlen-oder Adre·angaben von der Kom-
mandozeile lesen, dÅrfen diese auch hexadezimal geschrieben werden,
indem man sie mit einem voranstehenden Dollarzeichen versieht (z.B.
$10 anstelle von 16).

Ansonsten folgen die Aufrufkonventionen und -variationen (bis auf
PLIST und AS2MSG) denen von AS, d.h. man kann dauernd gebrauchte
Schalter in einer Environmentvariablen ablegen (deren Name sich aus
dem AnhÑngen von CMD an den Programmnamen ergibt, z.B. BINDCMD fÅr
BIND), Optionen negieren und Gro·-bzw. Kleinschreibung erzwingen
(nÑheres zu dem Wie in Kapitel 2.1).

Sofern Adre·angaben benutzt werden, beziehen sie sich immer auf die
GranularitÑt des Adre·raumes des jeweiligen Prozessors; beim PIC
bedeutet z.B. eine Adre·differenz von 1 nicht ein Byte, sondern ein
Wort.


        6.1. PLIST
	----------

PLIST ist das einfachste Programm der vier mitgelieferten; es dient
einfach nur dazu, die in einer Codedatei gespeicherten Records aufzu-
listen.  Da das Programm nicht allzuviel bewirkt, ist der Aufruf
ziemlich simpel:

    PLIST <Dateiname>

Der Dateiname wird automatisch um die Endung P erweitert, falls keine
Endung vorhanden ist.

ACHTUNG! An dieser Stelle sind keine Jokerzeichen erlaubt! Falls mit
einem Befehl trotzdem mehrere Programmdateien gelistet werden sollen,
kann man sich mit folgendem "Minibatch" behelfen:

    for %n in (*.p) do plist %n

PLIST gibt den Inhalt der Codedatei in Tabellenform aus, wobei fÅr
jeden Record genau eine Zeile ausgegeben wird.  Die Spalten haben
dabei folgende Bedeutung:

Codetyp      : die Prozessorfamilie, fÅr die der Code erzeugt wurde.

Startadresse : absolute Speicheradresse, an die der Code zu laden ist.

LÑnge        : LÑnge des CodestÅcks in Byte.

Endadresse   : letzte absolute Adresse des CodestÅcks.  Diese berech-
               net sich als Startadresse+LÑnge-1.

Alle Angaben sind als hexadezimal zu verstehen.

Zuletzt gibt PLIST noch einen Copyrightvermerk aus, sofern er einen
solchen in der Datei findet, und die Summe aller CodelÑngen.

PLIST ist praktisch ein DIR fÅr Codedateien.  Man kann es benutzen,
um sich den Inhalt einer Datei auflisten zu lassen, bevor man sie
weiterbearbeitet.



        6.2. BIND
        ---------

BIND ist ein Programm, mit dem man die Records mehrerer Codedateien
in eine Datei zusammenkopieren kann.  Die dabei vorhandene Filter-
funktion erlaubt es aber auch, nur Records eines bestimmten Typs
zu Åbernehmen.  Auf diese Weise kann BIND auch dazu verwendet wer-
den, um eine Codedatei in mehrere aufzuspalten.

Die allgemeine Syntax von BIND lautet

   BIND <Quelldatei(en)> <Zieldatei> [Optionen]

Wie auch AS betrachtet BIND alle nicht mit einem - oder / eingelei-
teten Parameter als Dateiangaben, von denen die letzte die Zieldatei
angeben mu·.  Alle anderen Dateiangaben bezeichnen Quellen, diese
Angaben dÅrfen auch wieder Jokerzeichen enthalten.

An Optionen definiert BIND momentan nur eine:

 f <Header[,Header...]> : gibt eine Liste von Recordtypen an, die
                          kopiert werden sollen.  Alle anderen
			  Records werden nicht kopiert.  Ohne die-
			  se Angabe werden alle Records kopiert.
			  Die in der Liste angegebenen entsprechen
			  dem Typfeld in der Recordstruktur, wie
			  es in Punkt 4 beschrieben wurden. Die ein-
                          zelnen Typnummern in der Liste werden durch
                          Kommas getrennt.

Um z.B. alle MCS-51-Codeteile aus einer Programmdatei auszusieben,
benutzt man BIND folgenderma·en:

   BIND <Quellname> <Zielname> -f $31

Fehlt bei einer Dateiangabe eine Endung, so wird automatisch die En-
dung P angefÅgt.



	6.3. P2HEX
	----------

P2HEX ist eine Erweiterung von BIND.  Es besitzt alle Kommandozeilen-
optionen von BIND und hat die gleichen Konventionen bzgl. Dateinamen.
Im Gegensatz zu BIND wird die Zieldatei aber als Hexfile ausgegeben,
d.h. als eine Folge von Zeilen, die den Code als ASCII-Hexzahlen ent-
halten.

P2HEX kennt 7 verschiedene Zielformate, die Åber den Kommandozeilen-
parameter F ausgewÑhlt werden kînnen:

 - Motorola S-Record ( -F Moto)
 - MOS Hex ( -F MOS)
 - Intel-Hex (Intellec-8, -F Intel)
 - 16-Bit Intel-Hex (MCS-86, -F Intel16)
 - 32-Bit Intel-Hex (-F Intel32)
 - Tektronix Hex (-F Tek)
 - Texas Instruments DSK (-F DSK)

Wird kein Zielformat explizit angegeben, so wÑhlt P2HEX anhand des
Prozessortyps automatisch eines aus, und zwar S-Records fÅr Motorola-
Prozessoren, Hitachi und TLCS-900, MOS fÅr 65xx/MELPS, DSK fÅr die
16-Bit-Texas-Signalprozessoren und Intel-Hex fÅr den Rest.  Je nach
Breite der Startadresse kommen bei S-Record Records der Typen 1,2
oder 3 zum Einsatz, jedoch nie in einer Gruppe gemischt.
Die Intel-, Tektronix-und MOS-Formate sind auf 16 Bit-Adressen be-
schrÑnkt, das 16-Bit Intel-Format reicht 4 Bit weiter.  LÑngere Adres-
sen werden von P2HEX mit einer Warnung gemeldet und abgeschnitten (!).

För die PICs und kînnen die drei von Microchip spezifizierten Varian-
ten des Intel-Hex-Formates erzeugt werden, und zwar mit dem Schalter

 m <0..3>

Das Format 0 ist INHX8M, in dem alle Bytes in Lo-Hi-Ordnung enthalten
sind.  Die Adre·angaben verdoppeln sich, weil bei den PICs die Adres-
se sich nur um 1 pro Wort erhîht.  Dieses Format ist gleichzeitig die
Vorgabe.  Im Format 1 (INHX16M) werden alle Worte in ihrer natÅrli-
chen Ordnung abgelegt.  Dieses Format verwendet Microchip fÅr seine
eigenen ProgramiergerÑte.  Format 2 (INHX8L) und 3 (INHX8H) trennen
die Worte in ihre oberen und unteren Bytes auf.  Um die komplette In-
formation zu erhalten, mu· P2HEX zweimal aufgerufen werden, z.B. so:

  p2hex test -m 2
  rename test.hex test.obl
  p2hex test -m 3
  rename test.hex test.obh

FÅr das Motorola-Format verwendet P2HEX zusÑtzlich einen in [CPM68K]
genannten Recordtyp mit der Nummer 5, der die Zahl der folgenden
Daten-Records (S1/S2/S3) bezeichnet.  Da dieser Typ vielleicht nicht
jedem Programm bekannt ist, kann man ihn mit der Option

 +5

unterdrÅcken.

Finden sich Coderecords verschiedener Prozessoren in einer Quelldatei,
so erscheinen die verschiedenen Hexformat auch gemischt in der Ziel-
datei - es empfiehlt sich also dringend, von der Filterfunktion Ge-
brauch zu machen.

Neben dem Codetypenfilter kennt P2HEX noch ein Adre·filter, das nÅtz-
lich ist, falls der Code auf mehrere EPROMs verteilt werden mu·:

 r <Startadresse>-<Endadresse>

Die Startadresse ist dabei die erste Speicherzelle, die im Fenster
liegen soll, die Endadresse die der letzten Speicherzelle im Fenster,
NICHT die der ersten au·erhalb.  Um z.B. ein 8051-Programm in 4 2764-
EPROMs aufzuteilen, geht man folgenderma·en vor:

p2hex <Quelldatei> eprom1 -f $31 -r $0000-$1fff
p2hex <Quelldatei> eprom2 -f $31 -r $2000-$3fff
p2hex <Quelldatei> eprom3 -f $31 -r $4000-$5fff
p2hex <Quelldatei> eprom4 -f $31 -r $6000-$7fff

DefaultmÑ·ig ist das Fenster 32 kByte gro· und beginnt bei Adresse 0.

ACHTUNG! Die Splittung Ñndert nichts an den absoluten Adressen, die
in den Hexfiles stehen!  Sollen die Adressen im Hexfile bei 0 begin-
nen, so kann man dies durch den zusÑtzlichen Schalter

 a

erreichen.

Als Sonderwerte fÅr Start-und Endadresse beim r-Parameter ist ein
schlichtes Dollar-Zeichen ($) erlaubt.  Diese kennzeichnet die erste
bzw. letzte in der Programmdatei belegte Adresse.  Wer also sicher
sein will, da· immer das ganze Programm in der Hex-Datei abgelegt
wird, braucht sich mit dem Schalter

 -r $-$

keine Gedanken mehr zu machen.  Dollarzeichen und feste Adressen
lassen sich selbstverstÑndlich auch gemischt verwenden, z.B. kann
mit

 -r $-$7fff

das obere Ende auf die ersten 32K begrenzt werden.

Den Inhalt einer Datei kann man mit einem Offset auf eine beliebige
Position verschieben; diesen Offset hÑngt man einfach in Klammern an
den Dateinamen an.  Ist der Code in einer Datei z.B. auf Adresse 0 in
der P-Datei abgelegt, man mîchte ihn jedoch auf Adresse 1000h
verschieben, so hÑngt man an ($1000) an den Dateinamen (ohne
Leerzeichen!) an.

Da das TI-DSK-Format Daten und Code unterscheiden kann, lÑ·t sich
mit dem Schalter

 -d <Start>-<Ende>

festlegen, welche Adre·bereiche als Daten ausgegeben werden sollen.
Dollarzeichen sind hier NICHT zugelassen.  FÅr das DSK- sowie
Intel- und Motorola-Format relevant ist dagegen die Option

 -e <Adresse> ,

mit der man die in die Hex-Datei einzutragende Startadresse fest-
legen kann.  Fehlt diese Angabe, so wird nach einen entsprechenden
Eintrag in der Code-Datei gesucht.  Ist auch dort kein Hinweis auf
einen Einsprungpunkt zu finden, so wird kein Eintrag in die HEX-Datei
geschrieben (DSK/Intel) bzw. das entsprechende Feld wird auf 0 gesetzt
(Motorola).

Leider ist sich die Literatur nicht ganz Åber die Endezeile fÅr Intel-
Hexfiles einig.  P2HEX kennt daher 3 Varianten, einstellbar Åber den
Parameter i mit einer nachfolgenden Ziffer:

 0  :00000001FF
 1  :00000001
 2  :0000000000

Fehlt der Zieldateiangabe eine Endung, so wird HEX als Endung ange-
nommen.

DefaultmÑ·ig gibt P2HEX pro Zeile maximal 16 Datenbytes aus, wie es
auch die meisten anderen Tools tun, die Hex-Files erzeugen.  Wollen
Sie dies Ñndern, so kînnen Sie dies mit dem Schalter

 l <Anzahl>

tun.  Der erlaubte Wertebereich liegt dabei zwischen 2 und 254 Daten-
bytes; ungerade Werte werden implizit auf gerade Anzahlen aufgerundet.

Anders als BIND erzeugt P2HEX keine Leerdatei, wenn nur ein Dateina-
me (=Zieldatei) angegeben wurde, sondern bearbeitet die dazugehîrige
Codedatei.  Es ist also ein Minimalaufruf a la

 P2HEX <Name>

mîglich, um <Name>.HEX aus <Name>.P zu erzeugen.


	6.4. P2BIN
	----------

P2BIN funktioniert wie P2HEX und bietet die gleichen Optionen (bis
auf die a- und i-Optionen, die bei BinÑrdateien keinen Sinn ergeben),
nur wird das Ergebnis nicht als Hexdatei, sondern als einfache Bi-
nÑrdatei abgelegt.  Dies kann dann z.B. direkt in ein EPROM gebrannt
werden.

Zur Beeinflussung der BinÑrdatei kennt P2BIN gegenÅber P2HEX noch
zwei weiter Optionen:

 l <8-Bit-Zahl>   :  gibt den Wert an, mit dem unbenutzte Speicher-
		     stellen in der Datei gefÅllt werden sollen.
                     DefaultmÑ·ig ist der Wert $ff, so da· ein halb-
                     wegs intelligenter EPROM-Brenner sie Åber-
		     springt.  Man kann aber hiermit auch andere Wer-
                     te einstellen, z.B. enthalten die gelîschten
                     Speicherzellen der MCS-48-EPROM-Versionen Nul-
		     len.  In einem solchen Falle wÑre 0 der richti-
		     ge Wert.

 s                :  weist das Programm an, eine PrÅfsumme Åber die
       		     BinÑrdatei zu berechnen.  Die PrÅfsumme wird
		     einmal als 32-Bit-Wert ausgegeben, zum anderen
		     wird das Zweierkomplement der Bits 0..7 in der
		     letzten Speicherstelle abgelegt, so da· die Mo-
		     dulo-256-Summe zu 0 wird.

 m                :  fÅr den Fall, da· ein Prozessor mit 16- oder
                     32-Bit-Datenbus eingesetzt wird und die BinÑr-
		     datei fÅr mehrere EPROMs aufgesplittet werden
		     mu·.  Das Argument kann folgende Werte annneh-
		     men:

		     ALL    : alles kopieren
		     ODD    : alle Bytes mit ungerader Adresse ko-
			      pieren
                     EVEN   : alle Bytes mit gerader Adresse ko-
                              pieren
		     BYTE0..: nur alle Bytes kopieren, deren Adres-
		     BYTE3    die Form 4n+0 .. 4n+3 hat.
		     WORD0, : nur das untere bzw. obere 16-Bit-Wort
		     WORD1    der 32-Bit-Worte kopieren.

		     Nicht wundern: Bei diesen Optionen ist die Bi-
                     nÑrdatei um den Faktor 2 oder 4 kleiner als bei
		     ALL.  Dies ist bei konstantem Adre·fenster lo-
                     gisch.



	6.5. AS2MSG
	-----------

Bei AS2MSG handelt es sich eigentlich um kein Hilfsprogramm, sondern
um ein Filter, das (glÅcklichen) Besitzern von Borland-Pascal 7.0 das
Arbeiten mit dem Assembler erleichtern soll.  In den DOS-Arbeitsumge-
bungen existiert ein "Tools"-MenÅ, das man um eigene Programme, z.B.
AS erweitern kann.  Das Filter erlaubt, die von AS gelieferten Fehler-
meldungen mit Zeilenangabe direkt im Editorfenster anzuzeigen.  Dazu
mu· im Tools-MenÅ ein neuer Eintrag angelegt werden (Options/Tools/New).
Tragen Sie in die einzelnen Felder folgende Werte ein :

 - Title: ~M~akroassembler
 - Program path: AS
 - Command line: -E !1 $EDNAME $CAP MSG(AS2MSG) $NOSWAP $SAVE ALL
 - bei Bedarf einen Hotkey zuordnen (z.B. Shift-F7)}

Die Option -E sorgt dafÅr, da· Turbo-Pascal nicht mit STDOUT und
STDERR durcheinander kommt.

Ich setze dabei voraus, da· sowohl AS als auch AS2MSG sich in einem
Verzeichnis befinden, welches in der Pfadliste aufgefÅhrt ist.  Nach
einem Druck auf dem passenden Hotkey (oder Auswahl aus dem Tools-
MenÅ) wird AS mit dem Namen der Textdatei im aktiven Editorfenster
aufgerufen.  Die dabei aufgetretenen Fehler werden in ein separates
Fenster geleitet, durch das man nun "browsen" kann.  Mit Ctrl-Enter
springt man eine fehlerhafte Zeile an.  ZusÑtzlich enthÑlt das
Fenster die Statistik, die AS am Ende der Assemblierung ausgibt.
Diese erhalten als Dummy-Zeilennummer 1.

FÅr diese Arbeitsweise sind sowohl TURBO.EXE (Real Mode) als auch
BP.EXE (Protected Mode) geeignet.  Ich empfehle BP, da in dieser Va-
riante beim Aufruf nicht erst der halbe DOS-Speicher "freigeswappt"
werden mu·.


			--- AnhÑnge ---


        A. Fehlermeldungen von AS
	=========================

Im folgenden findet sich eine halb-tabellarische Auflistung der in
AS definierten Fehlermeldungen.  Zu jeder Fehlermeldung finden sich
folgende Angaben:

 - interne Fehlernummer (fÅr den Anwender nur mit der n-Option sichtbar);
 - Fehlermeldung im Klartext;
 - Typ       :
   - Warnung   : zeigt mîgliche Fehler oder ineffizienten Code an.
                 Assemblierung geht weiter.
   - Fehler    : echte Fehler.  Assemblierung geht weiter, aber keine
                 Code-Datei wird geschrieben.
   - fatal     : schwerwiegende Fehler.  Assemblierung wird abge-
                 brochen.
 - Ursache   : die Situation(en), in denen der Fehler ausgegeben wird;
 - Argument  : Die Ausgabe, die auf Wunsch als erweiterte Fehlermel-
	       dung erfolgt.

   0 Displacement=0, ÅberflÅssig

        Fehlertyp:
	   Warnung
        Ursache:
	   bei 680x0-, 6809 und COP8-Prozessoren: Das Displacement
	   in einem Adre·ausdruck hat den Wert 0 ergeben.  Es wird
           ein  Adre·ausdruck  ohne Displacement erzeugt.  Um keine
           Phasenfehler zu erzeugen, werden NOP-Befehle eingefÅgt.
        Argument:
        keines


  10 Kurzadressierung mîglich

	Fehlertyp:
           Warnung
	Ursache:
           bei 680x0-, 6502- und 68xx-Prozessoren kînnen
	   bestimmte Speicherbereiche mit kurzen Adressen erreicht
           werden.  Um keine Phasefehler zu erzeugen, wird zwar der
	   kÅrzere Ausdruck erzeugt, der freie Platz wird aber mit
	   NOPs aufgefÅllt.
        Argument:
	   keines


  20 kurzer Sprung mîglich

	Fehlertyp:
	   Warnung
        Ursache:
           Bei 680x0 und 8086-Prozessoren kann der Sprung
           sowohl mit langem als auch kurzem Displacement ausgefÅhrt
           werden.  Da kein kurzer Sprung angefordert wurde, wurde im
           ersten Pass Platz fÅr den langen Sprung freigehalten.
	   Es wird ein kurzer Sprung erzeugt, der freie Platz wird
	   mit NOPs aufgefÅllt, um Phasenfehler zu vermeiden.
	Argument:
           keines


  30 kein Sharefile angelegt, SHARED ignoriert

        Fehlertyp:
	   Warnung
	Ursache:
	   Es wurde eine SHARED-Anweisung gefunden, es wurde aber
           keine Kommandozeilenoption angegeben, um eine Shared-Datei
           zu erzeugen.
        Argument:
           keines


  40 FPU liest Wert evtl. nicht korrekt ein (>=1E1000)

        Fehlertyp:
	   Warnung
        Ursache:
	   Das BCD-Gleitkommaformat der 680x0-Koprozessoren erlaubt
           zwar vierstellige Exponenten, lt. Datenbuch kînnen solche
	   Werte aber nicht korrekt eingelesen werden.  Der vierstel-
	   lige Wert wird zwar erzeugt, eine Funktion ist aber nicht
           gewÑhleistet.
        Argument:
           keines


  50 Privilegierte Anweisung

	Fehlertyp:
           Warnung
        Ursache:
           Es wurde eine Anweisung benutzt, die nur im Supervisor-Mode
           zulÑssig ist, obwohl dieser nicht mittels SUPMODE ON vorher
           explizit angezeigt wurde.
        Argument:
	   keines


  60 Distanz 0 nicht bei Kurzsprung erlaubt (NOP erzeugt)

	Fehlertyp:
           Warnung
        Ursache:
	   Ein kurzer Sprung mit der Distanz 0 ist bei 680x0-Prozesso-
	   ren nicht erlaubt, da dieser Sonderwert fÅr lange SprÅnge
	   benîtigt wird.  Stattdessen wurde ein NOP-Befehl eingefÅgt.
        Argument:
	   keines


  70 Symbol aus falschem Segment

	Fehlertyp:
           Warnung
        Ursache:
           Das in dem Operanden benutzte Symbol ist aus einem Adre·-
           raum, der nicht mit dem benutzten Befehl bearbeitet werden
	   kann.
        Argument:
	   keines


  75 Segment nicht adressierbar

        Fehlertyp:
           Warnung
	Ursache:
	   Das in dem Operanden benutzte Symbol ist aus einem Adre·-
	   raum, der mit keinem der Segmentregister des 8086 adres-
           siert werden kann.
        Argument:
           Der Name des nicht adressierbaren Segments


  80 énderung des Symbolwertes erzwingt zusÑtzlichen Pass

	Fehlertyp:
	   Warnung
	Ursache:
	   Ein Symbol hat im einen anderen Wert zugewiesen bekommen
	   als im vorhergehenden Pass.  Diese Warnung wird nur aus-
	   gegeben, falls die r-Option angegeben wurde.
	Argument:
	   Name des fraglichen Symbols


  90 öberlappende Speicherbelegung

	Fehlertyp:
           Warnung
	Ursache:
	   Bei der Bildung der Belegungsliste wurde festgestellt, da·
           ein Speicherbereich im Codesegment mehrfach benutzt wurde.
           Ursache kînnen unÅberlegte ORG-Anweisungen sein.
        Argument:
           keines


 100 keine CASE-Bedingung zugetroffen

	Fehlertyp:
           Warnung
	Ursache:
           bei einem SWITCH..CASE-Konstrukt ohne ELSECASE-Zweig traf
           keiner der CASE-Zweige zu.
        Argument:
	   keines


 110 Seite mîglicherweise nicht adressierbar

        Fehlertyp:
           Warnung
        Ursache:
	   Das in dem Operanden benutzte Symbol liegt nicht in der
	   momentan mit ASSUME eingestellten Fenster (ST62xx,78(C)10).
        Argument:
           keines


 120 Registernummer mu· gerade sein

	Fehlertyp:
	   Warnung
        Ursache:
           Die Hardware erlaubt nur ein Registerpaar zu verketten,
           dessen Startadresse gerade ist (RR0, RR2..., nur Z8).
        Argument:
	   keines


 130 veralteter Befehl

	Fehlertyp:
	   Warnung
	Ursache:
	   Der verwendete Befehl ist zwar noch definiert, ist in
	   seiner Funktion aber durch andere, neue Befehle ersetzbar
	   und daher in zukÅnftigen Prozessorversionen eventuell
	   nicht mehr vorhanden.
	Argument:
	   keines

 140 Nicht vorhersagbare AusfÅhrung dieser Anweisung

	Fehlertyp:
	   Warnung
	Ursache:
	   Die verwendete Adressierungsart ist bei diesem Befehl zwar
	   prinzipiell erlaubt, ein Register wird jedoch in einer
	   Weise doppelt verwendet, da· je nach AusfÅhrungsreihen-
	   folge sich unterschiedliche Ergebnisse einstellen kînnen.
	Argument:
	   keines

 150 Lokaloperator au·erhalb einer Sektion ÅberflÅssig

	Fehlertyp:
	   Warnung
	Ursache:
	   Ein vorangestellter Klammeraffe dient dazu, sich explizit
	   auf zu der Sektion lokale Symbole zu beziehen.  Wenn man
	   sich au·erhalb einer Sektion befindet, gibt es keine
	   lokalen Symbole, weshalb dieser Operator ÅberflÅssig ist.
	Argument:
	   keines

 160 sinnlose Operation

	Fehlertyp:
	   Warnung
	Ursache:
	   Die Anweisung ergibt entweder Åberhaupt keine Sinn oder
	   kann auf andere Weise schneller und kÅrzer ausgefÅhrt
	   werden.
	Argument:
	   keines

 170 unbekannter Symbolwert erzwingt zusÑtzlichen Pass

	Fehlertyp:
	   Warnung
	Ursache:
	   AS vermutet eine VorwÑrtsreferenz eines Symbols, d.h. das
	   Symbol wird benutzt, bevor es definiert wurde, und hÑlt
	   einen weiteren Pass fÅr unumgÑnglich.  Diese Warnung wird
	   nur ausgegeben, falls die r-Option angegeben wurde.
	Argument:
	   Der Name des fraglichen Symbols


 180 Adresse nicht ausgerichtet

	Fehlertyp:
	   Warnung
	Ursache:
	   Eine Adresse ist nicht ein mehrfaches der Operandengrî·e.
	   Das Datenbuch verbietet zwar solche Zugriffe, im Instruk-
	   tionswort ist aber Platz fÅr diese Adresse, so da· AS es
	   bei einer Warnung belassen hat.
	Argument:
	   keines


 190 I/O-Adresse darf nicht verwendet werden

	Fehlertyp:
	   Warnung
	Ursache:
	   Der verwendete Adressierungsmodus oder die angesprochene
	   Adresse sind zwar prinzipiell erlaubt, die Adresse liegt
	   aber im Bereich der Peripherieregister, die in diesem
	   Zusammenhang nicht verwendet werden dÅrfen.
	Argument:
	   keines


 200 mîgliche Pipeline-Effekte

	Fehlertyp:
	   Warnung
	Ursache:
	   Ein Register wird in einer Befehlsfolge so verwendet, da·
	   die BefehlsausfÅhrung mîglicherweise nicht in der hinge-
	   schriebenen Form ablaufen wird.  öblicherweise wird ein
	   Register benutzt, bevor der neue Wert zur VerfÅgung steht.
	Argument:
	   das die Verklemmung verursachende Register


 210 mehrfache Adre·registerbenutzung in einer Anweisung

	Fehlertyp:
	   Warnung
	Ursache:
	   Ein Adre·register wird in mehreren Adre·ausdrÅcken eines
	   Befehls benutzt.  Sofern einer der beiden AusdrÅcke das
	   Register modifiziert, sind die Ergebnisadressen nicht
	   eindeutig festgelegt.
	Argument:
	   das mehrfach verwendete Register


 220 Speicherstelle ist nicht bitadressierbar

	Fehlertyp:
	   Warnung
	Ursache:
           Mit einer SFRB-Anweisung wurde versucht, eine Speicher-
           stelle als bitadressierbar zu deklarieren, die aufgrund
           der Architektur des 8051 nicht bitadressierbar ist.
	Argument:
	   das mehrfach verwendete Register


 230 Stack ist nicht leer

	Fehlertyp:
	   Warnung
	Ursache:
           Am Ende eines Durchlaufes ist ein vom Programm
           definierter Stack nicht leer.
	Argument:
	   der Name des Stacks sowie seine Resttiefe


 240 NUL-Zeichen in Strings, Ergebnis undefiniert

	Fehlertyp:
	   Warnung
	Ursache:
           Eine String-Konstante enthÑlt ein NUL-Zeichen. Dies funk-
           tioniert zwar mit der Pascal-Version, in Hinblick auf die
           C-Version von AS ist dies aber ein Problem, da C Strings
           mit einem NUL-Zeichen terminiert, d.h. der String wÑre
           fÅr C an dieser Stelle zu Ende...
	Argument:
           keines


1000 Symbol doppelt definiert

	Fehlertyp:
	   Fehler
        Ursache:
	   Einem Symbol wurde durch ein Label oder EQU, PORT, SFR,
	   LABEL, SFRB oder BIT ein neuer  Wert zugewiesen, dies ist
	   aber nur bei SET/EVAL erlaubt.
        Argument:
           Name des fraglichen Symbols, bei eingeschalteter Querver-
	   weisliste zusÑtzlich die Zeile der ersten Definition.


1010 Symbol nicht definiert

	Fehlertyp:
           Fehler
	Ursache:
	   Ein benutztes Symbol ist auch im 2.Pass noch nicht in der
	   Symboltabelle enthalten.
        Argument:
	   Name des nicht gefundenen Symbols


1020 UngÅltiger Symbolname

        Fehlertyp:
	   Fehler
        Ursache:
           Ein Symbolname entspricht nicht den Bedingungen fÅr einen
           gÅltigen Symbolnamen.  Beachten Sie, da· fÅr Makro-und
           Funktionsparameter strengere Regeln gelten!
        Argument:
	   der fehlerhafte Symbolname


1090 UngÅltiges Format

	Fehlertyp:
	   Fehler
	Ursache:
	   Das benutzte Befehlsformat existiert bei diesem Befehl
	   nicht (nur TLCS-9000).
	Argument:
	   Der Kennbuchstabe des verwendeten Formates


1100 öberflÅssiges Attribut

	Fehlertyp:
	   Fehler
        Ursache:
           Der benutzte Befehl (Prozessor oder Pseudo) darf kein mit
	   einem Punkt angehÑngtes Attribut haben.
	Argument:
           keines


1105 Attribut darf nur 1 Zeichen lang sein

        Fehlertyp:
           Fehler
	Ursache:
           Das mit einem Punkt an einen Befehl angehÑngte Attribut mu·
           genau ein Zeichen lang sein; weder mehr noch weniger ist
	   erlaubt.
        Argument:
	   keines


1110 Unpassende Operandenzahl

        Fehlertyp:
           Fehler
	Ursache:
           Die bei einem Befehl (Prozessor oder Pseudo) angegebene
           Operandenzahl liegt nicht in dem fÅr diesen Befehl erlaub-
           ten Bereich.
	Argument:
           keines


1115 Unpassende Operandenzahl

        Fehlertyp:
           Fehler
	Ursache:
           Die bei diesem Befehl angegebene Zahl von Optionen liegt
	   nicht in dem fÅr diesen Befehl erlaubten Bereich.
	Argument:
           keines


1120 nur immediate-Adressierung erlaubt

        Fehlertyp:
           Fehler
	Ursache:
           Der benutzte Befehl lÑ·t nur immediate-Operanden (mit vor-
	   angestelltem #) zu.
        Argument:
           keines


1130 Unpassende Operandengrî·e

	Fehlertyp:
           Fehler
        Ursache:
           Der Operand hat zwar einen fÅr den Befehl zugelassenen Typ,
           jedoch nicht die richtige LÑnge (in Bits).
        Argument:
	   keines


1131 Widersprechende Operandengrî·en

        Fehlertyp:
	   Fehler
        Ursache:
	   Die angegebenen Operanden haben unterschiedliche LÑngen (in
           Bit).
        Argument:
           keines


1132 Undefinierte Operandengrî·e

        Fehlertyp:
           Fehler
        Ursache:
           Aus Opcode und Operanden lÑ·t sich die Operandengrî·e nicht
           eindeutig bestimmen (ein Problem des 8086-Assemblers).  Sie
	   mÅssen die Operandengrî·e durch einen BYTE, WORD, usw. PTR-
           PrÑfix festlegen.
        Argument:
           keines


1135 UngÅltiger Operandentyp

	Fehlertyp:
           Fehler
        Ursache:
           Ein Ausdruck hat einen an dieser Stelle nicht zulÑssigen
	   Typ (Integer/Gleitkomma/String).
        Argument:
           Die an dieser Stelle zulÑssigen Datentypen


1140 Zuviele Argumente

        Fehlertyp:
           Fehler
	Ursache:
           Einem Befehl wurden mehr als die unter AS zulÑssigen 20
           Parameter Åbergeben.
        Argument:
           keines


1200 Unbekannter Befehl

        Fehlertyp:
           Fehler
        Ursache:
	   Der benutzte Befehl ist weder ein Pseudobefehl von AS
           noch ein Befehl des momentan eingestellten Prozessors.
        Argument:
	   keines


1300 Klammerfehler

        Fehlertyp:
	   Fehler
        Ursache:
           Der Formelparser ist auf einen (Teil-)Ausdruck gesto·en,
           in dem die Summe îffnender und schlie·ender Klammern
           nicht Åbereinstimmt.
        Argument:
	   der beanstandete (Teil-)Ausdruck


1310 Division durch 0

        Fehlertyp:
	   Fehler
        Ursache:
           Bei einer Division oder Modulooperation ergab die Auswer-
	   tung des rechten Teilausdruckes 0.
        Argument:
           keines


1315 Bereichsunterschreitung

        Fehlertyp:
           Fehler
        Ursache:
           Der angegebene Integer-Wert unterschreitet den
           zulÑssigen Bereich.
	Argument:
           aktueller Wert und zulÑssiges Minimum (manchmal,
           ich stelle das gerade um...)


1320 BereichsÅberschreitung

	Fehlertyp:
           Fehler
        Ursache:
	   Der angegebene Integer-Wert Åberschreitet den
           zulÑssigen Bereich.
        Argument:
           aktueller Wert und zulÑssiges Maximum (manchmal,
           ich stelle das gerade um...)


1325 Adresse nicht ausgerichtet

	Fehlertyp:
	   Fehler
	Ursache:
	   Die angegebene direkte Speicheradresse entspricht nicht
	   den AnsprÅchen des Datentransfers, d.h. ist nicht ein
	   mehrfaches der Operandengrî·e.  Nicht alle Prozessoren
	   erlauben unausgerichtete Datenzugriffe.
	Argument:
	   keines


1330 Distanz zu gro·

        Fehlertyp:
           Fehler
        Ursache:
           Der in einem Adre·ausdruck enthaltene Displacement-Wert
	   ist zu gro·.
        Argument:
	   keines


1340 Kurzadressierung nicht mîglich

        Fehlertyp:
           Fehler
	Ursache:
           Die Adresse des Operanden liegt au·erhalb des Speicherbe-
           reiches, in dem Kurzadressierung mîglich ist.
        Argument:
           keines


1350 Unerlaubter Adressierungsmodus

        Fehlertyp:
           Fehler
        Ursache:
	   Der benutzte Adressierungsmodus existiert generell zwar,
           ist an dieser Stelle aber nicht erlaubt.
	Argument:
	   keines


1351 Nummer mu· ausgerichtet sein

	Fehlertyp:
	   Fehler
	Ursache:
	   An dieser Stelle sind nur ausgerichtete (=gerade,..) Adressen
	   erlaubt, da die untersten Bits fÅr andere Zwecke verwendet
	   werden oder reserviert sind.
	Argument:
	   keines

1355 Adressierungsmodus im Parallelbetrieb nicht erlaubt

	Fehlertyp:
	   Fehler
	Ursache:
	   Die verwendeten Adressierungsmodi sind zwar im sequentiellen
	   Modus zulÑssig, jedoch nicht bei parallelen Instruktionen.
	Argument:
	   keines

1360 Undefinierte Bedingung

	Fehlertyp:
	   Fehler
	Ursache:
           Die benutzte Bedingung fÅr bedingte SprÅnge existiert nicht.
        Argument:
           keines


1370 Sprungdistanz zu gro·

        Fehlertyp:
           Fehler
        Ursache:
	   Sprungbefehl und Sprungziel liegen zu weit auseinander, um
           mit einem Sprung der benutzten LÑnge ÅberbrÅckt werden zu
	   kînnen.
        Argument:
           keines


1375 Sprungdistanz ist ungerade

	Fehlertyp:
	   Fehler
	Ursache:
	   Da Befehle nur auf geraden Adressen liegen dÅrfen, mu· eine
	   Sprungdistanz zwischen zwei Befehlen auch immer gerade sein,
	   das Bit 0 der Distanz wird anderweitig verwendet.  Diese
	   Bedingung ist verletzt worden.  Grund ist Åblicherweise die
	   Ablage einer ungeraden Anzahl von Daten in Bytes oder ein
	   falsches ORG.
	Argument:
	   keines


1380 ungÅltiges Schiebeargument

	Fehlertyp:
           Fehler
        Ursache:
           als Argument fÅr die Schiebeamplitude darf nur eine Kon-
           stante oder ein Datenregister verwendet werden. (nur
           680x0)
	Argument:
           keines


1390 Nur Bereich 1..8 erlaubt

	Fehlertyp:
           Fehler
	Ursache:
           Konstanten fÅr Schiebeamplituden oder ADDQ-Argumente
	   dÅrfen nur im Bereich 1..8 liegen. (nur 680x0)
        Argument:
	   keines


1400 Schiebezahl zu gro·

        Fehlertyp:
           Fehler
        Ursache:
           (nicht mehr verwendet)
	Argument:
           keines


1410 UngÅltige Registerliste

	Fehlertyp:
           Fehler
	Ursache:
           Das Registerlisten-Argument von MOVEM oder FMOVEM hat ein
           falsches Format. (nur 680x0)
        Argument:
	   keines


1420 UngÅltiger Modus mit CMP

        Fehlertyp:
           Fehler
        Ursache:
           Die verwendete Operandenkombination von CMP ist nicht er-
	   laubt. (nur 680x0)
        Argument:
           keines


1430 UngÅltiger Prozessortyp

        Fehlertyp:
	   Fehler
        Ursache:
           Den mit CPU angeforderten Zielprozessor kennt AS nicht.
        Argument:
	   der unbekannte Prozessortyp


1440 UngÅltiges Kontrollregister

        Fehlertyp:
           Fehler
        Ursache:
           Das bei MOVEC benutzte Kontrollregister  kennt der mit
	   CPU gesetzte Prozessor (noch) nicht.
        Argument:
           keines


1445 UngÅltiges Register

	Fehlertyp:
	   Fehler
	Ursache:
	   Das benutzte Register ist zwar prinzipiell vorhanden,
	   hier aber nicht erlaubt.
	Argument:
	   keines


1450 RESTORE ohne SAVE

        Fehlertyp:
	   Fehler
        Ursache:
           Es wurde ein RESTORE-Befehl gefunden, obwohl kein mit
           SAVE gespeicherter Zustand (mehr) auf dem Stapel vor-
	   handen ist.
        Argument:
           keines


1460 fehlendes RESTORE

        Fehlertyp:
           Fehler
	Ursache:
           Nach der Assemblierung sind nicht alle SAVE-Befehle
           wieder aufgelîst worden.
        Argument:
           keines

1465 unbekannte Makro-Steueranweisung

	Fehlertyp:
	   Fehler
	Ursache:
	   Eine beim MACRO-Befehl zusÑtzlich angegebene Steueran-
	   weisung ist AS unbekannt.
	Argument:
	   die fragliche Anweisung

1470 fehlendes ENDIF/ENDCASE

        Fehlertyp:
           Fehler
        Ursache:
	   Nach der Assemblierung sind nicht alle Konstrukte zur
           bedingten Assemblierung aufgelîst worden.
        Argument:
	   keines


1480 ungÅltiges IF-Konstrukt

        Fehlertyp:
	   Fehler
        Ursache:
           Die Reihenfolge der Befehle in einem IF- oder SWITCH-
           Konstrukt stimmt nicht.
        Argument:
           keines


1483 doppelter Sektionsname

        Fehlertyp:
           Fehler
	Ursache:
           Es existiert bereits eine Sektion gleichen Namens auf
           dieser Ebene.
	Argument:
           der doppelte Name


1484 unbekannte Sektion

	Fehlertyp:
           Fehler
        Ursache:
           Im momentanen Sichtbarkeitsbereich existiert keine Sektion
           dieses Namens.
        Argument:
	   der unbekannte Name


1485 fehlendes ENDSECTION

        Fehlertyp:
	   Fehler
        Ursache:
           Nach Ende eines Durchganges sind nicht alle Sektionen wie-
	   der geschlossen worden.
        Argument:
           keines


1486 falsches ENDSECTION

        Fehlertyp:
           Fehler
        Ursache:
           die bei ENDSECTION angegebene Sektion ist nicht die inner-
           ste offene.
	Argument:
           keines


1487 ENDSECTION ohne SECTION

	Fehlertyp:
           Fehler
        Ursache:
	   Es wurde ein ENDSECTION-Befehl gegeben, obwohl gar keine
           Sektion offen war.
        Argument:
           keines


1488 nicht aufgelîste VorwÑrtsdeklaration

        Fehlertyp:
           Fehler
        Ursache:
           Ein mit FORWARD oder PUBLIC angekÅndigtes Symbol wurde
	   nicht in der Sektion definiert.
        Argument:
	   der Name des fraglichen Symbols


1489 widersprechende FORWARD<->PUBLIC-Deklaration

	Fehlertyp:
           Fehler
	Ursache:
           Ein Symbol wurde sowohl als privat als auch global defi-
           niert.
        Argument:
           der Name des Symbols


1490 falsche Argumentzahl fÅr Funktion

        Fehlertyp:
           Fehler
        Ursache:
	   Die Anzahl der Argumente fÅr eine selbstdefinierte
           Funktion stimmt nicht mit der geforderten Anzahl
	   Åberein.
        Argument:
           keines

1495 unaufgelîste Literale (LTORG fehlt)

	Fehlertyp:
	   Fehler
	Ursache:
	   Am Programmende oder beim Umachalten zu einem
	   anderen Zielprozessor blieben noch nicht abgelegte
	   Literale Åbrig.
	Argument:
	   keines

1500 Befehl auf dem ... nicht vorhanden

	Fehlertyp:
           Fehler
        Ursache:
           Der benutzte Befehl existiert zwar  grundsÑtzlich, das
           eingestellte Mitglied der Prozessorfamilie beherrscht
           ihn aber noch nicht.
	Argument:
           keines


1505 Adressierungsart auf dem ... nicht vorhanden

	Fehlertyp:
           Fehler
	Ursache:
           Der benutzte Adressierungsmodus existiert zwar grund-
           sÑtzlich, das eingestellte Mitglied der Prozessorfamilie
           beherrscht ihn aber noch nicht.
	Argument:
           keines


1510 UngÅltige Bitstelle

        Fehlertyp:
           Fehler
        Ursache:
	   Die angegebene Bitnummer ist nicht erlaubt oder eine Angabe
           fehlt komplett.
        Argument:
           keines


1520 nur ON/OFF erlaubt

	Fehlertyp:
           Fehler
        Ursache:
           Dieser Pseudobefehl darf als Argument nur ON oder OFF
	   haben.
        Argument:
           keines


1530 Stack ist leer oder nicht definiert

	Fehlertyp:
           Fehler
        Ursache:
           Es wurde bei einem POPV-Befehl versucht, einen Stack
           anzusprechen, der entweder nie definiert oder bereits
           leergerÑumt wurde.
        Argument:
           der Name des fraglichen Stacks


1540 Nicht genau ein Bit gesetzt

	Fehlertyp:
           Fehler
        Ursache:
           In einer Bitmaske, die der BITPOS-Funktion Åbergeben 
           wurde, war nicht genau ein Bit gesetzt.
        Argument:
           keines


1600 vorzeitiges Dateiende
        Fehlertyp:
           Fehler
        Ursache:
           Es wurde mit einem BINCLUDE-Befehl versucht, Åber das 
           Ende einer Datei hinauszulesen.
        Argument:
           keines


1700 ROM-Offset geht nur von 0..63

        Fehlertyp:
           Fehler
	Ursache:
           Das Konstanten-ROM der 680x0-Koprozessoren hat nur max.
           63 EintrÑge.
        Argument:
           keines


1710 UngÅltiger Funktionscode

        Fehlertyp:
           Fehler
        Ursache:
	   Als Funktionscodeargument darf nur SFC, DFC, ein Daten-
           register oder eine Konstante von 0..15 verwendet werden.
           (nur 680x0-MMU)
	Argument:
           keines


1720 UngÅltige Funktionscodemaske

	Fehlertyp:
           Fehler
        Ursache:
           Als Funktionscodemaske darf nur ein Wert von 0..15 ver-
           wendet werden. (nur 680x0-MMU)
        Argument:
	   keines


1730 UngÅltiges MMU-Register

        Fehlertyp:
	   Fehler
        Ursache:
           Die MMU hat kein Register mit dem angegebenen Namen. (nur
	   680x0-MMU)
        Argument:
           keines


1740 Level nur von 0..7

        Fehlertyp:
           Fehler
        Ursache:
           Die Ebene fÅr PTESTW und PTESTR mu· eine Konstante von
           0..7 sein. (nur 680x0-MMU)
	Argument:
           keines


1750 ungÅltige Bitmaske

	Fehlertyp:
           Fehler
        Ursache:
	   Die bei den Bit-Feld-Befehlen angegebene Bitmaske hat ein
           falsches Format. (nur 680x0)
        Argument:
           keines


1760 ungÅltiges Registerpaar

        Fehlertyp:
           Fehler
        Ursache:
           Das angegebene Registerpaar ist hier nicht verwendbar oder
	   syntaktisch falsch. (nur 680x0)
        Argument:
	   keines


1800 offene Makrodefinition

        Fehlertyp:
           Fehler
	Ursache:
           Eine Makrodefinition war am Dateiende nicht zuende.  Ver-
           mutlich fehlt ein ENDM.
        Argument:
           keines


1805 EXITM au·erhalb eines Makrorumpfes

        Fehlertyp:
           Fehler
        Ursache:
           EXITM bricht die Expansion von Makro-Konstrukten ab.  Dieser 
           Befehl macht nur innerhalb von Makros Sinn und es wurde 
           versucht, ihn au·erhalb aufzurufen.
        Argument:
           keines

1810 mehr als 10 Makroparameter

        Fehlertyp:
           Fehler
        Ursache:
	   Ein Makro darf hîchstens 10 Parameter haben.
        Argument:
	   keines


1815 doppelte Makrodefinition

	Fehlertyp:
	   Fehler
	Ursache:
	   Ein Makronamne wurde in einer Sektion doppelt vergeben.
	Argument:
	   der doppelt verwendete Name


1820 Ausdruck mu· im ersten Pass berechenbar sein

        Fehlertyp:
           Fehler
	Ursache:
           Der benutzte Befehl beeinflu·t die CodelÑnge, daher sind
           VorwÑrtsreferenzen hier nicht erlaubt.
        Argument:
           keines


1830 zu viele verschachtelte IFs

        Fehlertyp:
           Fehler
        Ursache:
	   (nicht mehr verwendet)
        Argument:
	   keines


1840 ELSEIF/ENDIF ohne ENDIF

        Fehlertyp:
           Fehler
	Ursache:
           es wurde ein ELSEIF- oder ENDIF-Befehl gefunden, obwohl
           kein offener IF-Befehl vorhanden ist.
        Argument:
           keines


1850 verschachtelter/rekursiver Makroaufruf

        Fehlertyp:
           Fehler
        Ursache:
	   (nicht mehr verwendet)
        Argument:
	   keines


1860 unbekannte Funktion

        Fehlertyp:
           Fehler
	Ursache:
           Die angesprochene Funktion ist weder eingebaut noch nach-
           trÑglich definiert worden.
	Argument:
           der Funktionsname


1870 Funktionsargument au·erhalb Definitionsbereich

        Fehlertyp:
           Fehler
        Ursache:
	   Das Argument liegt nicht im Bereich der angesprochenen
           transzendenten Funktion.
	Argument:
           keines


1880 GleitkommaÅberlauf

	Fehlertyp:
	   Fehler
	Ursache:
	   Das Argument liegt zwar im Bereich der angesprochenen
	   transzendenten Funktion, das Ergebnis wÑre aber nicht
	   mehr darstellbar.
	Argument:
	   keines


1890 ungÅltiges Wertepaar

	Fehlertyp:
	   Fehler
	Ursache:
	   Das benutzte PÑrchen aus Basis und Exponent kann nicht
	   berechnet werden.
	Argument:
           keines


1900 Befehl darf nicht auf dieser Adresse liegen

        Fehlertyp:
           Fehler
        Ursache:
           Die Prozessorhardware erlaubt keine SprÅnge von dieser
           Adresse.
	Argument:
           keines


1905 ungÅltiges Sprungziel

	Fehlertyp:
           Fehler
	Ursache:
           Die Prozessorhardware erlaubt keine SprÅnge zu dieser
	   Adresse.
        Argument:
	   keines


1910 Sprungziel nicht auf gleicher Seite

        Fehlertyp:
           Fehler
        Ursache:
           Sprungbefehl und Sprungziel mÅssen bei diesem Befehl
	   auf der gleichen Seite liegen.
        Argument:
           keines


1920 CodeÅberlauf

        Fehlertyp:
	   Fehler
        Ursache:
	   Es wurde versucht, mehr als 1024 Bytes Code oder Daten
           in einer Zeile zu erzeugen.
	Argument:
           keines


1925 Adre·Åberlauf

	Fehlertyp:
	   Fehler
	Ursache:
	   Der Adre·raum dieses Prozessors wurde Åberschritten.
	Argument:
	   keines


1930 Konstanten und Platzhalter nicht mischbar

	Fehlertyp:
	   Fehler
	Ursache:
	   Anweisungen, die Speicher reservieren und solche, die ihn
           mit Konstanten belegen, dÅrfen nicht in einer Pseudo-
           anweisung gemischt werden.
        Argument:
           keines


1940 Codeerzeugung nur im Codesegment zulÑssig

	Fehlertyp:
	   Fehler
	Ursache:
	   Alle Segmente au·er Code dienen nur der Reservierung von
	   Speicher, in ihnen dÅrfen weder Code noch Daten abgelegt
	   werden.
           (nicht mehr benutzt)
	Argument:
	   keines


1950 Paralleles Konstrukt nicht mîglich

	Fehlertyp:
	   Fehler
	Ursache:
	   Entweder sind die beiden Instruktionen prinzipiell nicht
	   parallel ausfÅhrbar, oder sie stehen nicht unmittelbar
	   untereinander.
	Argument:
	   keines

1960 ungÅltiges Segment
        Fehlertyp:
           Fehler
        Ursache:
	   Das angegebene Segment ist an dieser Stelle nicht
           anwendbar.
        Argument:
	   der benutzte Segmentname


1961 unbekanntes Segment

        Fehlertyp:
	   Fehler
        Ursache:
           Das bei SEGMENT angegebene Segment existiert bei diesem
           Prozessor nicht.
        Argument:
           der benutzte Segmentname


1962 unbekanntes Segmentregister

        Fehlertyp:
           Fehler
	Ursache:
           Das angegebene Segmentregister existiert nicht (nur 8086).
        Argument:
	   keines


1970 ungÅltiger String

        Fehlertyp:
	   Fehler
        Ursache:
           Der angegebene String hat ein ungÅltiges Format.
        Argument:
           keines


1980 ungÅltiger Registername

        Fehlertyp:
           Fehler
        Ursache:
	   Das angegebene Register existiert nicht oder darf hier
           nicht verwendet werden.
        Argument:
	   keines


1985 ungÅltiges Argument

        Fehlertyp:
	   Fehler
        Ursache:
           Der angegebene Befehl darf nicht mit einem REP-PrÑfix
           versehen werden.
        Argument:
           keines


1990 keine Indirektion erlaubt

        Fehlertyp:
           Fehler
	Ursache:
           in dieser Kombination ist keine indirekte Adressierung
           erlaubt.
	Argument:
           keines


1995 nicht im aktuellen Segment erlaubt

	Fehlertyp:
           Fehler
        Ursache:
           (nicht mehr verwendet)
        Argument:
           keines


1996 nicht im Maximum-Modus zulÑssig

        Fehlertyp:
           Fehler
	Ursache:
           Dieses Register ist nur im Minimum-Modus definiert.
        Argument:
	   keines


1997 nicht im Minimum-Modus zulÑssig

	Fehlertyp:
	   Fehler
        Ursache:
           Dieses Register ist nur im Maximum-Modus definiert.
        Argument:
           keines


2000 UngÅltige PrÑfix-Kombination

        Fehlertyp:
           Fehler
        Ursache:
           Die angegebene Kombination von PrÑfixen ist nicht zulÑssig
           oder nicht im Maschinenkode darstellbar.
        Argument:
           keines


2010 ungÅltige Escape-Sequenz

        Fehlertyp:
           Fehler
        Ursache:
           Das mit einem Backslash eingeleitete Sonderzeichen ist
           nicht definiert.
        Argument:
           keines


10001 Fehler bein ôffnen der Datei

        Fehlertyp:
           fatal
        Ursache:
	   Beim Versuch, eine Datei zu îffnen, ist ein Fehler
           aufgetreten.
        Argument:
	   Beschreibung des E/A-Fehlers


10002 Listingschreibfehler

        Fehlertyp:
	   fatal
        Ursache:
	   Beim Schreiben des Assemblerlistings ist ein Fehler
           aufgetreten.
        Argument:
           Beschreibung des E/A-Fehlers


10003 Dateilesefehler

	Fehlertyp:
           fatal
	Ursache:
           Beim Lesen aus einer Quelldatei ist ein Fehler auf-
           getreten.
	Argument:
           Beschreibung des E/A-Fehlers


10004 Dateischreibfehler

	Fehlertyp:
           fatal
        Ursache:
           Beim Schreiben von Code- oder Share-Datei ist ein
           Fehler aufgetreten.
	Argument:
	   Beschreibung des E/A-Fehlers


10006 SpeicherÅberlauf

        Fehlertyp:
	   fatal
	Ursache:
           Der verfÅgbare Speicher reicht nicht mehr, alle Daten-
	   strukturen aufzunehmen.  Weichen Sie auf die DPMI- oder
           OS/2-Version von AS aus.
        Argument:
           keines


10007 StapelÅberlauf

        Fehlertyp:
           fatal
        Ursache:
           Der Programmstapel ist wegen zu komplizierter Formel-
	   ausdrÅcke oder einer ungÅnstigen Anlage der Symbol-
	   oder Makrotabelle Åbergelaufen.  Versuchen Sie es noch
	   einmal mit der '-A'-Option.
	Argument:
           keines


        B. E/A-Fehlermeldungen
        ======================

Die hier aufgelisteten Fehlermeldungen werden nicht nur von AS bei
E/A-Fehlern ausgegeben, sondern auch von den Hilfsprogrammen PLIST,
BIND, P2HEX und P2BIN.  Es sind nur die Fehler nÑher erklÑrt, die
m.E. bei der Arbeit auftreten kînnen.  Sollte doch einmal ein nicht
erlÑuterter E/A-Fehler auftreten, so dÅrfte der Grund in einem Pro-
grammfehler liegen.  Melden Sie dies unbedingt!!

   2   Datei nicht gefunden
	Die angegebene Datei existiert nicht oder liegt auf einem
        anderen Laufwerk.

   3   Pfad nicht gefunden
        Der Pfad eines Dateinamens existiert nicht oder liegt auf
        einem anderen Laufwerk.

   4   zu viele offene Dateien
	DOS sind die Dateihandles ausgegangen.  Erhîhen Sie die
        FILES= -Angabe in der CONFIG.SYS.

   5   Dateizugriff verweigert
	Entweder reichen die Netzwerkrechte fÅr einen Dateizugriff
        nicht, oder es wurde versucht, eine schreibgeschÅtzte Datei
        zu Åberschreiben oder zu verÑndern.

   6   UngÅltiger Dateihandle

  12   UngÅltiger Zugriffsmodus

  15   UngÅltiger Laufwerksbuchstabe
	Das angesprochene Laufwerk existiert nicht.

  16   aktuelles Verzeichnis kann nicht gelîscht werden

  17   RENAME geht nicht Åber Laufwerke

 100   vorzeitiges Dateiende
        Eine Datei war zuende, obwohl sie es aufgrund ihrer Struktur
	noch nicht sein dÅrfte.  Vermutlich ist sie beschÑdigt.

 101   Diskette/Platte voll
        Das spricht wohl fÅr sich!  AufrÑumen!!

 102   ASSIGN fehlt

 103   Datei nicht offen

 104   Datei nicht fÅr Einlesen offen

 105   Datei nicht fÅr Ausgaben offen

 106   UngÅltiges numerisches Format

 150   Diskette ist schreibgeschÅtzt
        Wenn Sie schon keine Festplatte als Arbeitsmedium verwenden,
        so sollten Sie wenigstens die Schreibschutzecke entfernen!

 151   Unbekanntes GerÑt
        Sie haben versucht, ein PeripheriegerÑt anzusprechen, welches
	DOS unbekannt ist.  Dies sollte normalerweise nicht auftreten,
	da der Name dann automatisch als Datei interpretiert wird.

 152   Laufwerk nicht bereit
	Schlie·en Sie die Klappe des Diskettenlaufwerks.

 153   unbekannte DOS-Funktion

 154   PrÅfsummenfehler auf Diskette/Platte
	Ein harter Lesefehler auf der Diskette.  Nochmal versuchen;
        wenn immer noch vorhanden, Diskette neu formatieren bzw.
        ernste Sorgen um Festplatte machen!

 155   ungÅltiger DPB

 156   Positionierfehler
        Der Platten/Disketten-Controller hat eine bestimmte Spur nicht
	gefunden.  Siehe Nr. 154!

 157   unbekanntes Sektorformat
        DOS kann mit dem Format der Diskette nichts anfangen.

 158   Sektor nicht gefunden
        Analog zu Nr. 158, nur da· hier der angeforderte Sektor auf
        der Spur nicht gefunden werden konnte.

 159   Papierende
        Offensichtlich haben Sie die Ausgaben von AS direkt auf einen
	Drucker umgeleitet.  Assemblerlistings kînnen seeehr lang
        sein...

 160   GerÑtelesefehler
        Nicht nÑher vom GerÑtetreiber klassifizierter Lesefehler.

 161   GerÑteschreibfehler
        Nicht nÑher vom GerÑtetreiber klassifizierter Schreibfehler.

 162   allgemeiner GerÑtefehler
        Hier ist der GerÑtetreiber vîllig ratlos, was passiert sein
        kînnte.


        C. HÑufig gestellte Fragen
        ==========================

In diesem Kapitel habe ich versucht, einige besonders hÑufig ge-
stellte Fragen mit den passenden Antworten zu sammeln.  Die Ant-
worten auf die hier auftauchenden Probleme finden sich zwar auch
an anderer Stelle in der Anleitung, jedoch findet man sie vielleicht
nicht auf den ersten Blick...

F: In den Bildschirmausgaben von AS tauchen seltsame Zeichen auf,
   z.B. Pfeile und eckige Klammern.  Warum?
A: AS verwendet zur Bildschirmsteuerung defaultmÑ·ig einige ANSI-
   Terminalsteuersequenzen.  Haben Sie keinen ANSI-Treiber instal-
   liert, so kommen diese Steuerzeichen ungefiltert auf Ihrem Bild-
   schirm heraus.  Installieren Sie entweder einen ANSI-Treiber oder
   schalten Sie die Steuersequenzen mit dem DOS-Befehl SET USEANSI=N
   ab.

F: WÑhrend der Assemblierung bricht AS plîtzlich mit der Meldung
   eines StapelÅberlaufes ab.  Ist mein Programm zu kompliziert?
A: Ja und Nein.  Die Symboltabelle fÅr Ihr Programm ist nur etwas
   unregelmÑ·ig gewachsen, was zu zu hohen Rekursionstiefen im
   Zugriff auf die Tabelle gefÅhrt hat.  Diese Fehler treten ins-
   besondere bei der 16-Bit-OS/2-Version von AS auf, die nur Åber
   einen relativ kleinen Stack verfÅgt.  Starten Sie AS noch einmal
   mit dem -A-Kommandozeilenschalter.

F: AS scheint mein Programm nicht bis zum Ende zu assemblieren.  Mit
   einer Ñlteren Version von AS (1.39) hat es dagegen funktioniert.
A: Neuere Versionen von AS ignorieren das END-Statement nicht mehr,
   sondern beenden danach wirklich die Assemblierung.  Insbesondere
   bei Include-Dateien ist es frÅher vorgekommen, da· Anwender jede
   Datei mit einem END-Statement beendet haben.  Entfernen Sie die
   ÅberflÅssigen ENDs.

F: Mein Programm wird zwar korrekt assembliert, bei der Umwandlung
   mit P2BIN oder P2HEX erhalte ich aber nur eine leere Datei.
A: Dann haben Sie wahrscheinlich das Adre·filter nicht korrekt
   eingestellt.  DefaultmÑ·ig reicht der Filter von 0 bis 32 kByte,
   falls Ihr Programm Teile au·erhalb dieses Bereiches besitzen
   sollte, werden diese nicht Åbernommen.  Sollte Ihr Code komplett
   jenseits 32 kByte liegen (wie es bei 65er und 68er-Prozessoren
   Åblich ist), dann erhalten Sie das von Ihnen geschilderte Ergeb-
   nis.  Setzen Sie das Adre·filter einfach auf einen passenden
   Bereich (s. das Kapitel zu P2BIN/P2HEX).


        D. Pseudobefehle gesammelt
        ==========================


In diesem Anhang finden sich noch einmal als schnelle Referenz alle
von AS zur VerfÅgung gestellten Pseudobefehle.  Die Liste ist in zwei
Teile gegliedert: Im ersten Teil finden sich Befehle, die unabhÑngig
vom eingestellten Zielprozessor vorhanden sind, danach folgen för 
jede Prozessorfamilie die zusÑtzlich vorhandenen Befehle:

        Immer vorhandene Befehle
        ------------------------

=             :=             ALIGN          BINCLUDE       CASE
CHARSET       CPU            DEPHASE        ELSECASE       ELSEIF
END           ENDCASE        ENDIF          ENDM           ENDSECTION
ENUM          ERROR          EQU            EXITM          FATAL
FORWARD       FUNCTION       GLOBAL         IF             IFB
IFDEF         IFEXIST        IFNB           IFNDEF         IFNEXIST
IFNUSED       IFUSED         INCLUDE        IRP            LABEL
LISTING       MACEXP         MACRO          MESSAGE        NEWPAGE
ORG           PAGE           PHASE          POPV           PUSHV
PRTEXIT       PRTINIT        PUBLIC         READ           RELAXED
REPT          RESTORE        SAVE           SECTION        SEGMENT
SHARED        SWITCH         TITLE          WARNING        WHILE

ZusÑtzlich existiert SET bzw. EVAL, falls SET bereits ein Prozessor-
befehl ist.

        Motorola 680x0
        --------------

DC[.<size>]   DS[.<size>]    FULLPMMU       FPU            PADDING
PMMU          SUPMODE


        Motorola 56000
        --------------

DC            DS             XSFR           YSFR


        PowerPC
        -------

BIGENDIAN     DB             DD             DQ             DS
DT            DW             SUPMODE


        Motorola 68xx/Hitachi 6309
        --------------------------

ADR           BYT            DC[.<size>]    DFS            DS[.<size>]
FCB           FCC            FDB            PADDING        RMB


        Motorola 6805/68HC08
        --------------------

ADR           BYT            DFS            FCB            FCC
FDB           RMB


        Motorola 6809/Hitachi 6309
        --------------------------

ADR           ASSUME         BYT            DFS            FCB
FCC           FDB            RMB


        Motorola 68HC12
        ---------------

ADR           BYT            DC[.<size>]    DFS            DS[.<size>]
FCB           FCC            FDB            PADDING        RMB


        Motorola 68HC16
        ---------------

ADR           ASSUME         BYT            DFS            FCB
FCC           FDB            RMB


        Hitachi H8/300(L/H)
        -------------------

DC[.<size>]   DS[.<size>]    MAXMODE        PADDING


        Hitachi H8/500
        --------------

ASSUME        DC[.<size>]    DS[.<size>]    MAXMODE        PADDING


        Hitachi SH7x00
        --------------

COMPLITERALS  DC[.<size>]    DS[.<size>]    LTORG          PADDING
SUPMODE


        65xx/MELPS-740
        --------------

ADR           ASSUME         BYT            DFS            FCB
FCC           FDB            RMB


        65816/MELPS-7700
        ----------------

ADR           ASSUME         BYT            DFS            FCB
FCC           FDB            RMB


        Mitsubishi MELPS-4500
        ---------------------

DATA          RES            SFR


        Mitsubishi M16
        --------------

DB            DD             DQ             DS             DT
DW


        Mitsubishi M16C
        ---------------

DB            DD             DQ             DS             DT
DW


        Intel MCS-48
        ------------

DB            DD             DQ             DS             DT
DW


        Intel MCS-(2)51
        ---------------

BIGENDIAN     BIT            DB             DD             DQ
DS            DT             DW             PORT           SFR
SFRB          SRCMODE


        Intel MCS-96
        ------------

ASSUME        DB             DD             DQ             DS
DT            DW
 

        Intel 8080/8085
        ---------------

DB            DD             DQ             DS             DT
DW            PORT

 
        Philips XA
        ----------

ASSUME        BIT            DB             DC[.<size>]    DD 
DQ            DS[.<size>]    DT             DW             PADDING
PORT          SUPMODE


        AMD 29K
        -------

ASSUME        DB             DD             DQ             DS
DT            DW             EMULATED       SUPMODE


        Siemens 80C166/167
        ------------------

ASSUME        BIT            DB             DD             DQ
DS            DT             DW


        Zilog Zx80
        ----------

DB            DD             DEFB           DEFW           DQ
DS            DT             DW             EXTMODE        LWORDMODE


        Zilog Z8
        --------

DB            DD             DQ             DS             DT
DW            SFR


        Toshiba TLCS-900
        ----------------

DB            DD             DQ             DS             DT
DW            MAXIMUM        SUPMODE


        Toshiba TLCS-90
        ---------------

DB            DD             DQ             DS             DT
DW


        Toshiba TLCS-870
        ----------------

DB            DD             DQ             DS             DT
DW


        Toshiba TLCS-47(0(A))
        ---------------------

ASSUME        DB             DD             DQ             DS
DT            DW             PORT


        Toshiba TLCS-9000
        -----------------

DB            DD             DQ             DS             DT
DW


        Microchip PIC16C5x
        ------------------

DATA          RES            SFR            ZERO


        Microchip PIC16C5x
        ------------------

DATA          RES            SFR            ZERO


        Microchip PIC17C42
        ------------------

DATA          RES            SFR            ZERO


        SGS-Thomson ST6
        ---------------

ASCII         ASCIZ          ASSUME         BYTE           BLOCK
SFR           WORD      


        6804
        ----

ADR           BYT            DFS            FCB            FCC
FDB           RMB            SFR


        Texas TM3201x
        -------------

DATA          PORT           RES


        Texas TM32C02x
        --------------

BFLOAT        BSS            BYTE           DATA           DOUBLE
EFLOAT        TFLOAT         LONG           LQxx           PORT
Qxx           RES            RSTRING        STRING         WORD


        Texas TMS320C3x
        ---------------

ASSUME        BSS            DATA           EXTENDED       SINGLE
WORD


        Texas TM32C05x
        --------------

BFLOAT        BSS            BYTE           DATA           DOUBLE
EFLOAT        TFLOAT         LONG           LQxx           PORT
Qxx           RES            RSTRING        STRING         WORD


        Texas TMS370
        ------------

DB            DBIT           DD             DQ             DS
DT            DW


        Texas MSP430
        ------------

BSS           BYTE           PADDING        WORD


        National COP8
        -------------

ADDR          ADDRW          BYTE           DSB            DSW
FB            FW             SFR            WORD


        NEC uPD78C1x
        ------------

ASSUME        DB             DD             DQ             DS
DT            DW


        NEC 75K0
        --------

ASSUME        BIT            DB             DD             DQ
DS            DT             DW             SFR

   
        NEC 78K0
        --------

DB            DD             DQ             DS             DT
DW


        E. Vordefinierte Symbole
        ========================


Name         Datentyp   Definition  Bedeutung

BIGENDIAN    Boolean    dynam.(0)   Konstantenablage mit MSB first ?

CASESENSITIVE Boolean   normal      Unterscheidung von Gro·-und Klein-
                                    buchstaben in Symbolnamen ?

CONSTPI      Gleitkomma normal      Kreiszahl Pi (3.1415.....)

DATE         String     vordef.     Datum des Beginns der Assem-
                                    blierung (1.Pass)

FALSE        Boolean    vordef.     0 = logisch "falsch"

HASFPU       Boolean    dynam.(0)   Koprozessor-Befehle freige-
                                    schaltet ?

HASPMMU      Boolean    dynam.(0)   MMU-Befehle freigeschaltet ?

INEXTMODE    Boolean    dynam.(0)   XM-Flag fÅr 4 GByte Adre·raum ge-
                                    setzt ?

INLWORDMODE  Boolean    dynam.(0)   LW-Flag fÅr 32-Bit-Befehle ge-
                                    setzt ?

INMAXMODE    Boolean    dynam.(0)   Prozessor im Maximummodus ?

INSUPMODE    Boolean    dynam.(0)   Prozessor im Supervisor-Modus ?

INSRCMODE    Boolean    dynam.(0)   Prozessor im Quellmodus ?

FULLPMMU     Boolean    dynam.(0/1) voller PMMU-Befehlssatz erlaubt ?

LISTON       Boolean    dynam.(1)   Listing freigeschaltet ?

MACEXP       Boolean    dynam.(1)   Expansion von Makrokonstrukten im
                                    Listing freigeschaltet ?

MOMCPU       Integer    dynam.      Nummer der momentan gesetzten
			(68008)	    Ziel-CPU

MOMCPUNAME   String     dynam.      Name der momentan gesetzten Ziel-
                        (68008)     CPU

MOMFILE      String     Spezial     augenblickliche Quelldatei
                                    (schlie·t Includes ein)

MOMLINE      Integer    Spezial     aktuelle Zeilennummer in der
                                    Quelldatei

MOMPASS      Integer    Spezial     Nummer des laufenden Durchgangs

MOMSECTION   String     Spezial     Name der aktuellen Sektion oder
				    Leerstring, falls au·erhalb aller
                                    Sektionen

MOMSEGMENT   String     Spezial     Name des mit SEGMENT eingestellten
                                    Adre·raumes

PADDING      Boolean    dynam.(1)   AuffÅllen von Bytefeldern auf gan-
                                    ze Anzahl ?

RELAXED      Boolean    dynam.(0)   Schreibweise von Integer-Konstan-
                                    ten in beliebiger Syntax erlaubt ?

PC           Integer    Spezial     mom. ProgrammzÑhler (Thomson)

TIME         String     vordef.     Zeit des Beginns der Assemblie-
                                    rung (1. Pass)

TRUE         Integer    vordef.     1 = logisch "wahr"

VERSION      Integer    vordef.     Version von AS in BCD-Kodierung,
				    z.B. 1331 hex fÅr Version 1.33p1

*            Integer    Spezial     mom. ProgrammzÑhler (Motorola,
                                    Rockwell, Microchip, Hitachi)

$            Integer    Spezial     mom. ProgrammzÑhler (Intel, Zilog,
                                    Texas, Toshiba, NEC, Siemens, AMD)

Boolean-Symbole sind eigentlich normale normale Integer-Symbole, mit
dem Unterschied, da· ihnen von AS nur zwei verschiedene Werte (0 oder
1, entsprechend False oder True) zugewiesen werden.  Spezialsymbole
werden von AS nicht in der Symboltabelle abgelegt, sondern aus Ge-
schwindigkeitsgrÅnden direkt im Parser abgefragt.  Sie tauchen daher
auch nicht in der Symboltabelle des Listings auf.  WÑhrend vordefi-
nierte Symbole nur einmal am Anfang eines Passes besetzt werden, kîn-
nen sich die Werte dynamischer Symbole wÑhrend der Assemblierung
mehrfach Ñndern, da sie mit anderen Befehlen vorgenommene Einstel-
lungen widerspiegeln.  Die in Klammern stehenden Werte geben dann die
Voreinstellung zu Beginn eines Passes an.

Die hier aufgelistete Schreibweise ist diejenige, mit der man die 
Symbole auch im case-sensitiven Modus erreicht.

Die hier aufgefÅhrten Namen sollte man fÅr eigene Symbole meiden;
entweder kann man sie zwar definieren, aber nicht darauf zugreifen
(bei Spezialsymbolen), oder man erhÑlt eine Fehlermeldung wegen eines
doppelt definierten Symboles.  Im gemeinsten Fall fÅhrt die Neube-
legung durch AS zu Beginn eines Passes zu einem Phasenfehler und
einer Endlosschleife...


	F. Danksagungen
	===============

Wenn man sich entschlie·t, ein solches Kapitel neu zu schreiben, nach-
dem es eigentlich schon zwei Jahre veraltet ist, lÑuft man automatisch
Gefahr, da· dabei der eine oder andere gute Geist, der etwas zum bis-
herigen Gelingen dieses Projektes beigetragen hat.  Der allererste 
Dank gebÅhrt daher allen Personen, die ich in der folgenden AufzÑhlung
unfreiwillig unterschlagen habe!  

AS als Universalassembler, wie er jetzt besteht, ist auf Anregung von
Bernhard (C.) Zschocke entstanden, der einen "studentenfreundli-
chen", d.h. kostenlosen 8051-Assembler fÅr sein Mikroprozessorprakti-
kum brauchte und mich dazu bewegt hat, einen bereits bestehenden 
68000-Assembler zu erweitern.  Von dortan nahm die Sache ihren Lauf...
Das Mikroprozessorpraktikum an der RWTH Aachen hat auch immer die
eifrigsten Nutzer der neuesten AS-Features (und damit Bug-Sucher) ge-
stellt und damit einiges zur jetzigen QualitÑt von AS beigetragen.

Das Internet und FTP haben sich als gro·e Hilfe bei der Meldung von
Bugs und der Verbreitung von AS erwiesen.  Ein Dank geht daher an
die FTP-Administratoren (Bernd Casimir in Stuttgart, Norbert Breidohr
in Aachen und JÅrgen Mei·burger in JÅlich).  Insbesondere letzterer 
hat hat sich sehr engagiert, um eine praxisnahe Lîsung im ZAM zu 
finden.

Ach ja, wo wir schon im ZAM sind: Wolfgang E. Nagel hat zwar nichts
direkt mit AS zu tun, immerhin ist er aber mein Chef und wirft 
stÑndig vier Augen auf das, was ich tue.  Bei AS scheint zumindest
ein lachendes dabei zu sein...

Ohne DatenbÅcher und Unterlagen zu Prozessoren ist ein Programm wie
AS nicht zu machen.  Ich habe von einer enormen Anzahl von Leuten
Informationen bekommen, die von einem kleinen Tip bis zu ganzen
DatenbÅchern reichen.  Hier eine AufzÑhlung (wie oben gesagt, ohne 
Garantie auf VollstÑndigkeit!):

Ernst Ahlers, Charles Altmann, Bernd Casimir, Gunther Ewald,
Stephan Hruschka, Peter Kliegelhîfer, Ulf Meinke, Matthias Paul, 
Norbert Rosch, Leonhard Schneider, Oliver Sellke, Christian Stelter,
Oliver Thamm, Thorsten Thiele.

...und ein gehÑssiger Dank an Rolf-Dieter-Klein und Tobias Thiel, die
mit ihren ASM68K demonstrierten, wie man es nicht machen sollte und
mich damit indirekt dazu angeregt haben, etwas besseres zu schrei-
ben!

So ganz allein habe ich AS nicht verzapft.  AS enthÑlt die OverXMS-
Routinen von Wilbert van Leijen, um die Overlay-Module ins Extended
Memory verlagern zu kînnen.  Eine wirklich feine Sache, einfach und
problemlos anzuwenden!

Der TMS320C2x/5x-Codegenerator sowie die Datei STDDEF2x.INC stammen
von Thomas Sailer, ETH ZÅrich.  Erstaunlich, an einem Wochenende hat
er es geschafft, durch meinen Code durchzusteigen und den neuen Ge-
nerator zu implementieren.  Entweder waren das reichliche Nacht-
schichten oder ich werde langsam alt...


	G. énderungen seit Version 1.3
	==============================

Version 1.31:  - zusÑtzlicher MCS-51-Prozessortyp 80515.  Die Nummer
		 wird wiederum nur vom Assembler verwaltet.  Die Da-
		 tei STDDEF51.INC wurde um die dazugehîrigen SFRs
		 erweitert. ACHTUNG! Einige 80515-SFRs haben sich
                 adre·mÑ·ig verschoben!

               - zusÑtzlich Prozessor Z80 unterstÅtzt;

               - schnellerer 680x0-Codegenerator.

Version 1.32   - Schreibweise von Zeropageadressen fÅr 65xx nicht mehr
                 als Adr.z, sondern wie beim 68xx als <Adr;

               - unterstÅtzt die Prozessoren 6800, 6805, 6301 und
		 6811;

               - der 8051-Teil versteht jetzt auch DJNZ, PUSH und POP
		 (sorry);

               - im Listing werden neben den Symbolen jetzt auch die
                 definierten Makros aufgelistet;

	       - Befehle IFDEF/IFNDEF fÅr bedingte Assemblierung, mit
                 denen sich die Existenz eines Symboles abfragen
		 lÑ·t;

	       - Befehle PHASE/DEPHASE zur UnterstÅtzung von Code,
                 der zur Laufzeit auf eine andere Adresse verschoben
		 werden soll;

	       - Befehle WARNING/ERROR/FATAL, um anwenderspezifi-
                 sche Fehlermeldungen ausgeben zu kînnen;

               - Die Datei STDDEF51.INC enthÑlt zusÑtzlich das Makro
		 USING zur einfacheren Handhabung der RegisterbÑnke
		 der MCS-51er;

               - Kommandozeilenoption u, um Segmentbelegung anzuzei-
		 gen.

Version 1.33   - unterstÅtzt den 6809;

	       - zusÑtzlich Stringvariablen;

	       - Die Befehle TITLE, PRTINIT, PRTEXIT, ERROR, WARNING
		 und FATAL erwarten jetzt einen Stringausdruck, Kon-
                 stanten mÅssen demzufolge nicht mehr in Hochkommas,
		 sondern in GÑnsefÅ·chen eingeschlossen werden. Ana-
                 loges gilt fÅr DB, DC.B und BYT;

	       - Befehl ALIGN zur Ausrichtung des ProgrammzÑhlers bei
		 Intel-Prozessoren:

               - Befehl LISTING, um die Erzeugung eines Listings ein-
                 und ausschalten zu kînnen;

	       - Befehl CHARSET zur Definition eigener ZeichensÑtze;

Version 1.34   - Wenn im ersten Pass Fehler auftreten, wird gar kein
		 zweiter Pass mehr durchgefÅhrt;

	       - neues vordefiniertes Symbol VERSION, welches die
                 Version von AS enthÑlt;

	       - Befehl MESSAGE, um Durchsagen und Meldungen programm-
                 gesteuert zu erzeugen;

               - Formelparser Åber Stringkonstanten zugÑnglich;

               - Bei Fehlern in Makroexpansionen wird zusÑtzlich die
		 laufende Zeile im Makro angezeigt;

	       - Funktion UPSTRING, um einen String in Gro·buchstaben
                 zu wandeln;

Version 1.35   - Funktion TOUPPER, um ein einzelnes Zeichen in Gro·-
                 buchstaben zu wandeln;

               - Befehl FUNCTION, um eigene Funktionen definieren zu
                 kînnen;

               - Kommandozeilenoption D, um Symbole von au·en definie-
		 ren zu kînnen;

               - Fragt die Environment-Variable ASCMD fÅr hÑufig ge-
		 brauchte Optionen ab;

	       - bei gesetzter u-Option wird das Programm zusÑtzlich
                 auf doppelt belegte Speicherbereiche abgeprÅft;

	       - Kommandozeilenoption C, um eine Querverweisliste zu
		 erzeugen.

Version 1.36   - unterstÅtzt zusÑtzlich die Prozessorfamilien PIC 16C5x
                 und PIC17C4x;

               - im Listing wird zusÑtzlich die Verschachtelungsebene
                 bei Include-Dateien angezeigt;

               - in der Querverweisliste wird zusÑtzlich die Stelle
		 angezeigt, an der ein Symbol definiert wurde;

               - Kommandozeilenoption A, um eine kompaktere Ablage
                 der Symboltabelle zu erzwingen.

Version 1.37   - unterstÅtzt zusÑtzlich die Prozessoren 8086, 80186,
		 V30, V35, 8087 und Z180;

	       - Befehle SAVE und RESTORE zur besseren Umschaltung von
                 Flags;

               - Operatoren zur logischen Verschiebung und Bitspiegelung;

               - Kommandozeilenoptionen kînnen mit einem Pluszeichen
		 negiert werden;

               - Filter AS2MSG zur bequemen Arbeit mit AS unter
                 Turbo-Pascal 7.0;

	       - ELSEIF darf ein Argument zur Bildung von IF-THEN-ELSE-
                 Leitern haben;

	       - Zur bequemeren bedingten Assemblierung zusÑtzlich ein
                 CASE-Konstrukt;

               - Selbstdefinierte Funktionen dÅrfen mehr als ein Argument
                 haben;

               - P2HEX kann nun auch Hexfiles fÅr 65er-Prozessoren er-
		 zeugen;

               - BIND, P2HEX und P2BIN haben jetzt die gleichen Varia-
                 tionsmîglichkeiten in der Kommandozeile wie AS;

               - Schalter i bei P2HEX, um 3 Varianten fÅr den Endere-
		 cord einzustellen;

               - Neue Funktionen ABS und SGN;

               - Neue Pseudovariablen MOMFILE und MOMLINE;

               - Ausgabemîglichkeit erweiterter Fehlermeldungen;

	       - Befehle IFUSED und IFNUSED, um abzufragen, ob ein
                 Symbol bisher benutzt wurde;

	       - Die Environment-Variablen ASCMD, BINDCMD usw. kînnen
                 auch einen Dateinamen enthalten, in dem fÅr die
		 Optionen mehr Platz ist;

	       - P2HEX erzeugt nun die von Microchip vorgegebenen
                 Hex-Formate (p4);

               - mit der SeitenlÑngenangabe 0 kînnen automatische
		 SeitenvorschÅbe im Listing vollstÑndig unterdrÅckt
                 werden (p4);

               - neue Kommandozeilenoption P, um die Ausgabe des
                 Makroprozessors in eine Datei zu schreiben (p4);

               - vordefinierte Symbole dÅrfen nun auch mit einem frei
		 wÑhlbaren Wert belegt werden (p5).

Version 1.38   - Umstellung auf Mehrpass-Betrieb.  Damit kann AS auch
		 bei VorwÑrtsreferenzen immer den optimalen Code
		 erzeugen;

	       - Der 8051-Teil kennt nun auch die Befehle JMP und CALL;

	       - unterstÅtzt zusÑtzlich die Toshiba TLCS-900-Reihe (p1);

	       - Befehl ASSUME, um dem Assembler die Belegung der 8086-
		 Segmentregister mitzuteilen (p2);

	       - unterstÅtzt zusÑtzlich die ST62xx-Reihe von SGS-Thomson
		 (p2);

	       - ..sowie die 3201x-Signalprozessoren von Texas Instru-
		 ments (p2);

	       - Option F bei P2HEX, um die automatische Formatwahl
		 Åbersteuern zu kînnen (p2);

	       - P2BIN kann nun auch durch Angabe von Dollarzeichen
		 Anfang und Ende des Adre·fensters selbststÑndig
		 festlegen (p2);

	       - Der 8048-Codegenerator kennt nun auch die 8041/42-
		 Befehlserweiterungen(p2).

	       - unterstÅtzt zusÑtzlich die Zilog Z8-Mikrokontroller.

Version 1.39   - Definitionsmîglichkeit von Sektionen und lokalen
		 Labels;

	       - Kommandozeilenschalter h, um Hexadezimalzahlenausgabe
		 mit Kleinbuchstaben zu erzwingen;

	       - Variable MOMPASS, um die Nummer des augenblicklichen
		 Durchganges abfragen zu kînnen;

	       - Kommandozeilenschalter t, um einzelne Teile des As-
		 semblerlistings ausblenden zu kînnen;

	       - kennt zusÑtzlich die L-Variante der TLCS-900-Reihe
		 von Toshiba und die MELPS-7700-Reihe von Mitsubishi
		 (p1);

	       - P2HEX akzeptiert nun auch Dollarzeichen fÅr Start-
		 und Endadresse (p2);

	       - unterstÅtzt zusÑtzlich die TLCS90-Familie von Toshi-
		 ba (p2);

	       - P2HEX kann Daten zusÑtzlich im Tektronix- und 16-
		 Bit Intel-Hex-Format ausgeben (p2);

	       - bei Adre·Åberschreitungen gibt P2HEX Warnungen aus
		 (p2);

	       - Include-Datei STDDEF96.INC mit Adre·definitionen fÅr
		 die TLCS-900-Reihe (p3);

	       - Befehl READ, um Werte wÑhrend der Assemblierung
		 interaktiv einlesen zu kînnen (p3);

	       - Fehlermeldungen werden nicht mehr einfach auf die
		 Standardausgabe, sondern auf den von DOS dafÅr
		 vorgesehenen Kanal (STDERR) geschrieben (p3);

	       - Der beim 6811-Teil fehlende STOP-Befehl ist nun
		 da (scusi,p3);

	       - unterstÅtzt zusÑtzlich die ÊPD78(C)1x-Familie von
		 NEC (p3);

	       - unterstÅtzt zusÑtzlich den PIC16C84 von Microchip
		 (p3);

	       - Kommandozeilenschalter E, um die Fehlermeldungen in
		 eine Datei umleiten zu kînnen (p3);

	       - Die Unklarheiten im 78(C)1x-Teil sind beseitigt (p4);

	       - neben dem MELPS-7700 ist nun auch das "Vorbild" 65816
		 vorhanden (p4);

	       - Die ST62xx-Pseudoanweisung ROMWIN wurde entfernt und
		 mit in den \tt ASSUME\rm -Befehl eingegliedert (p4);

	       - unterstÅtzt zusÑtzlich den 6804 von SGS-Thomson (p4);

	       - durch die NOEXPORT-Option in der Makrodefinition kann
		 nun fÅr jedes Makro einzeln festgelegt werden, ob es
		 in der MAC-Datei erscheinen soll oder nicht (p4);

	       - Die Bedeutung von MACEXP fÅr Expansionen von Makros
		 hat sich wegen der zusÑtzlichen NOEXPAND-Option in
		 der Makrodefinition leicht geÑndert (p4);

	       - Durch die GLOBAL-Option in der Makrodefinition kînnen
		 nun zusÑtzlich Makros definiert werden, die durch
		 ihren Sektionsnamen eindeutig gekennzeichnet sind
		 (p4).

Version 1.40:  - unterstÅtzt zusÑtzlich den DSP56000 von Motorola;

	       - P2BIN kann nun auch das untere bzw. obere Wort aus
		 32-Bit-Wîrtern abtrennen;

	       - unterstÅtzt zusÑtzlich die TLCS-870- und TLCS-47-
		 Familie von Toshiba(p1);

	       - mit einem vorangestellten ! kann man durch Makros
		 "verdeckte" Maschinenbefehle wieder erreichen(p1);

	       - mit der GLOBAL-Anweisung lassen sich Symbolnamen
		 nun auch qualifiziert exportieren(p1);

	       - mit der r-Option kann man sich nun eine Liste der
		 Stellen erzeugen lassen, die zusÑtzliche DurchlÑufe
		 erzwangen(p1);

	       - bei der E-Option kann nun die Dateiangabe weggelas-
		 sen werden, so da· ein passender Default gewÑhlt
		 wird(p1);

	       - mit der t-Option kann nun die Zeilennumerierung im
		 Listing abgeschaltet werden(p1);

	       - Escapesequenzen sind nun auch in in ASCII geschrie-
		 benen Integerkonstanten zulÑssig(p1);

	       - Mit dem Pseudobefehl PADDING kann das EinfÅgen von
		 FÅllbytes im 680x0-Modus ein- und ausgeschaltet
		 werden (p2);

	       - ALIGN ist nun fÅr alle Zielplattformen erlaubt (p2);

	       - kennt zusÑtzlich die PIC16C64-SFRs (p2);

	       - unterstÅtzt zusÑtzlich den 8096 von Intel (p2);

	       - Bei DC kann zusÑtzlich ein Wiederholungsfaktor an-
		 gegeben werden (r3);

	       - unterstÅtzt zusÑtzlich die TMS320C2x-Familie von
		 Texas Instruments (Implementierung von Thomas
		 Sailer, ETH ZÅrich, r3); P2HEX ist auch entsprechend
		 erweitert;

	       - statt EQU darf nun auch einfach ein Gleichheits-
		 zeichen benutzt werden (r3);

	       - zur Definition von AufzÑhlungen zusÑtzlich ein
		 ENUM-Befehl (r3);

	       - END hat jetzt auch eine Wirkung (r3);

	       - zusÑtzliche Kommandozeilenoption n, um zu
		 Fehlermeldungen zusÑtzlich die internen Fehlernummern
		 zu erhalten (r3);

	       - unterstÅtzt zusÑtzlich die TLCS-9000er von Toshiba (r4);

	       - unterstÅtzt zusÑtzlich die TMS370xxx-Reihe von Texas
		 Instuments, wobei als neuer Pseudobefehl DBIT
		 hinzukam (r5);

	       - kennt zusÑtzlich die DS80C320-SFRs (r5);

	       - der Makroprozessor kann nun auch Includes aus Makros
		 heraus einbinden, wozu das Format von Fehlermeldungen
		 aber leicht geÑndert werden mu·te.  Falls Sie AS2MSG
		 verwenden, ersetzen Sie es unbedingt durch die neue
		 Version! (r5)

	       - unterstÅtzt zusÑtzlich den 80C166 von Siemens (r5);

	       - zusÑtzlich eine VAL-Funktion, um StringausdrÅcke
		 auswerten zu kînnen (r5).

	       - Mit Hilfe von in geschweiften Klammern eingeschlos-
		 senen Stringvariablen lassen sich nun selber Symbole
		 definieren (r5);

	       - kennt zusÑtzlich die Eigenheiten des 80C167 von
		 Siemens (r6);

	       - jetzt gibt es fÅr die MELPS740-Reihe auch die
		 special-page-Adressierung (r6);

	       - mit eckigen Klammern kann man explizit Symbole aus
		 einer bestimmten Sektion ansprechen.  Die Hilfs-
		 konstruktion mit dem Klammeraffen gibt es nicht
		 mehr (r6)!

	       - kennt zusÑtzlich die MELPS-4500-Reihe von Mitsubi-
		 shi (r7);

	       - kennt zusatzlich die H8/300 und H8/300H-Prozessoren
		 von Hitachi (r7);

	       - die mit LISTING und MACEXP gemachten Einstellungen
		 lassen sich nun auch wieder aus gleichnamigen Sym-
		 bolen auslesen (r7);

	       - kennt zusÑtzlich den TMS320C3x von Texas Instruments
		 (r8);

	       - kennt zusÑtzlich den SH7000 von Hitachi (r8);

               - der Z80-Teil wurde um die UnterstÅtzung des Z380
                 erweitert (r9);

               - der 68K-Teil wurde um die feinen Unterschiede der
                 683xx-Mikrokontroller erweitert (r9);

               - ein Label mu· nun nicht mehr in der ersten Spalte
                 beginnen, wenn man es mit einem Doppelpunkt
		 versieht (r9);

               - kennt zusÑtzlich die 75K0-Reihe von NEC (r9);

               - mit dem neuen Kommandozeilenschalter o kann der Name
                 der Code-Datei neu festgelegt werden (r9);

               - der ~~-Operator ist in der Rangfolge auf einen sinn-
                 volleren Platz gerutscht (r9);

               - ASSUME berÅcksichtigt fÅr den 6809 jetzt auch das
                 DPR-Register und seine Auswirkungen (pardon, r9);

               - Der 6809-Teil kennt nun auch die versteckten Erwei-
                 terungen des 6309 (r9);

               - BinÑrkonstanten kînnen jetzt auch in C-artiger Notation
                 geschrieben werden (r9).

Version 1.41:  - Åber das Symbol MOMSEGMENT kann der momentan gesetzte
                 Adre·raum abgefragt werden;

               - anstelle von SET bzw. EVAL kann jetzt auch einfach :=
                 geschrieben werden;

               - mit der neuen Kommandozeilenoption q kann ein "stiller"
                 Assemblerlauf erzwungen werden;

               - das SchlÅsselwort PARENT zum Ansprechen der Vatersektion
                 wurde um PARENT0...PARENT9 erweitert;

               - der PowerPC-Teil wurde um die Mikrokontroller-Versionen
                 MPC505 und PPC403 erweitert;

               - mit SET oder EQU definierte Symbole kînnen nun einem
                 bestimmten Adre·raum zugeordnet werden;

               - durch das Setzen der Environment-Variablen USEANSI
                 kann die Verwendung von ANSI-Bildschirmsteuersequenzen
                 an-und ausgeschaltet werden (r1);

               - der SH7000-Teil kennt jetzt auch die SH7600-Befehls-
                 erweiterungen (und sollte jetzt korrekte Displacements
                 berechnen...) (r1);

               - im 65XX-Teil wird jetzt zwischen 65C02 und 65SC02
	         unterschieden (r1);

               - neben der Variablen MOMCPU gibt es jetzt auch den
	         String MOMCPUNAME, der den Prozessornamen im Voll-
                 text enthÑlt (r1);

               - P2HEX kennt jetzt auch die 32-Bit-Variante des
                 Intel-Hex-Formates (r1);

               - kennt jetzt auch die EinschrÑnkungen des 87C750 (r2);

               - die Nummern fÅr fatale Fehlermeldungen wurden auf den
                 Bereich ab 10000 verschoben, um Platz fÅr normale
                 Fehlermeldungen zu schaffen (r2);

               - unbenutzte Symbole werden in der Symboltabelle jetzt
                 mit einem Stern gekennzeichnet (r2);

               - unterstÅtzt zusÑtzlich die 29K-Familie von AMD (r2);

               - unterstÅtzt zusÑtzlich die M16-Familie von Mitsu-
                 bishi (r2);

               - unterstÅztzt zusÑtzlich die H8/500-Familie von
	         Hitachi (r3);

               - die Anzahl von Datenbytes, die P2HEX pro Zeile aus-
                 gibt, ist jetzt variierbar (r3);

               - der Pass, ab dem durch die -r-Option erzeugte War-
	         nungen ausgegeben werden, ist einstellbar (r3);

               - der Makroprozessor kennt jetzt ein WHILE-Statement,
                 mit dem ein Code-StÅck eine variable Anzahl wieder-
		 holt werden kann (r3);

               - der PAGE-Befehl erlaubt es nun auch, die Breite des
                 Ausgabemediums fÅrs Listing anzugeben (r3);

               - Um neue Pseudo-Prozessortypen einfÅhren zu kînnen,
                 lassen sich jetzt CPU-Aliasse definieren (r3);

               - unterstÅztzt zusÑtzlich die MCS/251-Familie von
	         Intel (r3);

               - bei eingeschalteter Querverweisliste wird bei dop-
                 pelt definierten Symbolen die Stelle der ersten
                 Definition angezeigt (r3);

               - unterstÅtzt zusÑtzlich die TMS320C5x-Familie von
		 Texas Instruments (Implementierung von Thomas
                 Sailer, ETH ZÅrich, r3);

               - die OS/2-Version sollte jetzt auch mit langen Da-
                 teinamen klarkommen.  Wenn man nicht jeden Mist
                 selber kontrolliert... (r3)

               - Åber den Befehl BIGENDIAN kann im MCS-51/251-Modus
                 jetzt gewÑhlt werden, ob die Ablage von Konstanten
                 im Big- oder Little-Endian-Format erfolgen soll
                 (r3);

               - es wird beim 680x0 jetzt zwischen dem vollen und 
                 eingeschrÑnkten Befehlssatz unterschieden; eine
                 manuelle Umschaltung ist mit dem FULLPMMU-Befehl
                 mîglich (r3);

               - Åber die neue Kommandozeilenoption I kann eine
                 Liste aller eingezogenen Include-Files mit ihrer
                 Verschachtelung ausgegeben werden (r3);

               - unterstÅtzt zusÑtzlich die 68HC16-Familie von
		 Motorola (r3);

               - Beim END-Statement kann jetzt zusÑtzlich ein
                 Einsprungpunkt fÅr das Programm angegeben werden
                 (r3);

               - P2HEX und P2BIN erlauben es jetzt, den Inhalt einer
                 Code-Datei adre·mÑ·ig zu verschieben (r4);

               - einem SHARED-Befehl anhÑngende Kommentare werden
                 jetzt in die Share-Datei mit Åbertragen (r4);

               - unterstÅtzt zusÑtzlich die 68HC12-Familie von
                 Motorola (r4);

               - unterstÅtzt zusÑtzlich die XA-Familie von Philips
                 (r4);

               - unterstÅtzt zusÑtzlich die 68HC08-Familie von
                 Motorola (r4);

               - unterstÅtzt zusÑtzlich die AVR-Familie von
                 Atmel (r4);

               - aus KompatibilitÑt zum AS11 von Motorola existieren 
                 zusÑtzlich die Befehle FCB, FDB, FCC und RMB (r5);

               - unterstÅtzt zusÑtzlich den M16C von Mitsubishi (r5);

               - unterstÅtzt zusÑtzlich den COP8 von National Semi-
                 conductor (r5);

               - zwei neue Befehle zur bedingten Assemblierung: IFB
                 und IFNB (r5);

               - mit dem EXITM-Befehl ist es nun mîglich, eine Makro-
                 expansion vorzeitig abzubrechen (r5);

               - unterstÅtzt zusÑtzlich den MSP430 von Texas Instru-
                 ments (r5);

               - LISTING kennt zusÑtzlich die Varianten NOSKIPPED und
                 PURECODE, um nicht assemblierten Code aus dem Listing
                 auszublenden (r5);

               - unterstÅtzt zusÑtzlich die 78K0-Familie von NEC (r5);

               - BIGENDIAN ist jetzt auch im PowerPC-Modus verfÅgbar
                 (r5);

               - zusÑtzlich ein BINCLUDE-Befehl, um BinÑrdaten ein-
                 binden zu kînnen (r5);

               - zusÑtzliche TOLOWER- und LOWSTRING-Funktionen, um
                 Gro·- in Kleinbuchstaben umzuwandeln (r5);

               - es ist jetzt mîglich, auch in anderen Segmenten als
                 CODE Daten abzulegen.  Das Dateiformat wurde ent-
                 sprechend erweitert (r5);

               - der DS-Befehl, mit dem man Speicherbereiche reser-
                 vieren kann, ist jetzt auch im Intel-Modus zulÑssig
                 (r5);

               - Mit der Kommandozeilenoption U ist es jetzt mîglich,
                 AS in einen case-sensitiven Modus umzuschalten, in
                 dem Namen von Symbolen, selbstdefinierten Funktionen,
                 Makros, Makroparametern sowie Sektionen nach Gro·-
                 und Kleinschreibung unterschieden werden (r5);

               - SFRB berÅcksichtigt jetzt auch die Bildungsregeln 
                 fÅr Bitadressen im RAM-Bereich; werden nicht bit-
                 adressierbare Speicherstellen angesprochen, erfolgt
                 eine Warnung (r5);

               - zusÑtzliche Pseudobefehle PUSHV und POPV, um Symbol-
                 werte temporÑr zu sichern (r5);

               - zusÑtzliche Funktionen BITCNT, FIRSTBIT, LASTBIT und
                 BITPOS zur Bitverarbeitung (r5);

               - bei den CPU32-Prozessoren ist jetzt auch der 68360 
                 berÅcksichtigt (r5);


        H. Hinweise zum Quellcode von AS
	================================

Wie in der Einleitung erwÑhnt, gebe ich nach RÅcksprache den Quellcode
von AS heraus.  Im folgenden sollen einige Hinweise zu dessen Handhabung
gegeben werden.


	H.1 Sprachvoraussetzungen
	-------------------------

AS ist in Turbo-Pascal implementiert worden.  "Aua", hîre ich jetzt
die C-Freaks schreien, "in C geht so etwas doch viel besser, au·erdem
ist es dann beliebig portabel!"  Jaaaa, wenn das alles so einfach
wÑre...AS ist ein Projekt, das ich nun schon seit einigen Jahren
verfolge, und zu der Zeit, als ich damit anfing, bestand die Betriebs-
systemwelt des PC-Benutzers aus DOS, DOS und DOS, und die Erfahrung, 
da· ich ohne Festplatte schon bei Turbo-C mit 4 Disketten jonglieren
mu·te, Turbo-Pascal aber immer noch auf eine pa·te, wirkte noch sehr
deutlich nach.  Auch das Dickicht der Speichermodelle eines DOS-C-
Compilers machte die Sache nicht attraktiver.  Au·erdem kannte ich
mich mit Turbo-Pascal am besten aus, und es war die Sprache, in der
ich am produktivsten war.  C hatte ich durchaus schon einmal auspro-
biert, und es machte auf mich einen chaotischen und archaischen Ein-
druck:


  - Die Strukturierung oberhalb der Funktionsebene hat Assemblerni-
    veau (das eines normalen Assemblers, AS kann durch das Konzept
    lokaler Variablen in dieser Hinsicht eher mehr als C), es ist
    nicht mîglich, Prozeduren zu deklarieren, die lokal zu einer
    anderen Prozedur sind und auf deren Variablen zugreifen kînnen.
    Wer portable Programme schreiben will, dem helfen Spracherwei-
    terungen wie in CNU-C hier auch nicht richtig weiter!

  - Ein dem WITH-Befehl von Pascal entsprechendes Konstrukt fehlt.

  - Es gab keine brauchbare Typ-PrÅfung der Parameter bei Funktio-
    nen, wenn man sich auf den damals noch aktuellen K&R-Standard
    beschrÑnkte.

  - Man kann keine Funktionen schreiben, die einen String als WERT
    erhalten oder zurÅckgeben, was den Programmierer dazu zwingt,
    per Hand umstÑndliche und aufwendige Hin-und Herkopierereien
    durchzufÅhren.

All das fÅhrte dazu, da· ich Turbo-Pascal zur Implementierung von
AS benutzte, und bis heute ist das so geblieben.  Die Zeiten haben
sich aber geÑndert: Mit der Einstellung der Turbo/Borland-Pascal-
Linie durch Borland gibt es an aktuellen Pascal-Compilern nur noch
so etwas wie Delphi, das m.E. eigentlich nur zur Entwicklung von
Programmen taugt, die aus 90% OberflÑche bestehen, fÅr ein kommando-
zeilengesteuertes Programm wie AS also vîllig ungeeignet ist. 
Au·erdem hat sich mein betriebssystemmÑ·iger Schwerpunkt inzwischen
deutlich in Richtung Unix verschoben, und der ANSI-Standard hat sich
inzwischen durchgesetzt.  Eine Portierung der AS-Sourcen auf C habe
ich daher inzwischen fast beendet, momentan ist die Pascal-Version 
aber noch die "Referenz".  Zum öbersetzen wird Borland-Pascal in 
der Version 7 empfohlen; mit Version 6 geht es zur Not zwar auch,
man kann einige Features (wie Protected Mode) aber nicht ausnutzen.

Ein nicht ganz unwichtiger Hinweis fÅr Anwender der Version 7.0 von
Turbo/Borland-Pascal: Wie sich schon lÑnger herumgesprochen hat, hat
diese Version einige Bugs, weshalb Borland auch gezwungen war, die
Version 7.01 herauszugeben.  Bei AS tritt das Problem auf, da·
teilweise Longint-Schiebebefehle mit einer Amplitude von mehr als 16
verwendet werden, fÅr die die Version 7.0 eine fehlerhafte 386-Opti-
mierung enthÑlt.  Wenn Sie (wie ich) nicht das Geld fÅr den Update
auf 7.01 ausgeben wollen und die Quellen der Laufzeitbibliothek
besitzen, kînnen Sie den Fehler auch selber beseitigen, indem Sie die
beiden fehlerhaften Routinen in LONG.ASM austauschen, z.B. so:

; Longint shift right
; In	DX:AX = Value
;	CX    = Shift count
; Out	DX:AX = Result
; Correction 11.6.1994 AA

LongShr:

	CMP	Test8086,2
	JB	@@1
    .386
        SHL     EAX,16
        SHRD    EAX,EDX,16
        SHR     EAX,CL
        SHLD    EDX,EAX,16
	RETF
    .8086
@@1:	AND	CX,1FH
	JE	@@3
@@2:	SHR	DX,1
	RCR	AX,1
	LOOP	@@2
@@3:	RETF

; Longint shift left
; In	DX:AX = Value
;	CX    = Shift count
; Out	DX:AX = Result
; Correction 11.6.1994 AA

LongShl:

	CMP	Test8086,2
	JB	@@1
    .386
        SHL     EAX,16
        SHRD    EAX,EDX,16
        SHL     EAX,CL
        SHLD    EDX,EAX,16
	RETF
    .8086
@@1:	AND	CX,1FH
	JE	@@3
@@2:	SHL	AX,1
	RCL	DX,1
	LOOP	@@2
@@3:	RETF

Wer keine Quellen hat, kann alternativ auch als "Notlîsung" die Vari-
able Test8086 im Hauptprogramm auf einen Wert <2 setzen und so die
Optimierungen ganz unterbinden...

        H.2 Modulaufteilung
        -------------------

Programme in der Grî·e von AS mÅssen notwendigerweise in mehrere Mo-
dule aufgespalten werden, nicht nur um eine vernÅnftige Strukturie-
rung zu erreichen, sondern auch, um unter DOS die ewige 64KByte-
Grenze zu Åberwinden.  Im einzelnen besteht AS aus folgenden Modulen:

        STDINC.PAS

Dies ist im eigentlichen Sinne kein Modul, sondern eine Include-Datei,
die von allen anderen Modulen eingebunden wird.  Sie enthÑlt die
unvermeidlichen Compiler-Schalter, die sich je nach Zielplattform
etwas unterscheiden.

	AS.PAS

Diese Datei enthÑlt das Hauptmodul von AS und mu· demzufolge in der
IDE als Hauptdatei eingetragen werden.  Sie beinhaltet die Åberge-
ordnete Steuerung der einzelnen DurchlÑufe, das Einlesen der Quell-
dateien, das Schreiben der Code-Datei sowie den Makroprozessor.
Dieser Programmteil ist unabhÑngig vom Zielprozessor.

        ASMDEF.PAS

Dieses Modul enthÑlt lediglich Deklarationen von Åberall benîtigten
Konstanten und gemeinsam benutzten Variablen.  Wichtig fÅr Erweite-
rungen sind die hier definierten Listen mit den vorhandenen Pro-
zessoren und ihren Namen.  Die Nummer, die fÅr einen Prozessortyp
unter dem Symbol MOMCPU abfragbar ist, leitet AS automatisch aus dem
Namen ab, deshalb findet sich hierfÅr keine Liste.

        ASMSUB.PAS

Hier finden sich gesammelt einige hÑufig gebrauchte Unterroutinen,
welche in erster Linie die Bereiche Stringbearbeitung und Fehler-
behandlung abdecken.

        ASMPARS.PAS

Hier geht es ins Eingemachte: In diesem Modul werden die Symbolta-
bellen (global und lokal) in zwei BinÑrbÑumen verwaltet.  Au·erdem
findet sich hier eine ziemlich gro·e Prozedur EvalExpression, wel-
che einen (Formel-)ausdruck analysiert und auswertet.  Die Proze-
dur liefert das Ergebnis (Integer, Gleitkomma oder String) in
einem varianten Record zurÅck.  Zur Auswertung von AusdrÅcken bei
der Codeerzeugung sollten allerdings eher die Funktionen EvalInt-
Expression, EvalFloatExpression und EvalStringExpression verwendet
werden.  énderungen zum EinfÅgen neuer Prozessoren sind hier nicht
erforderlich und sollten auch nur mit Ñu·erster öberlegung erfolgen,
da man hier sozusagen an "die Wurzel" von AS greift.

	ASMMAC.PAS

In diesem Modul finden sich die Routinen zur Speicherung und
Abfrage von Makros.  Der eigentliche Makroprozessor befindet sich
in AS.PAS!!

	ASMIF.PAS

Hier befinden sich alle Routinen, die die bedingte Assemblierung
steuern.  Exportiert wird als wichtigste Variable das Flag IfAsm,
welches anzeigt, ob Codeerzeugung momentan ein- oder ausgeschal-
tet ist.

	CODEALLG.PAS

In diesem Modul werden all die Befehle bearbeitet, die fÅr alle Pro-
zessoren definiert sind, z.B. EQU und ORG.  Hier findet sich auch
der  CPU-Befehl, mit dem zwischen den einzelnen Prozessoren hin-und
hergeschaltet wird.  Von diesem Modul wird im spÑteren Verlauf noch
einmal die Rede sein.

	CODEPSEU.PAS

Hier finden sich Pseudobefehle, die von mehreren Codegeneratoren ver-
wendet werden.  Dies ist einmal die Intel-Gruppe mit der DB..DT-
Gruppe, zum anderen die Pendants fÅr die 8-Bitter von Motorola oder
Rockwell.  Wer in diesem Bereich um einen Prozessor erweitern will,
kann mit einem Aufruf den grî·ten Teil der Pseudobefehle erschlagen.

	DECODECM.PAS

Dieses Modul implemetiert den Mechanismus der Kommandozeilenparameter.
Es benîtigt eine Spezifikation der erlaubten Parameter, zerlegt die
Kommadozeile und ruft die entsprechenden Callbacks auf.
Der Mechanismus leistet im einzelnen folgendes:

  - Mitbearbeitung von Optionen in einer Environment-Variablen oder
    entsprechenden Datei;

  - RÅckgabe einer Menge, welche die noch nicht bearbeiteten Kommando-
    zeilenparameter beschreibt;

  - Trenunng von positiven und negativen Schaltern;

  - Eine HintertÅr, falls die darÅberliegende Entwicklungsumgebung die
    Kommandozeile nur in Gro·- oder Kleinschreibung Åbergibt.

Dieses Modul wird nicht nur von AS, sondern auch von den Hilfsprogram-
men BIND, P2HEX und P2BIN verwendet.

	STDHANDL.PAS

Dieses mit Abstand kÅrzeste Modul dient nur einem einzigen Zweck (und
ist vielleicht auch in anderen Programmen nÅtzlich).  Es ergÑnzt
Pascal um die von C her bekannte Mîglichkeit, auf die neben Standard-
eingabe und -ausgabe von DOS vordefinierten KanÑle

 - STDERR (Ausgabe Fehlermeldungen)
 - STDPRN (Default-Drucker)
 - STDAUX (serielle Schnittstelle)

Åber normale Text-Variablen zuzugreifen.  AS benutzt momentan nur
STDERR.

	NLS.PAS

Hiermit wird ein Thema abgehandelt, das sowohl von Borland als auch
den meisten Programmierern eher stiefmÅtterlich behandelt wird: der
National Language Support (kurz NLS), den es bei DOS schon seit
Version 2.0 gibt.  Diese Unit liefert die Informationen Åber Dinge,
die sich von Land zu Land unterscheiden:

- Datumsformat: Reihenfolge von Tag, Monat und Jahr sowie das Trenn-
  zeichen;
- Zeitformat: 12- oder 24-Stunden-Format;
- Umsetzung von Klein- in Gro·buchstaben;
- Trennzeichen fÅr Tausender- und Nachkommastellen;
- WÑhrungsname und -format;
- Sortierreihenfolge von Zeichen.

AS benutzt noch nicht alle von dieser Unit angebotenen Informationen
(was will man auch dort mit GeldbetrÑgen? :-) ), die NLS-UnterstÅt-
zung wird in Zukunft aber noch besser werden.  Insbesondere diese
Unit bietet sich zur Verwendung in anderen Programmen an: Durch
schlichtes Einbinden erhÑlt man eine korrekt fÅr alle Zeichen arbei-
tende UpCase-Funktion, die Borland uns schon seit Jahren vorenthÑlt!

        STRINGLI.PAS

Dies ist nur ein kleiner "Hack", der Routinen zur Verwaltung von linearen
Listen mit Strings als Inhalt definiert, welche z.B. im Makroprozessor von
AS gebraucht werden.

        STRINGUT.PAS

Hier sind einige hÑufig genutzte String-Operationen gelandet.

        CHUNKS.PAS

Dieses Modul definiert einen Datentyp, mit dem eine Liste von Adre·-
bereichen verwaltet werden kann.  Dies Funktion wird von AS fÅr die 
Belegungslisten benîtigt, au·erdem benutzten P2BIN und P2HEX diese 
Listen, um vor öberlappungen zu warnen.

        INCLIST.PAS

In diesem Modul ist die Listenstruktur definiert, Åber die AS die 
Verschachtelung von Include-Dateien im Listing ausgeben kann.

	CODExxxx.PAS

Diese Dateien schlu·endlich enthalten die eigentlichen Codegeneratoren
fÅr die verschiedenen Prozessoren.  Sie sind alle nach dem gleichen
Schema aufgebaut (natÅrlich mit unterschiedlichem Inhalt!), das im
folgenden Abschnitt erklÑrt wird.


        H.3 Neuer Prozessor...was nun ?
	-------------------------------

Der mit Abstand hÑufigste Grund, im Quellcode von AS etwas zu ver-
Ñndern, dÅrfte wohl die Erweiterung um einen neuen Zielprozessor
sein.  Das Verfahren der Definition eines neuen Prozessors hat sich
mit V1.39p5 drastisch geÑndert: Es ist wesentlich indirekter geworden,
hat aber den Vorteil, da· in den Standard-Modulen von AS nur noch an
EINER Stelle etwas geÑndert werden mu·.  Es beruht sehr stark auf in-
direkten Verweisen und Prozedurvariablen, verlangt also schon etwas
vertiefte Kenntnisse von (Turbo-)Pascal.  Wer aber in Assembler pro-
grammiert, sollte damit keine grundsÑtzlichen Probleme haben.
Im folgenden will ich kochbuchartig die zum EinhÑngen erforderlichen
Schritte beschreiben:


	Festlegung des Prozessornamens
	- - - - - - - - - - - - - - -

Der fÅr den Prozessor zu wÑhlende Name mu· zwei Kriterien erfÅllen:

 1. Der Name darf noch nicht von einem anderen Prozessor belegt sein.
    Beim Aufruf von AS ohne Parameter erhÑlt man eine Liste der be-
    reits vorhandenen Typen.

 2. Soll der Prozessorname vollstÑndig in der Variablen MOMCPU auf-
    tauchen, so darf er au·er am Anfang keine Buchstaben au·erhalb
    des Bereiches von A..F enthalten.  In der Variablen MOMCPUNAME
    liegt aber zur Assemblierzeit immer der volle Name vor.
    Sonderzeichen sind generell nicht erlaubt, Kleinbuchstaben
    werden von AS bei der Eingabe in Gro·buchtaben umgewandelt
    und sind daher auch nicht im Prozessornamen sinnvoll.


	Definition des Codegeneratormoduls
	- - - - - - - - - - - - - - - - -

Die Unit, die fÅr den neuen Prozessor zustÑndig sein soll, sollte
einer gewissen Einheitlichkeit wegen den Namen CODExxxx tragen,
wobei xxxx etwas mit dem Prozessornamen zu tun haben sollte.  Den
Kopf mit den Compilerschaltern sowie den Uses-Anweisungen Åbernimmt
man am besten direkt aus einer bereits vorhandenen Codegenerator-Unit.

Die Unit selber mu· weder Variablen noch Prozeduren oder Funktionen
nach au·en exportieren, da die ganze Kommunikation zur Laufzeit Åber
indirekte SprÅnge abgewickelt wird.  Die dazu erforderlichen Initia-
lisierungen mÅssen im Initialisierungsteil der Unit vorgenommen
werden, indem fÅr jeden von der Unit zu behandelnden Prozessortyp
ein Aufruf der Funktion AddCPU erfolgt:

   CPUxxxx:=AddCPU('XXXX',SwitchTo_xxxx);

'XXXX' ist dabei der fÅr den Prozessor festgelegte Name, der spÑter
im Assemblerprogramm verwendet werden mu·, um AS auf diesen Zielpro-
zessor umzuschalten.  SwitchTo_xxxx (im folgenden kurz als "Umschal-
ter" bezeichnet) ist eine parameterlose Prozedur, die von AS aufge-
rufen wird, sobald auf diesen Prozessor umgeschaltet werden soll.
Als Ergebnis liefert AddCPU eine Zahlenwert, der als interne "Ken-
nung" fÅr diesen Prozessor fungiert.  In der globalen Variablen
MomCPU wird stÑndig die Kennung des momentan gesetzten Zielprozes-
sors mitgefÅhrt.  Der von AddCPU gelieferte Wert sollte in einer
privaten Variable des Typs CPUVar (hier CPUxxxx genannt) abgelegt
werden.  Falls ein Codegeneratormodul verschiedene Prozessoren (z.B.
einer Familie) verwaltet, kann es so durch Vergleich von MomCPU
gegen diese Werte feststellen, welche Befehlsuntermenge momentan
zugelassen ist.

Dem Umschalter obliegt es, AS auf den neuen Zielprozessor "umzupo-
len".  Dazu mÅssen im Umschalter einige globale Variablen besetzt
werden:

  - ConstMode: Diese Variable kann die Werte ConstModeIntel,
    ConstModeMoto oder ConstModeC haben und bestimmt, in welcher
    Form Zahlensysteme bei Integerkonstanten spezifiziert werden
    sollen.

  - PCSymbol: Diese Variable enthÑlt den String, mit dem aus dem As-
    sembler-Programm heraus der momentane Stand des ProgrammzÑhlers
    abgefragt werden kann.  FÅr Intel-Prozessoren ist dies z.B. ein
    Dollarzeichen.

  - HeaderID: Dieses Byte enthÑlt die Kennung, mit der in der Code-
    datei die Prozessorfamilie gekennzeichnet wird (s. das Kapitel,
    welches das Code-Format von AS beschreibt).  Um Zweideutigkeiten
    zu vermeiden, bitte ich, den Wert mit mir abzusprechen.  Auf
    jeden Fall sollten Werte au·erhalb des Bereiches $01..$7f benutzt
    werden, diese sind fÅr Sonderzwecke (wie z.B. eine zukÅnftige
    Erweiterung um einen Linker) reserviert.

  - NOPCode: In bestimmten Situationen kann es sein, da· AS unbenutz-
    te Bereiche im Code mit NOPs auffÅllen mu·.  Diese Variable be-
    inhaltet den dazu erforderlichen Code.

  - SetIsOccupied: Einige Prozessoren verwenden SET als Maschinenbe-
    fehl.  Wird diese Variable gesetzt, so gibt AS SET-Befehle an den
    Codegenerator weiter und verwendet stattdessen EVAL.

  - ValidSegs: Nicht alle Prozessoren definieren alle von AS unter-
    stÅtzten Adre·rÑume.  Mit dieser Menge legt man fest, welche
    Untermenge fÅr den jeweiligen Prozessor von SEGMENT-Befehl zu-
    gelassen wird.  Im mindesten mu· das Code-Segment freigeschaltet
    werden.  Die Gesamtmenge aller vorhandenen Segmenttypen kann im
    Modul ASMDEF nachgelesen werden (Seg.....-Konstanten).

  - SegInits: Dieses Feld speichert die initialen (ohne ORG-Befehl)
    Startadressen in den einzelnen Segmenten.  Nur in Ausnnahme-
    fÑllen (physikalisch Åberlappende, aber logisch getrennte Adre·-
    rÑume) sind hier andere Werte als 0 sinnvoll.

  - Grans: Hiermit kann fÅr jedes Segment die Grî·e des kleinsten
    adressierbaren Elements in Bytes festgelegt werden, d.h. die
    Grî·e des Elements, fÅr das eine Adresse um eins erhîht wird.
    Bei den allermeisten Prozessoren (auch 16 oder 32 Bit) ist dies
    ein Byte, nur Signalprozessoren und die PICs fallen z.B. aus dem
    Rahmen.

  - ListGrans: Hiermit kann wieder fÅr alle Segmente getrennt fest-
    gelegt werden, in was fÅr Gruppen die Bytes im Assemblerlisting
    dargestellt werden sollen.  Beim 68000 sind z.B. Befehle immer
    ein mehrfaches von 2 Bytes lang, weshalb die entsprechende Va-
    riable auf 2 gesetzt ist.

  - TurnWords: Falls der Prozessor ein Big-Endian-Prozessor sein
    sollte und eines der Elemente von ListGrans ungleich eins ist,
    sollte dieses Flag auf True gesetzt werden, um korrekte Code-
    Dateien zu erhalten.

  - DivideChars: Dieser String enthÑlt all jene Zeichen, die als
    Trennzeichen fÅr die Parameter eines Assemblerbefehls zugelassen
    sind.  Nur fÅr extreme Ausrei·er (wie den DSP56) sollte sich in
    diesem String etwas anderes finden als ein Komma.

  - HasAttrs: Einige Prozessoren wie die 68k-Reihe teilen einen
    Maschinenbefehl durch einen Punkt noch weiter in Mnemonic und
    Attribut auf.  Ist dies beim neuen Prozessor auch der Fall, so
    ist dieses Flag auf True zu setzen.  AS liefert dann die Einzel-
    teile in den Variablen OpPart und AttrPart.  Setzt man es dagegen
    auf False, so bleibt der Befehl in OpPart zusammen, und AttrPart
    ist immer leer.  Sofern der Prozessor keine Attribute verwendet,
    sollte man HasAttrs auf jeden Fall auf False setzen, da man sich
    sonst die Mîglichkeit nimmt, Makros mit einem Punkt im Namen
    (z.B. zur Emulation anderer Assembler) zu definieren.

  - AttrChars : Falls HasAttrs gesetzt wurde, mÅssen in diesem String
    alle Zeichen eingetragen werden, die das Attribut vom Befehl
    trennen kînnen.  Meist ist dies nur der Punkt.

Gehen Sie nicht davon aus, da· eine dieser Variablen einen vordefi-
nierten Wert hat, sondern besetzen Sie ALLE Felder neu!!

Neben diesen Variablen sind noch drei Prozedurvariablen zu besetzen,
die die Verbindung von AS zu den "aktiven" Teilen des Codegenerator-
moduls herstellen:

  - MakeCode: Diese Routine wird nach der Zerlegung einer Zeile
    in Mnemonic und Parameter aufgerufen.  Das Mnemonic liegt in der
    Variablen OpPart, die Parameter in dem Feld ArgStr.
    Die Zahl der Parameter kann aus der Variablen ArgCnt ausgelesen
    werden.  Das binÑre Ergebnis mu· in dem Byte-Feld BAsmCode abge-
    legt werden, dessen LÑnge in der Variablen CodeLen.  Falls der
    Prozessor wortorientiert wie der 68000 oder viele Signalprozesso-
    ren ist, kann Feld auch wortweise als WAsmCode adressiert werden.
    FÅr ganz extreme FÑlle gibt es auch noch DAsmCode ... Die Code-
    lÑnge wird ebenfalls in solchen Einheiten angegeben.

  - ChkPC: Obwohl AS die ProgrammzÑhler intern durchgÑngig mit
    32 Bit verwaltet, benutzen die meisten Prozessoren nur einen
    kleineren Adre·raum.  Diese Funktion liefert AS Informationen, ob
    der momentane ProgrammzÑhler den erlaubten Bereich Åberschritten
    hat.  Bei Prozessoren mit mehreren Adre·rÑumen kann diese Routine
    natÅrlich deutlich komplizierter ausfallen.  Ein Beispiel dafÅr
    findet sich z.B. im Modul Code51.  Falls alles in Ordnung ist,
    mu· die Funktion TRUE zurÅckliefern, ansonsten FALSE.
    VORSICHT!  Da Turbo-Pascal momentan noch keine vorzeichenlosen
    32-Bit-Integers kennt, mu· hier damit gerechnet werden, da· der
    ProgrammzÑhlerwert negativ ist!  Eine Abfrage, ob der momentane
    Wert kleiner Null ist, ist daher keine Schînheitsoperation, son-
    dern unbedingt notwendig!

  - IsDef: Bestimmte Prozessoren kennen neben EQU noch weitere
    Pseudobefehle, bei denen ein in der ersten Spalte stehender
    Symbolname kein Label darstellt, z.B. BIT beim 8051.  Diese
    Funktion mu· TRUE zurÅckliefern, falls ein solcher, zusÑtz-
    licher Befehl vorliegt.  Im einfachsten Fall braucht nur FALSE
    zurÅckgeliefert zu werden.

  - SwitchFrom: Diese parameterlose Prozedur erlaubt dem Codegene-
    ratormodul, noch "AufrÑumarbeiten" durchzufÅhren, wenn auf einen
    anderen Zielprozessor umgeschaltet wird.  So kann man an dieser
    Stelle z.B. Speicher freigeben, der im Umschalter belegt wurde
    und nur benîtigt wird, wÑhrend dieses Codegeneratormodul aktiv
    ist.  Im einfachsten Fall zeigt diese Prozedurvariable auf eine
    leere Prozedur.  Ein Beispiel fÅr die Anwendung dieser Prozedur
    finden Sie im Modul CODE370, das seine Codetabellen dynamisch
    erzeugt und wieder freigibt.

Die Routinen, auf die diese drei Prozedurvariablen zeigen, sind alle
parameterlos und mÅssen (wie der Umschalter Åbrigens auch) als FAR
deklariert werden, sonst kînnen sie nicht einer Prozedurvariable zu-
gewiesen werden.

Bei Bedarf kann sich die Unit im Initialisierungsteil noch in die
Kette aller Funktionen eintragen, die vor Beginn eines Durchlaufes
durch den Quelltext ausgefÅhrt werden.  Dies ist z.B. immer dann der
Fall, wenn die Code-Erzeugung im Modul abhÑngig vom Stand bestimmter,
durch Pseudobefehle beeinflu·barer Flags ist.  Ein hÑufig auftreten-
der Fall ist z.B., da· ein Prozessor im User- oder Supervisor-
Modus arbeiten kann, wobei im User-Modus bestimmte Befehle gesperrt
sind.  Im Assembler-Quelltext kînnte dieses Flag, das angibt, in wel-
chem Modus der folgende Code ausgefÅhrt wird, durch einen Pseudobe-
fehl umgeschaltet werden.  Es ist aber dann immer noch eine Initia-
lisierung erforderlich, die sicherstellt, da· in allen DurchlÑufen
ein identischer Ausgangszustand vorliegt.  Der Åber die Prozedur-
variable InitPassProc angebotene Haken bietet die Mîglichkeit, der-
artige Initialisierungen vorzunehmen.  Das verwendete Prinzip Ñhnelt
dabei dem EinhÑngen in einen Interruptvektor: In der Initialisierung
der Unit wird der alte Wert von InitPassProc gesichert.  Danach kann
InitPassProc auf die hinzuzufÅgende Routine (parameterlose, FAR
deklarierte Prozedur) umgebogen werden.  Die neue Routine ruft dann
zuerst die alte Initialisierungsroutine auf und fÅhrt danach ihre
eigenen Operationen durch.

Analog zu InitPassProc funktioniert die Åber CleanUpProc aufgebaute
Prozedurkette, die es den Codegeneratoren erlaubt, nach dem Abschlu·
der Assemblierung noch AufrÑumarbeiten (z.B. das Freigeben von
Literaltabellen o.Ñ.) durchzufÅhren.  Dies ist sinnvoll, wenn mehrere
Dateien mit einem Aufruf assembliert werden, sonst hÑtte man noch
"MÅll" aus einem vorigen Lauf in den Tabellen.  Momentan nutzt kein
Modul diese Mîglichkeit.

Bisweilen sind bei einem bestimmten Prozessor Symbole definiert,
ohne da· man sie irgendwo explizit erzeugen mÅ·te.  Ein Beispiel
ist z.B. die TMS370-Reihe, bei der z.B. die ersten 256 Speicherzel-
len als "Register" R0..R255 bzw. R0FF angesprochen werden kînnen.
DafÅr existiert in AS eine Prozedurvariable InternSymbol, die vom
Codegenerator belegt werden kann.  Wann immer der Formelparser einen
Ausdruck analysieren mu·, ruft er diese Routine nach der Untersuchung
auf Konstanten hin auf.  Falls die Routine ein vordefiniertes Symbol
erkennt, mu· sie das Ergebnis in einen Åbergebenen Record des Typs
TempResult eintragen, d.h. das Feld Typ mit der Art des Ergebnisses
(empInt fÅr Integer, TempFloat fÅr Gleitkomma oder TempString fÅr
Strings) belegen sowie das eigentliche Ergebnis in eines der Felder
Int, Float oder Ascii eintragen.  War die Untersuchung erfolglos, so
schreiben Sie einfach TempNone in das Feld Typ.  Fehlermeldungen aus
dieser Routine heraus sollten vermieden werden, da nicht zu identi-
fizierende Namen normale Symbole bezeichnen kînnten (was der Parser
dann im folgenden abprÅft).  Seien Sie vorsichtig mit dieser Routine,
da Sie mit ihr mitten in den Parser hineingreifen kînnen!

Wer will, kann sich Åbrigens auch mit einem Copyright-Eintrag ver-
ewigen, indem er in der Initialisierung der Unit (bei den AddCPU-
Befehlen) einen Aufruf der Prozedur AddCopyright einfÅgt, in der
folgenden Art:

    AddCopyright("Intel 80986-Codegenerator (C) 2010 Hubert Simpel");

Der Åbergebene String wird dann nach dem Programmstart zusÑtzlich
zu der Standardmeldung ausgegeben.


	Eintragen des Codegeneratormodules
	- - - - - - - - - - - - - - - - -

So schwierig die formal richtige Definition des Moduls ist, so
trivial wird dadurch seine Einbindung: Im Hauptmodul AS.PAS mu· le-
diglich die USES-Liste um dieses Modul erweitert werden.  Ob
diese Modul auch als Overlay definiert werden soll, ist eine AbwÑ-
gung zwischen Geschwindigkeit und freiem Speicherplatz.


	Schreiben des eigentlichen Codegenerators
	- - - - - - - - - - - - - - - - - - - - -

Hier ist nun endlich eigene KreativitÑt gefragt: Wie Sie es schaffen,
aus dem Mnemonic und den Argumenten die Code-Bytes zu erzeugen, ist
weitgehend Ihnen Åberlassen.  Zur VerfÅgung stehen dafÅr natÅrlich
Åber den Formelparser die Symboltabellen sowie die Routinen aus
ASMSUB.  Ich kann hier nur einige generelle Regeln aufstellen:

  - Versuchen Sie, die Prozessorbefehle in Gruppen aufzusplitten, die
    gleiche Operanden erwarten und sich nur in einigen Kennbits unter-
    scheiden.  Alle argumentlosen Befehle kann man z.B. so in einer
    Tabelle abhandeln.

  - Die meisten Prozessoren haben ein festes Repertoire von Adres-
    sierungsarten.  Verlagern Sie das Parsing eines Adre·ausdrucks
    in eine getrennte Unterroutine.

  - Die Routine WrError definiert eine Vielzahl von mîglichen Fehler-
    meldungen und ist bei Bedarf leicht erweiterbar.  Nutzen Sie
    das!  Bei allen Fehler nur lapidar einen "Syntaxfehler" zu melden,
    nÅtzt niemandem!

Mit Sicherheit wird auch das Studium der vorhandenen Module weiter-
helfen.


	Modifikation der Dienstprogramme
	- - - - - - - - - - - - - - - -

Damit PLIST Codedateien weiterhin vollstÑndig anzeigen kann, mu· das
Feld mit den vorhandenen Code-Headern erweitert werden.

Sollte das Codesegment eine andere GranularitÑt als 1 Byte/Adresse
aufweisen (s. die Variable Grans oben), so mu· die Funktion Granula-
rity in TOOLS.PAS erweitert werden.  Damit P2HEX sich nicht mit einer
Fehlermeldung abmeldet, mu· noch entschieden werden, welches Hex-
Format defaultmÑ·ig fÅr diesen Prozessor verwendet werden soll.
P2HEX kennt bisher Motorola S-Records (bis 32-Bit-Adressen) sowie
Intel-, Tektronix- und MOS-HEX (16-Bit-Adressen).  Die CASE-Abfrage in
ProcessFile mu· nur entsprechend erweitert werden.


	H.4 RSC...was ist das denn?
	---------------------------

Falls es einmal erforderlich sein sollte, AS auf eine andere Sprache
anzupassen, sind sÑmtliche String-Konstanten im Programm zu Ñndern.
Damit dies einigerma·en leicht mîglich ist, finden sich diese konzen-
triert in den RSC-Dateien.  IOERRORS.RSC enthÑlt alle E/A-Fehlermel-
dungen und wird sowohl von AS als auch den Dienstprogrammen genutzt.
TOOLS.RSC enthÑlt die von allen Dienstprogrammen gleicherma·en be-
nîtigten Stringkonstanten.  Ansonsten hat jedes Programm seine eigene
Datei.  Solange Sie nicht vorhaben, AS in eine andere Sprache zu
Åbersetzen, brauchen Sie sich nicht weiter um diese Dateien zu kÅm-
mern.


	I. Literaturhinweise/Referenzen
	===============================

[Williams]	Steve Williams:
		68030 Assembly Language Reference
		Addison-Wesley, Reading, Massachusetts, 1989

[AMD29K]	Advanced Micro Devices:
		AM29240, AM29245, and AM29243 RISC Microcontrollers.
		1993

[AtAVR]         Atmel Corp.:
                AVR Enhanced RISC Microcontroller Data Book.
                May 1996

[CMD816]  	CMD Microcircuits:
		G65SC802/G65SC816 CMOS 8/16-Bit Microprocessor
		Family Data Sheet.

[CPM68K]  	Digital Research:
		CP/M 68K Operating System User's Guide
        	1983

[Cyrix]  	Cyrix Corp.:
		FasMath 83D87 User's Manual
		1990

[Dallas320]  	Dallas Semiconductor:
		DS80C320 High-Speed Micro User's Guide.
		Version 1.30, 1/94

[Hit180]  	Hitachi Ltd.:
		8-/16-Bit Microprocessor Data Book
		1986

[Hit63]  	Trevor J.Terrel & Robert J. Simpson:
		Understanding HD6301X/03X CMOS Microprocessor Systems
		erschienen bei Hitachi

[HitH8_3]  	Hitachi Microcomputer:
		H8/300H Series Programming Manual.
		(21-032, keine Jahresangabe)

[SH7000] 	Hitachi Semiconductor Design & Development Center:
		SH Microcomputer Hardware Manual (Preliminary)

[HitH8_5] 	Hitachi Semiconductor and IC Div:
        	H8/500 Series Programming Manual
        	(21-20, 1st Edition Feb. 1989)

[HitH8_532] 	Hitachi Ltd.:
        	H8/532 Hardware Manual
		(21-30, keine Jahresangabe)

[HitH8_534] 	Hitachi Ltd.:
        	H8/534,H8/536 Hardware Manual
		(21-19A, keine Jahresangabe)

[PPC403] 	IBM Corp.:
		PPC403GA Embedded Controller User's Manual.
        	First Edition, September 1994

[Int251]        Intel Corp.:
                8XC251SB High Performance CHMOS Single-Chip
                Microcontroller
                Sept. 1995, Order Number 272616-003

[IntEmb] 	Intel Corp.:
		Embedded Controller Handbook
		1987

[IntMic] 	Intel Corp.:
		Microprocessor and Peripheral Handbook.
		Volume I Microprocessor
		1988

[Kaku] 		Hirotsugu Kakugawa:
		A memo on the secret features of 6309.
        	(erhÑltlich Åber World Wide Web:
        	http://www.cs.umd.edu/users/fms/comp/CPUs/6309.txt)

[MicroChip] 	Microchip Technology Inc.:
		Microchip Data Book.
		1993 Edition

[Mit41] 	Mitsubishi Electric:
		Single-Chip 8-Bit Microcomputers.
        	Vol.2, 1987

[Mit16] 	Mitsubishi Electric:
		Single-Chip 16-Bit Microcomputers.
		Enlarged edition, 1991

[Mit8] 		Mitsubishi Electric:
		Single-Chip 8 Bit Microcomputers.
        	Vol.2, 1992

[Mit4500] 	Mitsubishi Electric:
		M34550Mx-XXXFP Users's Manual.
		Jan. 1994

[MitM16] 	Mitsubishi Electric:
        	M16 Family Software Manual.
        	First Edition, Sept. 1994

[MitM16C] 	Mitsubishi Electric:
        	M16C Software Manual.
        	First Edition, Rev. C, 1996

[Mit30600]      Mitsubishi Electric:
                M30600-XXXFP Data Sheet
                First Edition, April 1996

[GreenM16] 	Dokumentation zum M16/M32-Entwicklungspaket von Green
     		Hills Software

[MotMic] 	Motorola Inc.:
		Microprocessor, Microcontroller and Peripheral Data.
		Vol. I+II, 1988

[Mot81] 	Motorola Inc.:
		MC68881/882 Floating Point Coprocessor User's Manual.
		Second Edition, Prentice-Hall, Englewood Cliffs 1989

[Mot51] 	Motorola Inc.:
		MC68851 Paged Memory Management Unit User's Manual.
		Second Edition, Prentice-Hall, Englewood Cliffs 1989,1988

[Mot32] 	Motorola Inc.:
		CPU32 Reference Manual.
        	Rev. 1, 1990

[Mot56] 	Motorola Inc.:
		DSP56000/DSP56001 Digital Signal Processor User's Manual.
		Rev. 2, 1990

[Mot340] 	Motorola Inc.:
		MC68340 Technical Summary.
        	Rev. 2, 1991

[Mot16]         Motorola Inc.:
                CPU16 Reference Manual.
                Rev. 1, 1991

[Mot332] 	Motorola Inc.:
		MC68332 Technical Summary.
        	Rev. 2, 1993

[Mot601] 	Motorola Inc.:
		PowerPC 601 RISC Microprocessor User's Manual.
		1993

[Mot505]	Motorola Inc.:
		PowerPC(tm) MPC505 RISC Microcontroller Technical Summary.
        	1994

[Mot12]         Motorola Inc.:
                CPU12 Reference Manual.
                1st edition, 1996

[Mot08]         Motorola Inc.:
                CPU08 Reference Manual.
                Rev. 1 (keine Jahresangabe im PDF-File)

[Mot360]        Motorola Inc:
                MC68360 User's Manual

[AsmCop]        National Semiconductor:
                COP800 Assembler/Linker/Librarian User's Manual.
                Customer Order Number COP8-ASMLNK-MAN
                NSC Publication Number 424421632-001B
                August 1993

[Cop87L84]      National Semiconductor:
                COP87L84BC microCMOS One-Time-Programmable (OTP) Microcontroller.
                Preliminary, March 1996

[NECV] 		NEC Corp.:
		ÊpD70108/ÊpD70116/ÊpD70208/ÊpD70216/ÊpD72091 Data Book.
		(keine Jahresangabe)

[NEC78] 	NEC Electronics Europe GmbH:
		User's Manual ÊCOM-87 AD Family.
		(keine Jahresangabe)

[NEC75] 	NEC Corp.:
		ÊCOM-75x Family 4-bit CMOS Microcomputer User's Manual.
        	Vol. I+II (keine Jahresangabe)

[NEC78]         NEC Corp.:
                ÊPD78070A, 78070AY 8-Bit Single-Chip Microcontroller
                User's Manual.
                Document No. U10200EJ1V0UM00 (1st edition), August 1995

[NEC7814]       NEC Corp.:
                Data Sheet $\mu$PD78014.

[PhilXA]        Philips Semiconductor: 
                16-bit 80C51XA Microcontrollers (eXtended Architecture)
                Data Handbook IC25, 1996

[SGS04] 	SGS-Thomson Microelectronics:
		8 Bit MCU Families EF6801/04/05 Databook.
		1st edition, 1989

[SGS62] 	SGS-Thomson Microelectronics:
		ST6210/ST6215/ST6220/ST6225 Databook.
		1st edition, 1991

[Siem166] 	Siemens AG:
		SAB80C166/83C166 User's Manual.
		Edition 6.90

[Siem167] 	Siemens AG:
		SAB C167 Preliminary User's Manual.
		Revision 1.0, July 1992

[Syb68K] 	C.Vieillefond:
		Programmierung des 68000
		Sybex-Verlag DÅsseldorf, 1985

[TiC10] 	Texas Instruments:
		First-Generation TMS320 User's Guide.
		1988, ISBN 2-86886-024-9

[TiC20] 	Texas Instruments:
		TMS320C2x User's Guide.
		Revision C, Jan. 1993

[TiC30] 	Texas Instruments:
		TMS320C3x User's Guide.
		Revision E, 1991

[Ti370] 	Texas Instruments:
		TMS370 Family Data Manual.
		1994, SPNS014B

[Ti430FamSoft]  Texas Instruments:
                MSP430 Family Software User's Guide.
                1994, SLAUE11

[Ti430Met]      Texas Instruments:
                MSP430 Metering Application.
                1996, SLAAE10A

[Ti430FamArch]  Texas Instruments:
                MSP430 Family Architecture User's Guide.
                1995, SLAUE10A

[Tosh90] 	Toshiba Corp.:
		8-Bit Microcontroller TLCS-90 Development System Manual.
		1990

[Tosh870] 	Toshiba Corp.:
		8-Bit Microcontroller TLCS-870 Series Data Book.
		1992

[Tosh900] 	Toshiba Corp.:
		16-Bit Microcontroller TLCS-900 Series Users Manual.
		1992

[Tosh900L] 	Toshiba Corp.:
		16-Bit Microcontroller TLCS-900 Series Data Book:
		TMP93CM40F/TMP93CM41F
		1993

[Tosh47] 	Toshiba Corp.:
		4-Bit Microcontroller TLCS-47E/47/470/470A Development
		System Manual.
		1993

[Tosh9000] 	Toshiba Corp.:
		TLCS-9000/16 Instruction Set Manual Version 2.2
		10. Feb 1994

[Zilog] 	DatenblÑtter der Firma Zilog zur Z80-Familie

[ZilZ8] 	Zilog Inc.:
		Z8 Microcontrollers Databook.
		1992

[ZilZ380] 	Zilog Inc.:
		Z380 CPU Central Processing Unit User's Manual.
        	(keine Jahresangabe)

